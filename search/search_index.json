{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"firescript v0.1.1 Documentation","text":"<p>Note: The current compiler does not support all language features. Unsupported features are explicitly marked in each guide with Not yet implemented or Note.</p> <p>This directory contains guides for firescript language features. Each guide notes incomplete functionality with Not yet implemented.</p> <ul> <li>Types &amp; Variables</li> <li>Arrays</li> <li>Control Flow</li> <li>Functions &amp; Methods</li> <li>Classes &amp; Inheritance</li> </ul>"},{"location":"arrays/","title":"Arrays","text":"<p>Note: Only dynamic arrays with literal initialization and methods <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, and <code>length</code> are supported by the compiler. Array slicing, negative indices, and other utility methods are not implemented.</p> <p>firescript supports dynamic arrays similar to Python lists.</p>"},{"location":"arrays/#declaration","title":"Declaration","text":"<pre><code>int[] nums = [1, 2, 3]\nstring[] words = []\n</code></pre>"},{"location":"arrays/#operations","title":"Operations","text":"<ul> <li><code>append(element)</code> \u2013 add to end</li> <li><code>insert(index, element)</code> \u2013 insert at position</li> <li><code>pop(index?)</code> \u2013 remove and return element; default removes last</li> <li><code>clear()</code> \u2013 remove all elements</li> <li><code>length</code> \u2013 property for size</li> </ul> <pre><code>nums.append(4)\nprint(nums.pop(0))\nprint(nums)\n</code></pre>"},{"location":"arrays/#not-yet-implemented","title":"Not yet implemented","text":"<ul> <li>Array slicing (<code>arr[start:end:step]</code>)</li> <li>Negative indices (e.g., <code>arr[-1]</code>)</li> <li><code>remove(value)</code> \u2013 remove by value</li> <li><code>index(value)</code> \u2013 get index of a value</li> <li><code>count(value)</code> \u2013 count occurrences of a value</li> <li><code>sort()</code> \u2013 sort the array</li> </ul>"},{"location":"classes/","title":"Classes &amp; Inheritance","text":"<p>Note: Class definitions, inheritance, and methods are currently not supported by the compiler.</p> <p>firescript provides class definitions, constructors, instance/static methods, and single inheritance.</p>"},{"location":"classes/#defining-a-class","title":"Defining a Class","text":"<pre><code>class Person {\n    string name;\n    nullable int age;\n\n    // Constructor: 'this' is the instance\n    Person(this, string name, int age) {\n        this.name = name\n        this.age = age\n    }\n\n    // Instance method\n    string getName(this) {\n        return this.name\n    }\n\n    // Static method\n    static string species() {\n        return \"Homo sapiens\"\n    }\n}\n</code></pre>"},{"location":"classes/#inheritance","title":"Inheritance","text":"<pre><code>class Student from Person {\n    string school;\n\n    Student(this, string name, int age, string school) {\n        super.Student(name, age)  // call parent constructor\n        this.school = school\n    }\n\n    string getSchool(this) {\n        return this.school\n    }\n}\n</code></pre>"},{"location":"classes/#not-yet-implemented","title":"Not yet implemented","text":"<ul> <li>Interfaces and multiple inheritance</li> <li>Generics on classes</li> <li>Meta\u2011attributes and user\u2011defined annotations</li> <li>Access modifiers (<code>public</code>, <code>private</code>, <code>protected</code>)</li> <li>Abstract classes and methods</li> </ul>"},{"location":"control_flow/","title":"Control Flow","text":"<p>Note: Only <code>if</code>/<code>else</code> chains and <code>while</code> loops are currently supported. C-style <code>for</code> loops, for-in loops, range loops, and the ternary operator are not supported by the compiler.</p> <p>firescript supports structured control flow constructs.</p>"},{"location":"control_flow/#conditional-statements","title":"Conditional Statements","text":"<pre><code>if condition {\n    // then-branch\n} else if otherCondition {\n    // else-if branch\n} else {\n    // else branch\n}\n</code></pre>"},{"location":"control_flow/#loops","title":"Loops","text":""},{"location":"control_flow/#while-loops","title":"While Loops","text":"<pre><code>while condition {\n    // body\n}\n</code></pre>"},{"location":"control_flow/#c-style-for-loops","title":"C-style For Loops","text":"<pre><code>for (int i = 0; i &lt; n; i++) {\n    // body\n}\n</code></pre>"},{"location":"control_flow/#for-in-loops","title":"For-In Loops","text":"<pre><code>for (ElementType elem : array) {\n    // body\n}\n</code></pre>"},{"location":"control_flow/#range-loops","title":"Range Loops","text":"<pre><code>for (int i : range(end)) {\n    // 0 to end-1\n}\n</code></pre>"},{"location":"control_flow/#loop-control","title":"Loop Control","text":"<ul> <li><code>break</code> \u2013 exit loop</li> <li><code>continue</code> \u2013 next iteration</li> </ul>"},{"location":"control_flow/#ternary-operator","title":"Ternary Operator","text":"<pre><code>int max = ternary a &gt; b then a else b\n</code></pre>"},{"location":"control_flow/#not-yet-implemented","title":"Not yet implemented","text":"<ul> <li><code>for</code> loops (<code>for</code>, <code>for-in</code>, <code>range</code>)</li> <li>Ternary operator</li> <li><code>switch</code> / <code>case</code> statements</li> <li>Enhanced range parameters (<code>start</code>, <code>step</code>, <code>inclusive</code>)</li> <li>Comprehensions</li> </ul>"},{"location":"functions/","title":"Functions &amp; Methods","text":"<p>Note: User-defined function definitions, methods on objects, optional or named parameters, variadic parameters, and function overloading are currently not supported by the compiler.</p> <p>firescript supports both built-in and user-defined functions, as well as methods on objects and arrays.</p>"},{"location":"functions/#built-in-functions","title":"Built-in Functions","text":"<ul> <li><code>print(value)</code> \u2013 output a value</li> <li><code>input(prompt)</code> \u2013 read string from console</li> <li><code>toInt(x)</code>, <code>toFloat(x)</code>, <code>toDouble(x)</code>, <code>toBool(x)</code>, <code>toString(x)</code>, <code>toChar(x)</code> \u2013 conversions</li> <li><code>typeof(x)</code> \u2013 returns type name</li> </ul>"},{"location":"functions/#user-defined-functions","title":"User-defined Functions","text":"<pre><code>int add(int a, int b) {\n    return a + b\n}\n\nfloat average(int a, int b) {\n    // optional parameters not yet implemented\n    return toFloat(a + b) / 2.0\n}\n</code></pre> <ul> <li>Define with return type, name, parameters, and body.</li> <li><code>void</code> functions: use <code>void</code> as return type.</li> </ul>"},{"location":"functions/#methods","title":"Methods","text":"<ul> <li>Instance methods take <code>this</code> as first parameter</li> <li>Static methods: use <code>static</code> keyword</li> </ul> <pre><code>class Person {\n    string name;\n    Person(this, string name) {\n        this.name = name\n    }\n    static string greet() {\n        return \"Hello\"\n    }\n}\n</code></pre>"},{"location":"functions/#array-methods","title":"Array Methods","text":"<p>See Arrays.</p>"},{"location":"functions/#not-yet-implemented","title":"Not yet implemented","text":"<ul> <li>Default or named arguments in functions</li> <li>Variadic parameters</li> <li>First-class function types and closures</li> </ul>"},{"location":"scoping/","title":"Scoping in firescript","text":"<p>In firescript, scopes define the visibility and lifetime of variables. Understanding how scopes work is crucial for writing correct and predictable code.</p>"},{"location":"scoping/#scope-creation","title":"Scope Creation","text":"<p>A new scope is created by any set of curly braces <code>{}</code>. This includes:</p> <ul> <li>Control Flow Statements: The bodies of <code>if</code>, <code>else if</code>, <code>else</code>, <code>for</code>, <code>while</code>, and other control flow statements each create their own scope.</li> <li>Function Bodies: The body of a function defines a scope.</li> <li>Class Bodies: The body of a class defines a scope.</li> <li>Bare Braces: You can create an explicit scope simply by using a pair of curly braces <code>{}</code> anywhere they are syntactically allowed.</li> </ul> <pre><code>// Global scope\n\nint globalVar = 10;\n\nif (globalVar &gt; 5) {\n    // Inner scope 1 (if body)\n    int innerVar1 = 20;\n    print(globalVar); // Accessing outer scope variable: OK (prints 10)\n    print(innerVar1); // Accessing current scope variable: OK (prints 20)\n}\n\n// print(innerVar1); // ERROR: innerVar1 is not accessible here\n\n{\n    // Inner scope 2 (bare braces)\n    int innerVar2 = 30;\n    print(globalVar); // Accessing outer scope variable: OK (prints 10)\n    print(innerVar2); // Accessing current scope variable: OK (prints 30)\n\n    if (true) {\n        // Inner scope 3 (nested if body)\n        int innerVar3 = 40;\n        print(globalVar); // OK (prints 10)\n        print(innerVar2); // OK (prints 30)\n        print(innerVar3); // OK (prints 40)\n    }\n    // print(innerVar3); // ERROR: innerVar3 is not accessible here\n}\n\n// print(innerVar2); // ERROR: innerVar2 is not accessible here\n</code></pre>"},{"location":"scoping/#scope-hierarchy-and-variable-access","title":"Scope Hierarchy and Variable Access","text":"<ul> <li>Outer Scope Access: An inner scope can access variables declared in any of its enclosing (outer) scopes, all the way up to the global scope.</li> <li>Inner Scope Isolation: An outer scope cannot access variables declared within any of its inner scopes. Once a scope block is exited, all variables declared directly within that scope are destroyed and become inaccessible.</li> <li>Variable Shadowing: Variable shadowing is not allowed. firescript will throw an error if you try to declare a variable with the same name in an inner scope that already exists in an outer scope. This is to prevent confusion and ensure that the intended variable is always accessed.</li> </ul> <p>This strict scoping rule helps prevent errors related to variables potentially being uninitialized or accessed outside their intended lifetime. It ensures that if a variable name exists within a scope, it is guaranteed to have been properly declared either in the current scope or an outer one.</p>"},{"location":"type_system/","title":"Type System in firescript","text":"<p>firescript employs a static type system to enhance code reliability and catch errors early during the compilation phase. This means that the type of every variable and expression is checked before the code is run.</p>"},{"location":"type_system/#built-in-types","title":"Built-in Types","text":"<p>firescript provides several fundamental data types:</p> <ul> <li><code>int</code>: Represents whole numbers (integers). Example: <code>int age = 30;</code></li> <li><code>float</code>: Represents single-precision floating-point numbers. Example: <code>float price = 19.95f;</code></li> <li><code>double</code>: Represents double-precision floating-point numbers, offering higher precision than <code>float</code>. Example: <code>double pi = 3.1415926535;</code></li> <li><code>bool</code>: Represents boolean values, either <code>true</code> or <code>false</code>. Example: <code>bool isActive = true;</code></li> <li><code>string</code>: Represents sequences of characters. Example: <code>string message = \"Hello, World!\";</code></li> <li><code>char</code>: Represents a single character. (Note: Currently handled similarly to strings in some contexts, formal <code>char</code> type might be refined). Example: <code>char initial = 'A';</code></li> <li><code>void</code>: Represents the absence of a type, primarily used as the return type for functions that do not return a value.</li> </ul>"},{"location":"type_system/#arrays","title":"Arrays","text":"<p>Arrays are ordered collections of elements of the same type.</p> <ul> <li> <p>Declaration: Use square brackets <code>[]</code> after the type name.</p> <p><code>firescript int[] scores = [10, 20, 30]; string[] names = [\"Alice\", \"Bob\"];</code></p> </li> <li> <p>Access: Use square brackets with an integer index (0-based).</p> <p><code>firescript int firstScore = scores[0]; // firstScore is 10</code></p> </li> <li> <p>Type Checking: The type checker ensures that you only assign arrays of the correct element type and access elements correctly. Array literals must contain elements of a consistent type.</p> </li> </ul>"},{"location":"type_system/#nullability","title":"Nullability","text":"<p>By default, variables cannot hold the value <code>null</code>. To allow a variable to be assigned <code>null</code>, you must explicitly declare it as <code>nullable</code>.</p> <ul> <li> <p>Declaration: Use the <code>nullable</code> keyword before the type.</p> <p>```firescript nullable string username = null; // Allowed string title = \"Default\";</p> <p>title = null; // Error: Cannot assign null to non-nullable type 'string'</p> <p>username = \"John\"; // Can be assigned a non-null value later ```</p> </li> <li> <p>Type Checking: The type checker prevents assigning <code>null</code> to non-nullable variables and helps avoid null reference errors.</p> </li> </ul>"},{"location":"type_system/#type-checking-and-enforcement","title":"Type Checking and Enforcement","text":"<p>The firescript parser includes a type-checking phase that runs after the initial syntax parsing.</p> <ol> <li>Variable Declarations: When you declare a variable (<code>int x = 5;</code>), the type checker verifies that the type of the initializer (<code>5</code>, which is <code>int</code>) matches the declared type (<code>int</code>).</li> <li>Assignments: When assigning a value to an existing variable (<code>x = 10;</code>), the checker ensures the assigned value's type is compatible with the variable's declared type.</li> <li>Expressions: Operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&gt;</code>, etc.) are checked to ensure they are used with compatible operand types. For example, arithmetic operators generally require numeric types (<code>int</code>, <code>float</code>, <code>double</code>), while <code>+</code> can also be used for string concatenation. The result type of an expression is also determined (e.g., <code>1 + 2.0</code> results in a <code>float</code>).</li> <li>Function Calls: Arguments passed to functions are checked against the expected parameter types. The return value type is also enforced.</li> <li>Method Calls: Similar to functions, arguments and the object the method is called on are type-checked.</li> <li>Array Operations: Indexing requires an integer, and assigning elements requires matching the array's element type.</li> </ol> <p>Type errors found during this phase will prevent the code from compiling further, providing early feedback on potential issues.</p>"},{"location":"variables/","title":"Types &amp; Variables","text":"<p>Note: Tuple types, the generic placeholder <code>T</code>, and declarations without an initializer are not supported by the compiler. Only built-in primitive types (<code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>string</code>, <code>char</code>) are fully implemented.</p> <p>firescript supports the following built-in types:</p> <ul> <li>Numeric: <code>int</code>, <code>float</code>, <code>double</code></li> <li>Boolean: <code>bool</code> (<code>true</code>, <code>false</code>)</li> <li>Text: <code>string</code>, <code>char</code></li> <li>Composite: <code>tuple&lt;T1, T2, \u2026&gt;</code></li> <li>Generic placeholder: <code>T</code></li> </ul>"},{"location":"variables/#declaration-and-initialization","title":"Declaration and Initialization","text":"<pre><code>int age = 30\nnullable string name = null\nconst float PI = 3.14\ntuple&lt;int, string&gt; pair = (1, \"two\")\n</code></pre> <ul> <li>Use <code>nullable</code> to allow a variable to hold <code>null</code>.</li> <li>Use <code>const</code> to declare read-only bindings.</li> <li>Not yet implemented: full support for tuple operations and generic type inference.</li> </ul>"}]}