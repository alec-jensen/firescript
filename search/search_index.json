{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"firescript v0.3.0 Documentation","text":"<p>This documentation is being used for the most part as a reference for planning the direction of the firescript language and its features. The compiler is still in early development, so many features are not yet implemented, or are implemented differently than described here. Nothing here should be considered final until the language reaches a stable 1.0.0 release.</p> <p>This documentation is organized to help both newcomers and experienced developers understand and use the firescript language effectively.</p>"},{"location":"#1-language-reference-manual","title":"1. Language Reference Manual","text":"<ul> <li>Type System - Formal definition of types, nullability, arrays</li> <li>Scoping Rules - Variable visibility, lifetime, and scope creation</li> <li>Control Flow - Conditional statements and loops</li> </ul>"},{"location":"#2-getting-started-tutorials","title":"2. Getting Started &amp; Tutorials","text":"<ul> <li>Types &amp; Variables - Basic variable declarations and types</li> <li>Arrays - Working with array data structures</li> <li>Functions &amp; Methods - Built-in functions and user-defined functions</li> </ul>"},{"location":"#3-language-features","title":"3. Language Features","text":"<ul> <li>Classes &amp; Inheritance - Object-oriented programming fundamentals</li> </ul>"},{"location":"#4-standard-library-reference","title":"4. Standard Library Reference","text":"<p>Standard library does not yet exist.</p>"},{"location":"#5-examples","title":"5. Examples","text":"<p>Check the <code>/examples</code> directory for complete code samples:</p> <ul> <li>Basic usage of built-in functions</li> <li>Fibonacci sequence implementation</li> <li>Array manipulation</li> <li>Scope and variable visibility demonstrations</li> </ul>"},{"location":"#6-benchmarks","title":"6. Benchmarks","text":"<p>See the Benchmarks page for performance comparisons with other languages.</p>"},{"location":"#7-changelog","title":"7. Changelog","text":"<p>For the latest updates and changes to the firescript language, see the changelog.</p>"},{"location":"#implementation-status","title":"Implementation Status","text":"<p>firescript is under active development. Key limitations in the current compiler version:</p> <ul> <li>\u274c Some types are supported: Copyable types (<code>bool</code>, <code>char</code>), Owned types (<code>string</code>, arrays), and numeric types (<code>intN</code>, <code>floatN</code>) are planned.</li> <li>\u2705 Static type checking for expressions and assignments.</li> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, and type conversions.</li> <li>\u274c User-defined functions are not yet implemented.</li> <li>\u274c Classes and inheritance are planned but not implemented.</li> <li>\u274c Advanced array features like slicing and negative indices are not supported.</li> <li>\u274c Control flow is limited to <code>if</code>/<code>else</code> and <code>while</code> loops; <code>for</code> loops and <code>switch</code> statements are not implemented.</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#recursive-fibonacci","title":"Recursive Fibonacci","text":"<p>Algorithm pseudo\u2011code:</p> <pre><code>function fibonacci(n) {\n    if n &lt;= 1 {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfibonacci(47)\n</code></pre> <p>Fibonacci of 47 is used to provide a reasonable runtime for comparison. Test is run 5 times and the average time is reported. Tests are run on an AMD Ryzen 7 5800H processor. These tests were run against the latest stable releases of each language's compiler/interpreter as of October 2025.</p> Language Time (seconds) C 3.5s (avg) firescript \u2b50 4.2s (avg) Rust 5.8s (avg) Zig 6.5s (avg) Go 13.2s (avg)"},{"location":"changelog/","title":"Changelog","text":"<p>firescript follows Semantic Versioning. This makes it easier to understand the impact of changes in each release.</p>"},{"location":"changelog/#currently-in-development","title":"Currently in development","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed built-in <code>input()</code> function. User input functionality should be implemented via the standard library or external libraries.</li> </ul>"},{"location":"changelog/#compiler-improvements","title":"Compiler improvements","text":"<ul> <li>Bug fixes</li> </ul>"},{"location":"changelog/#040-phoenix","title":"0.4.0 - Phoenix","text":"<p>February 2, 2026</p> <p>Starting with 0.4.0, releases will now be named.</p>"},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Removed legacy numeric aliases: <code>int</code>, <code>float</code>, and <code>double</code>.<ul> <li>Use explicit-width types instead: <code>int8|16|32|64</code>, <code>uint8|16|32|64</code>, and <code>float32|64|128</code>.</li> <li>Integer literals default to <code>int32</code> when unsuffixed.</li> <li>No implicit numeric promotions. Arithmetic and comparisons require operands of the exact same type.</li> <li>Modulo (<code>%</code>) is defined only for integer types.</li> </ul> </li> <li>Beginning memory management implementation</li> <li>Remove type conversion functions in favor of future Java-style casting.</li> <li>Removed built-in <code>print()</code> function in favor of <code>std.io.print()</code> and <code>std.io.println()</code>.</li> <li>Arrays are now fixed-size. Future dynamic arrays will be in the standard library.</li> <li>Beginning of memory management implementation. See Memory Management for details.</li> </ul>"},{"location":"changelog/#new-language-features","title":"New Language Features","text":"<ul> <li>Fixed-width numeric types across the board:<ul> <li>Integers: <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>.</li> <li>Floats: <code>float32</code>, <code>float64</code>, <code>float128</code>.</li> </ul> </li> <li>Literal suffixes for precise typing:<ul> <li>Integers: <code>i8/i16/i32/i64</code> and <code>u8/u16/u32/u64</code> (e.g., <code>42i8</code>, <code>7u32</code>).</li> <li>Floats: <code>f32</code>, <code>f64</code>, <code>f128</code> (e.g., <code>3.14f32</code>, <code>2.0f64</code>, <code>1.0f128</code>).</li> </ul> </li> <li>String concatenation remains supported via <code>+</code> between two strings.</li> <li>Initial support for classes<ul> <li>Class definitions with fields, methods, and constructors.</li> <li>Object instantiation using <code>new</code> keyword.</li> <li>Method calls on class instances.</li> <li>Inheritance</li> </ul> </li> <li>Imports</li> <li>Casting (rust-like syntax <code>(87 as int8)</code>)<ul> <li>Currently only supported for numeric-&gt;numeric casts, and built-in types to string.</li> </ul> </li> <li>Generic functions</li> <li><code>std.math</code> library with basic math functions like <code>abs</code>, <code>min</code>, <code>max</code>, etc.</li> <li><code>std.io</code> library with <code>print</code> and <code>println</code> functions.</li> <li>C-style for loops and for-in loops.</li> <li>Added <code>--version</code> flag to the compiler for displaying version information.</li> </ul>"},{"location":"changelog/#compilerbackend-improvements","title":"Compiler/Backend Improvements","text":"<ul> <li>Name mangling in generated C code to prevent name collisions between multiple source files and built-in C functions.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>September 12, 2025</p>"},{"location":"changelog/#breaking-changes_2","title":"Breaking Changes","text":"<ul> <li><code>int</code> type is a native int again.<ul> <li>The <code>int</code> type is now a native <code>int64_t</code> type in the generated C code.</li> <li>This change improves performance and reduces complexity in the generated code.</li> <li>Arbitrary precision integer / decimal support has been removed from the core. Future optional library packages may re\u2011introduce them without impacting the core compiler.</li> </ul> </li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Function Definitions and Calls:<ul> <li>Added support for defining functions.</li> <li>Functions can be called by their name followed by parentheses.</li> <li>Functions can accept parameters and return values.</li> <li>Example:</li> </ul> </li> </ul> <pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Improved Variable Declaration Parsing:<ul> <li>Enhanced the parser to better handle nullable and const variable declarations.</li> </ul> </li> <li>Improved Error Handling:<ul> <li>Enhanced error messages for syntax and type errors.</li> <li>More context provided in error messages to help identify issues.</li> </ul> </li> <li>Refactored if-else parsing:<ul> <li>Improved the parsing logic for <code>if</code>, <code>else if</code>, and <code>else</code> statements.</li> <li>Better support for nested conditional statements.</li> </ul> </li> <li>Enhanced print function:<ul> <li>The <code>print</code> function correctly prints all primitive types.</li> </ul> </li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>May 8, 2025</p>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li> <p>Improved Syntax Handling and Error Reporting:</p> <ul> <li>Refactored the lexer and parser for enhanced syntax handling</li> <li>The lexer now correctly handles greater than (<code>&gt;</code>) and less than (<code>&lt;</code>) operators</li> <li>The parser includes stricter checks for Abstract Syntax Tree (AST) node children to prevent unexpected errors from <code>None</code> values</li> <li>Introduced new logic for parsing <code>if</code> and <code>while</code> statements to properly support nested structures</li> <li>Improved error messages with more context for syntax errors</li> </ul> </li> <li> <p>Memory Model Progress:</p> <ul> <li>Introduced an interim reference-counting mechanism for certain heap values (e.g., strings, arrays)</li> <li>This is a stepping stone toward the planned ownership + deterministic drop model (see Memory Management documentation)</li> <li>Improves leak resilience while compiler-based last-use drop insertion is under development</li> <li>Dynamic array resource reclamation aligned with deterministic drop goals</li> </ul> </li> <li> <p>Arbitrary Precision Integers:</p> <ul> <li>The <code>int</code> type is now represented using <code>mpz_t</code> in the generated code</li> <li>Enables arbitrary precision integers for handling large numbers</li> <li>Provides improved accuracy and reliability for complex calculations</li> <li>No practical limit to integer size (constrained only by available memory)</li> </ul> </li> <li> <p>Organized Build Outputs:</p> <ul> <li>Build outputs and temporary files are now stored in a dedicated <code>build</code> directory</li> <li>Temporary files are specifically located under <code>build/temp</code></li> <li>Cleaner project structure with separate directories for source, documentation, and build artifacts</li> </ul> </li> <li> <p>Expanded Array Operations:</p> <ul> <li>Added new array methods: <code>clear()</code> and improved <code>pop()</code> functionality</li> <li>Enhanced array bounds checking for safer indexing operations</li> <li>Optimized memory allocation for arrays to improve performance</li> </ul> </li> <li> <p>More Operators:</p> <ul> <li>Added support for compound assignment operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, and <code>%=</code></li> <li>Added support for increment (<code>++</code>) and decrement (<code>--</code>) operators</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed parser issue causing incorrect handling of complex nested expressions</li> <li>Addressed memory leak in string operations when concatenating multiple strings</li> <li>Corrected type checking for nullable values in conditional statements</li> <li>Fixed compilation errors in C code generation for complex boolean expressions</li> <li>Resolved issue with array element access in while loop conditions</li> </ul>"},{"location":"changelog/#code-quality-improvements","title":"Code Quality Improvements","text":"<ul> <li>Comprehensive refactoring of the C code generator for improved maintainability</li> <li>Added more detailed debug logging throughout the compilation process</li> <li>Improved documentation with examples for all supported language features</li> <li>Enhanced test coverage with new test cases for core functionality</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>January 2025</p> <p>There is not a version 0.1.0 because of a versioning mishap during initial release.</p>"},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li> <p>Enhanced Variable Scoping:</p> <ul> <li>Strict enforcement of variable scoping rules</li> <li>Prevention of variable shadowing to avoid common programming errors</li> <li>Clear error messages for scope-related issues</li> </ul> </li> <li> <p>Improved Type System:</p> <ul> <li>Comprehensive type checking for variable assignments</li> <li>Type compatibility verification for expressions</li> <li>Function and method call parameter validation</li> <li>Support for nullable types with explicit declaration</li> </ul> </li> <li> <p>Control Flow Structures:</p> <ul> <li>Basic implementation of <code>if</code>, <code>else if</code>, and <code>else</code> statements</li> <li>Support for <code>while</code> loops with condition checking</li> <li><code>break</code> and <code>continue</code> statements in loops</li> </ul> </li> <li> <p>Basic Standard Library:</p> <ul> <li>Implementation of essential built-in functions:</li> <li><code>print()</code> for output (note: later moved to standard library)</li> <li>Type conversion functions (<code>toInt()</code>, <code>toFloat()</code>, <code>toString()</code>, etc.)</li> <li><code>typeof()</code> function for runtime type introspection</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Resolved parsing issues for nested expressions</li> <li>Fixed incorrect operator precedence in complex expressions</li> <li>Addressed memory management issues in the runtime library</li> </ul>"},{"location":"changelog/#001","title":"0.0.1","text":"<p>November 2024</p>"},{"location":"changelog/#initial-release","title":"Initial Release","text":"<ul> <li>First Public Alpha:</li> <li>Basic language structure and syntax</li> <li>Simple variable declarations with primitive types</li> <li>Arithmetic and logical operations</li> <li> <p>First iteration of the compilation pipeline</p> </li> <li> <p>Array Support:</p> </li> <li>Initial implementation of arrays with literal initialization</li> <li>Basic array operations: indexing, assignment</li> <li> <p>Simple array methods: <code>append()</code> and <code>insert()</code></p> </li> <li> <p>Compiler Infrastructure:</p> </li> <li>Lexer for tokenizing source code</li> <li>Parser for building the abstract syntax tree</li> <li>Simple C code generator for compilation</li> <li>Runtime library with basic functions</li> </ul>"},{"location":"firescript_philosophy/","title":"firescript Philosophy","text":"<p>firescript is intended to be a simple but powerful and fast language with safety by design. This is accomplished through a strict type system, explicit design, and simple to learn but powerful compile-time memory management. It is intended to be usable in a variety of domains, from systems programming to web development, as it compiles to a C backend or JavaScript + WebAssembly in the future.</p>"},{"location":"firescript_philosophy/#key-principles","title":"Key Principles","text":"<ul> <li>Simplicity: The language syntax and semantics are designed to be easy to learn and understand, minimizing complexity while maximizing expressiveness.</li> <li>Safety: Strong static typing, null safety, and compile-time checks help prevent common programming errors.</li> <li>Null safety is enforced by default; nullable types must be explicitly declared.</li> <li>Memory safety is ensured through compile-time ownership and borrowing rules, preventing issues like dangling pointers</li> <li>There is no undefined behavior; all operations are well-defined.</li> <li>Performance: Although the syntax is high-level, firescript is designed to compile to efficient low-level code, with no runtime overhead.</li> <li>Explicitness: The language favors explicit declarations and operations over implicit behavior, making code easier to read and reason about.</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>GCC (other compilers may work, but GCC is recommended)</li> <li>Python 3 (firescript generally targets the latest version of Python)</li> </ul> <p>Supported Platforms: - Linux - Windows (via MSYS2, WSL is not officially supported but may work)</p> <p>Note: The compiler is developed in Fedora Linux and Windows environments. As it is currently under active development, there may be platform-specific issues. If you encounter any problems on your platform, please report them in the issue tracker. Contributions to improve cross-platform compatibility are also welcome.</p>"},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#linux","title":"Linux","text":"<pre><code># Debian/Ubuntu\nsudo apt-get install gcc python3 libgmp-dev libmpfr-dev\n\n# Fedora/RHEL/CentOS\nsudo dnf install gcc python3 gmp-devel mpfr-devel\n\n# Arch/Manjaro\nsudo pacman -S gcc python3 gmp mpfr\n\n# Clone the repository\ngit clone https://github.com/alec-jensen/firescript.git\ncd firescript\n</code></pre>"},{"location":"getting_started/#windows","title":"Windows","text":"<p>Install python</p> <p>Install GCC via MSYS2:</p> <p>Open the MSYS2 UCRT64 terminal and run:</p> <pre><code>pacman -Syu\npacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain\n</code></pre> <p>Add <code>C:\\msys64\\ucrt64\\bin</code> to your system PATH.</p> <p>Clone the repository</p> <pre><code>git clone https://github.com/alec-jensen/firescript.git\ncd firescript\n</code></pre>"},{"location":"getting_started/#compiling-and-running-a-program","title":"Compiling and Running a Program","text":"<pre><code># Compile a firescript program\npython3 firescript/firescript.py program.fire\n\n# Execute the compiled program\n./output/program\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":"<p>This glossary contains definitions of terms commonly used in the firescript documentation. For authoritative rules on ownership and lifetimes see Memory Management.</p>"},{"location":"glossary/#memory-management-terms","title":"Memory Management Terms","text":"Term Definition Copyable Fixed-size value with no destructor; copied bitwise. Owned Resource/heap-managing value with unique ownership semantics. Move Transfer of ownership; original binding becomes invalid. Borrow (<code>&amp;T</code>) Read-only, non-owning view whose lifetime is limited to an expression or call boundary. Clone Explicit duplication of an owned value\u2019s contents (deep or COW per type). Drop Deterministic destruction at an inserted point (last use or scope exit). Module A piece of firescript code that is imported or included in another firescript file. Package A module or collection of modules that is installed via the package manager. Library A module or collection of modules that is provided with the firescript installation."},{"location":"glossary/#expanded-definitions","title":"Expanded Definitions","text":"<ul> <li>Copyable: Includes <code>intN</code>, <code>floatN</code>, <code>bool</code>, and <code>char</code>. These are fixed-size scalars stored on the stack. Copies are bitwise; no destructor runs.</li> <li>Owned: Includes user-defined objects, closures, arrays, and strings. These values are stored on the heap with pointers on the stack. Ownership is unique unless an explicit sharing container (future <code>Rc</code>, <code>Arc</code>) is used.</li> <li>Move: Occurs on assignment, passing to a parameter of owned type, or returning a value. After a move, the source binding cannot be used (use-after-move error).</li> <li>Borrow: Lightweight, read-only access. Cannot be stored in owned fields or escape its originating scope/call. Does not incur runtime overhead.</li> <li>Clone: Creates an independent owned value. Semantics (deep vs copy-on-write) determined by the type implementation but always preserves logical independence.</li> <li>Drop: Compiler-inserted destructor invocation (<code>drop(this)</code>) ensuring timely resource release (files, sockets, buffers) without tracing GC.</li> <li>Module: A single <code>.fire</code> file or a collection of files that can be imported. Modules encapsulate code and can expose public APIs.</li> <li>Package: A distributable unit of code, often hosted in a package registry. Packages can contain multiple modules and dependencies.</li> <li>Library: A set of pre-written modules provided with the firescript installation, offering standard functionality (e.g., <code>std.io</code>, <code>std.math</code>).</li> </ul>"},{"location":"internal/","title":"Internal Documentation","text":"<p>This is documentation for internal language features intended for use in the compiler and standard library. These are not intended for use in user code, as these features require careful handling to be used safely and correctly.</p>"},{"location":"internal/directives/","title":"compiler directives","text":"<p>compiler directives are special instructions to the compiler that affect compilation behavior. They are not part of the runtime language and do not produce any code themselves.</p> <p>Directives are not intended to be used in source files except in specific scenarios (e.g., enabling syscalls in the standard library). They are primarily for internal use by the compiler and standard library.</p>"},{"location":"internal/directives/#directive-syntax","title":"Directive Syntax","text":"<pre><code>directive &lt;name&gt; [&lt;arg1&gt; [, &lt;arg2&gt; ...]];\n</code></pre> <ul> <li><code>directive</code> keyword starts the directive.</li> <li><code>&lt;name&gt;</code> is the name of the directive (e.g., <code>enable_syscalls</code>).</li> <li>Optional arguments can be provided, separated by commas.</li> </ul>"},{"location":"internal/directives/#examples","title":"Examples","text":"<ul> <li>Enable syscalls in a file:</li> </ul> <pre><code>directive enable_syscalls;\n</code></pre> <ul> <li>Enable compiler-inserted drops (preprocessor inserts drop() calls):</li> </ul> <p>Should ONLY be used internally by the preprocessor.</p> <pre><code>directive enable_drops;\n</code></pre>"},{"location":"internal/directives/#available-directives","title":"Available Directives","text":"<ul> <li><code>enable_syscalls</code>: Allows the use of syscalls in the file. This is required for files in the standard library that need syscall access (e.g. std.io).</li> <li><code>enable_drops</code>: Enables the preprocessor to insert deterministic drop() calls for Owned values (e.g., arrays) at scope boundaries and early exits.</li> <li><code>enable_lowlevel_stdout</code>: Allows the use of low-level stdout function.</li> <li><code>enable_lowlevel_stdin</code>: Allows the use of low-level stdin function.</li> </ul>"},{"location":"internal/syscalls/","title":"syscalls docs","text":"<p>Syscalls are only intended to be used in the standard library. When we need them in the standard library, you add this directive at the top of the file:</p> <pre><code>directive enable_syscalls;\n</code></pre>"},{"location":"internal/syscalls/#available-syscalls","title":"Available Syscalls","text":"<p>Enabling syscalls gives you access to the following functions:</p> Syscall Description syscall_open(path, mode) Opens a file at <code>path</code> with the given <code>mode</code> (\"r\", \"w\", \"a\", etc.). Returns a file descriptor or file object referencing the open file. syscall_read(fd, buf, n) Reads up to <code>n</code> bytes from file descriptor or file object <code>fd</code> into buffer <code>buf</code>. Returns number of bytes read or error code. syscall_write(fd, buf, n) Writes up to <code>n</code> bytes from buffer <code>buf</code> to file descriptor or file object <code>fd</code>. Returns number of bytes written or error code. syscall_close(fd) Closes file descriptor or file object <code>fd</code>. Returns 0 on success or error code. syscall_remove(path) Removes (deletes) the file at the given <code>path</code>. syscall_rename(old, new) Renames file <code>old</code> to <code>new</code>. syscall_stat(path, stat) Gets metadata for file at <code>path</code> into <code>stat</code> struct. syscall_exec(cmd, args) Executes shell command <code>cmd</code> with arguments <code>args</code>. syscall_getenv(name, buf) Gets the value of the environment variable <code>name</code> into <code>buf</code>. syscall_system(cmd) Executes shell command <code>cmd</code> via the system shell. syscall_exit(code) Exits the process with exit code <code>code</code>. syscall_time() Returns the current system time (seconds since epoch). syscall_sleep(ms) Sleeps for <code>ms</code> milliseconds."},{"location":"internal/syscalls/#how-file-and-descriptor-objects-work","title":"How File and Descriptor Objects Work","text":"<ul> <li>File handles/descriptors are returned by <code>syscall_open</code> and uniquely identify an open file.</li> <li>Parallel I/O: You can open multiple files at once. Each operation (<code>read</code>, <code>write</code>, <code>close</code>) targets a specific file via its descriptor/object, allowing independent and parallel operations on multiple files.</li> <li>Lifetime: The file descriptor/object remains valid until explicitly closed via <code>syscall_close</code>. After closing, further operations on that handle are invalid.</li> <li>Threading/Concurrency: If the firescript runtime or standard library supports threading, syscalls are designed so that concurrent threads can operate on different file descriptors in parallel, with OS-level guarantees of isolation and safety.</li> <li>Error Handling: Functions typically return 0 or a positive value on success, and a negative error code on failure (e.g., invalid descriptor, permission denied).</li> </ul>"},{"location":"internal/syscalls/#example-usage","title":"Example Usage","text":"<pre><code>directive enable_syscalls;\n\n// Open two files for parallel access\nint fd1 = syscall_open(\"output1.txt\", \"w\");\nint fd2 = syscall_open(\"output2.txt\", \"w\");\n\nif fd1 &gt;= 0 and fd2 &gt;= 0 {\n    // Write to both files independently\n    syscall_write(fd1, \"foo\", 3);\n    syscall_write(fd2, \"bar\", 3);\n\n    syscall_close(fd1);\n    syscall_close(fd2);\n}\n</code></pre>"},{"location":"internal/syscalls/#notes","title":"Notes","text":"<ul> <li>Syscalls are low-level; errors are returned as negative numbers where applicable.</li> <li>Buffer types and argument conventions are subject to firescript's standard library conventions.</li> </ul>"},{"location":"reference/arrays/","title":"Arrays","text":"<p>Only arrays with literal initialization and methods <code>length</code> are supported by the compiler. Array slicing, negative indices, and other utility methods are not implemented.</p>"},{"location":"reference/arrays/#array-basics","title":"Array Basics","text":"<p>In firescript, arrays are fixed-size, ordered collections of elements that all share the same type. Arrays are Owned types\u2014they are stored on the heap with pointers on the stack and use move semantics. Arrays are declared using square brackets and the size after the type.</p>"},{"location":"reference/arrays/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Arrays are declared by appending <code>[N]</code> to any valid type and initializing with values in square brackets:</p> <pre><code>// Array initialization with values\nint8[] numbers = [10, 20, 30, 40, 50];\nstring[] names = [\"Alice\", \"Bob\", \"Charlie\"];\nbool[] flags = [true, false, true];\n</code></pre> <p>All elements in an array must be of the same type as specified in the declaration.</p>"},{"location":"reference/arrays/#accessing-array-elements","title":"Accessing Array Elements","text":"<p>Individual array elements can be accessed using zero-based indexing:</p> <pre><code>int8[] scores = [85, 92, 78, 90, 88];\n\n// Access individual elements\nint8 firstScore = scores[0];    // 85\nint8 thirdScore = scores[2];    // 78\n\n// Modifying elements\nscores[1] = 95;                // Array becomes [85, 95, 78, 90, 88]\n</code></pre> <p>\u26a0\ufe0f Warning: Accessing an index outside the array bounds will cause a runtime error. Always ensure your index is valid before access.</p>"},{"location":"reference/arrays/#array-operations","title":"Array Operations","text":"<p>firescript provides several built-in methods for manipulating arrays:</p> <ul> <li><code>length</code> \u2013 Property that returns the current size of the array</li> </ul> <pre><code>int8[] data = [5, 10, 15, 20, 25];\nint8 size = data.length;      // size = 5\n</code></pre>"},{"location":"reference/arrays/#working-with-arrays","title":"Working with Arrays","text":""},{"location":"reference/arrays/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Use a <code>while</code> loop with an index variable to iterate over array elements:</p> <pre><code>string[] cities = [\"New York\", \"London\", \"Tokyo\", \"Paris\", \"Sydney\"];\nuint8 i = 0;\nwhile (i &lt; cities.length) {\n    print(cities[i]);\n    i = i + 1;\n}\n</code></pre>"},{"location":"reference/arrays/#array-as-function-arguments","title":"Array as Function Arguments","text":"<p>Arrays can be passed to functions:</p> <pre><code>// Example of how it would work when user-defined functions are implemented\nint32 sum(int8[] numbers) {\n    int32 total = 0;\n    uint8 i = 0;\n    while (i &lt; numbers.length) {\n        total = total + numbers[i];\n        i = i + 1;\n    }\n    return total;\n}\n\n// Usage\nint8[] values = [1, 2, 3, 4, 5];\nint32 result = sum(values);  // 15\n</code></pre>"},{"location":"reference/arrays/#nested-arrays","title":"Nested Arrays","text":"<p>Arrays can contain other arrays (though this is not fully implemented yet):</p> <pre><code>// 2D array example\nint8[][] matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\n// Accessing elements\nint8 element = matrix[1][2];  // 6\n</code></pre>"},{"location":"reference/arrays/#common-array-patterns","title":"Common Array Patterns","text":""},{"location":"reference/arrays/#finding-an-element","title":"Finding an Element","text":"<pre><code>int8[] numbers = [10, 20, 30, 40, 50];\nint8 target = 30;\nint8 index = -1;\nuint8 i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] == target) {\n        index = i;\n        break;\n    }\n    i = i + 1;\n}\n\n// index = 2 if found, -1 if not found\n</code></pre>"},{"location":"reference/arrays/#features-not-yet-implemented","title":"Features Not Yet Implemented","text":"<p>The following array features are planned but not yet implemented in the current compiler:</p> <ul> <li>Array slicing (<code>arr[start:end:step]</code>) \u2013 Extract a portion of the array</li> </ul> <pre><code>// Future syntax\nint8[] numbers = [10, 20, 30, 40, 50];\nint8[] subset = numbers[1:4];  // Would be [20, 30, 40]\n</code></pre> <ul> <li>Negative indices \u2013 Access elements from the end of the array</li> </ul> <pre><code>// Future syntax\nstring[] words = [\"apple\", \"banana\", \"cherry\"];\nstring last = words[-1];     // Would be \"cherry\"\n</code></pre> <ul> <li>Additional utility methods:</li> <li><code>index(value)</code> \u2013 Find the index of the first occurrence of a value</li> <li><code>count(value)</code> \u2013 Count occurrences of a value</li> <li> <p><code>sort()</code> \u2013 Sort the array elements</p> </li> <li> <p>Array arithmetic \u2013 Element-wise operations between arrays</p> </li> </ul> <p>Will use SIMD where possible for performance.</p> <pre><code>// Future syntax\nint8[] a = [1, 2, 3];\nint8[] b = [4, 5, 6];\n\n// add arrays element-wise\nint8[] c = a + b;  // Would be [5, 7, 9]\n\n// subtract arrays element-wise\nint8[] e = b - a;  // Would be [3, 3, 3]\n\n// add scalar to array\nint8[] g = a + 2;  // Would be [3, 4, 5]\n\n// subtract scalar from array\nint8[] h = b - 1;  // Would be [3, 4, 5]\n\n// multiply arrays element-wise\nint8[] j = a * b;  // Would be [4, 10, 18]\n\n// divide arrays element-wise\nint8[] k = b / a;  // Would be [4, 2, 2]\n\n// multiply arrays by scalar\nint8[] d = a * 2;  // Would be [2, 4, 6]\n\n// divide arrays by scalar\nint8[] f = b / 2;  // Would be [2, 2, 3]\n\n// dot product of two arrays\nint8 dotProduct = a . b;  // Would be 32 (1*4 + 2*5 + 3*6)\n</code></pre>"},{"location":"reference/arrays/#implementation-status","title":"Implementation Status","text":"<p>Arrays are functional but with limited operations in the current compiler:</p> <ul> <li>\u2705 Array declaration and initialization</li> <li>\u2705 Element access with positive indices</li> <li>\u2705 Length property</li> <li>\u274c Array slicing</li> <li>\u274c Negative indices</li> <li>\u274c Advanced utility methods</li> <li>\u274c Multi-dimensional array operations</li> </ul>"},{"location":"reference/classes/","title":"Classes &amp; Inheritance","text":"<p>Status: This page describes planned class semantics that integrate with the ownership-based memory model. See Memory Management and the Glossary for authoritative lifetime terminology.</p> <p>Note: Class definitions, inheritance, and methods are currently not supported by the compiler. This documentation describes the planned implementation.</p>"},{"location":"reference/classes/#object-oriented-programming-in-firescript","title":"Object-Oriented Programming in firescript","text":"<p>firescript's class system is designed to provide a clean, intuitive approach to object-oriented programming with features like single inheritance, constructors, and both instance and static methods.</p>"},{"location":"reference/classes/#ownership-lifetime-planned","title":"Ownership &amp; Lifetime (Planned)","text":"<p>Classes are Owned (Non-Trivially Copyable) types unless specified otherwise. Their instances participate in the deterministic ownership model:</p> <ul> <li>Construction produces a new owned instance. Binding the result to a variable creates that variable as the initial owner.</li> <li>Passing an instance to a function parameter of owned type moves it; the caller's binding becomes invalid after the call unless the value is returned.</li> <li>Future borrow syntax (<code>&amp;Person</code>) will allow read-only access to an instance without moving ownership.</li> <li>Fields that are owned types are dropped in reverse order of their construction when the containing object is dropped.</li> <li>A <code>drop(this)</code> method (planned) acts as a destructor. It runs exactly once at the inserted drop point.</li> <li>Cloning an instance will be explicit (<code>person.clone()</code>) if the type supports it (semantics: deep vs copy-on-write TBD per type design).</li> <li>Inheritance does not change ownership: moving a <code>Student</code> moves its base <code>Person</code> subobject as part of the same operation.</li> <li>Borrowed references cannot escape beyond the lifetime of the owning instance; the compiler enforces non-escaping borrows.</li> </ul> <p>Receiver convention (planned): Methods use a borrowed receiver <code>&amp;this</code> by default\u2014even when mutating fields\u2014because internal mutation does not require taking ownership of the entire object. A method takes an owning <code>this</code> only when it will consume the instance (e.g., irreversible state transition, transferring internal resources, or explicit <code>drop(this)</code> destructor). Examples below follow this convention.</p> <p>Borrowing applies only to Owned (Non-Trivially Copyable) types. Copyable types (<code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>) are always passed and returned by value with implicit bitwise copy; using a borrow marker on copyable values is unnecessary and omitted below. Owned types include <code>string</code>, arrays, and user-defined classes. When you see <code>&amp;Type</code> it implies the type is Owned.</p>"},{"location":"reference/classes/#example-deterministic-drop-ordering","title":"Example: Deterministic Drop Ordering","text":"<pre><code>class HandleBundle {\n    File log;\n    Socket conn;\n\n    HandleBundle(&amp;this, File &amp;log, Socket &amp;conn) {\n        this.log = log;     // constructed first\n        this.conn = conn;   // constructed second\n    }\n\n    drop(&amp;this) {            // planned destructor\n        // Custom cleanup (optional). Fields are then dropped automatically\n        // in reverse: conn then log.\n    }\n}\n\nHandleBundle hb = makeHandles(); // this would be invalid since you need to provide owned File and Socket\nprocess(&amp;hb);  // borrow\n// last use of hb here -&gt; compiler may drop immediately after\n</code></pre>"},{"location":"reference/classes/#takeaways","title":"Takeaways","text":"<ul> <li>Instances behave like other owned values: moves invalidate the source; borrows do not.</li> <li>Destruction is deterministic; order is reverse of field construction unless overridden by explicit semantics.</li> <li>No implicit deep copies: cloning is explicit.</li> <li>Inheritance does not introduce implicit sharing or reference counting.</li> </ul>"},{"location":"reference/classes/#defining-a-class","title":"Defining a Class","text":"<p>A class in firescript is defined using the <code>class</code> keyword, followed by the class name and a block containing fields and methods:</p> <pre><code>class Person {\n    // Fields (instance variables)\n    string name;\n    nullable int8 age;\n    bool isEmployed;\n\n    // Constructor: 'this' refers to the instance being created\n    Person(&amp;this, string &amp;name, nullable int8 age = null, bool isEmployed = false) {\n        this.name = name;\n        this.age = age;\n        this.isEmployed = isEmployed;\n    }\n\n    // Instance methods\n    // Non-mutating: borrow receiver\n    string getName(&amp;this) {\n        return &amp;this.name;\n    }\n\n    nullable int getAge(&amp;this) {\n        return &amp;this.age;\n    }\n\n    // Mutating via borrow (allowed; does not consume the instance)\n    void celebrate(&amp;this) {\n        if (this.age != null) {\n            this.age = this.age + 1;\n            print(this.name + \" is now \" + toString(this.age) + \" years old!\");\n        } else {\n            print(this.name + \" is celebrating!\");\n        }\n    }\n\n    // Static method (belongs to the class, not instances)\n    static string species() {\n        return \"Homo sapiens\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#fields","title":"Fields","text":"<p>Fields declare the data that each instance of a class will contain. Each field must have a type:</p> <pre><code>class Rectangle {\n    float32 width;\n    float32 height;\n    string color;\n}\n</code></pre> <p>Fields can be nullable or const:</p> <pre><code>class Configuration {\n    const string APP_NAME;       // Constant field\n    nullable string lastUser;    // Can be null\n}\n</code></pre>"},{"location":"reference/classes/#constructors","title":"Constructors","text":"<p>Constructors are special methods that initialize a new instance of a class. They always take <code>this</code> as their first parameter, which refers to the instance being created. For most cases, <code>this</code> will be a borrowed parameter, unless you are transferring ownership of the instance.</p> <pre><code>class Point {\n    float32 x;\n    float32 y;\n\n    // Basic constructor\n    Point(&amp;this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // With default values (when implemented)\n    Point(&amp;this, float32 x = 0.0, float32 y = 0.0) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#instance-methods","title":"Instance Methods","text":"<p>Instance methods are functions that belong to an instance of a class. They always take <code>this</code> as their first parameter:</p> <pre><code>class Circle {\n    float32 radius;\n\n    Circle(&amp;this, float32 radius) {\n        this.radius = radius;\n    }\n\n    // Instance methods\n    // Non-mutating\n    float getArea(&amp;this) {\n        return 3.14159 * this.radius * this.radius;\n    }\n\n    float getCircumference(&amp;this) {\n        return 2.0 * 3.14159 * this.radius;\n    }\n\n    // Mutating via borrow\n    void scale(&amp;this, float32 factor) {\n        this.radius = this.radius * factor;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#static-methods","title":"Static Methods","text":"<p>Static methods belong to the class itself rather than any instance. They don't take a <code>this</code> parameter:</p> <pre><code>class MathUtils {\n    // Static methods\n    static int8 max(int8 a, int8 b) {\n        if (a &gt; b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    static float32 average(float32 a, float32 b) {\n        return (a + b) / 2.0;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#creating-and-using-objects","title":"Creating and Using Objects","text":"<p>Once a class is defined, you can create instances (objects) of that class:</p> <pre><code>// Creating objects\nPerson alice = Person(\"Alice\", 30, true);\nPerson bob = Person(\"Bob\", null);\n\n// Using instance methods\nstring aliceName = alice.getName();\nalice.celebrate();\n\n// Using static methods\nstring speciesName = Person.species();\n</code></pre>"},{"location":"reference/classes/#inheritance","title":"Inheritance","text":"<p>Inheritance allows a class to inherit fields and methods from another class. firescript supports single inheritance using the <code>from</code> keyword:</p> <pre><code>class Student from Person {\n    string school;\n    string[] courses;\n\n    Student(&amp;this, string name, int8 age, string school) {\n        this.super(name, age);  // Call parent constructor\n        this.school = school;\n        this.courses = [];\n    }\n\n    // Additional methods\n    void enroll(&amp;this, string &amp;course) {\n        this.courses.append(course);\n        print(this.name + \" enrolled in \" + course);\n    }\n\n    string[] getCourses(&amp;this) {\n        return this.courses;\n    }\n\n    // Override parent method\n    void celebrate(&amp;this) {\n        this.super.celebrate();  // Call parent method\n        print(\"Time for a student party!\");\n    }\n}\n</code></pre>"},{"location":"reference/classes/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override methods from the parent class. To call the parent class's implementation, use <code>this.super</code>:</p> <pre><code>class Shape {\n    string color;\n\n    Shape(&amp;this, string color) {\n        this.color = color;\n    }\n\n    string describe(&amp;this) {\n        return \"A \" + this.color + \" shape\";\n    }\n}\n\nclass Square from Shape {\n    float32 side;\n\n    Square(&amp;this, float32 side, string color) {\n        this.super(color);\n        this.side = side;\n    }\n\n    // Override the parent's describe method\n    string describe(&amp;this) {\n        return this.super.describe() + \" (square with side \" + toString(this.side) + \")\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism allows objects of different classes in the same inheritance hierarchy to be treated as objects of a common superclass:</p> <pre><code>// Example of future planned polymorphism\nPerson[] people = [\n    Person(\"Alice\", 25),\n    Student(\"Bob\", 20, \"State University\")\n];\n\nuint8 i = 0;\nwhile (i &lt; people.length) {\n    print(people[i].getName());\n    i = i + 1;\n}\n</code></pre>"},{"location":"reference/classes/#planned-class-features-not-yet-implemented","title":"Planned Class Features (Not Yet Implemented)","text":"<p>The following features are planned for future versions of firescript:</p>"},{"location":"reference/classes/#interfaces","title":"Interfaces","text":"<pre><code>// Future syntax\ninterface Drawable {\n    void draw(&amp;this);\n    bool isVisible(&amp;this);\n}\n\nclass Circle implements Drawable {\n    float32 radius;\n\n    Circle(&amp;this, float32 radius) {\n        this.radius = radius;\n    }\n\n    // Must implement all interface methods\n    void draw(&amp;this) {\n        print(\"Drawing circle with radius \" + toString(this.radius));\n    }\n\n    bool isVisible(&amp;this) {\n        return true;\n    }\n}\n\n// Multiple interfaces\ninterface Movable {\n    void move(&amp;this, int32 dx, int32 dy);\n}\n\nclass Square implements Drawable, Movable {\n    float32 x;\n    float32 y;\n    float32 size;\n\n    Square(&amp;this, float32 x, float32 y, float32 size) {\n        this.x = x;\n        this.y = y;\n        this.size = size;\n    }\n\n    // Implement Drawable\n    void draw(&amp;this) {\n        print(\"Drawing square at (\" + toString(this.x) + \", \" + toString(this.y) + \")\");\n    }\n\n    bool isVisible(&amp;this) {\n        return true;\n    }\n\n    // Implement Movable\n    void move(&amp;this, int32 dx, int32 dy) {\n        this.x = this.x + cast&lt;float32&gt;(dx);\n        this.y = this.y + cast&lt;float32&gt;(dy);\n    }\n}\n</code></pre>"},{"location":"reference/classes/#generics-on-classes","title":"Generics on Classes","text":"<pre><code>// Future syntax\nclass Box&lt;T&gt; {\n    nullable T value;\n\n    Box(&amp;this) {\n        this.value = null;\n    }\n\n    void set(&amp;this, T newValue) { // if T is Owned this is a borrow; if T is copyable it's just a copy\n        this.value = newValue;\n    }\n\n    nullable T get(&amp;this) {\n        return this.value;\n    }\n}\n\n// Usage\nBox&lt;int&gt; intBox = Box&lt;int&gt;();\nintBox.set(42);\n</code></pre>"},{"location":"reference/classes/#abstract-classes-and-methods","title":"Abstract Classes and Methods","text":"<pre><code>// Future syntax\nabstract class Animal {\n    string species;\n\n    Animal(&amp;this, string &amp;species) {\n        this.species = species;\n    }\n\n    // Abstract method - no implementation\n    abstract string makeSound(&amp;this);\n\n    // Regular method with implementation\n    string getSpecies(&amp;this) { // non-mutating borrow\n        return this.species;\n    }\n}\n\nclass Cat from Animal {\n    // Must implement abstract methods\n    string makeSound(&amp;this) { // non-mutating\n        return \"Meow\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#copyable-classes","title":"Copyable Classes","text":"<p>A class may be annotated <code>copyable</code> to become Copyable if it satisfies: 1. All fields are Copyable. 2. No <code>drop</code> defined. 3. Fixed-size representation. 4. No disallowed interior references.</p> <pre><code>// Future syntax\ncopyable class Point {\n    float32 x;\n    float32 y;\n\n    Point(this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#best-practices-for-class-design","title":"Best Practices for Class Design","text":"<ol> <li>Single Responsibility Principle: Each class should have only one reason to change.\\</li> <li>Favor Composition Over Inheritance: Use object composition rather than complex inheritance hierarchies.</li> <li>Keep Inheritance Hierarchies Shallow: Deep inheritance can lead to complexity.</li> <li>Use Descriptive Names: Class names should be nouns, method names should be verbs.</li> </ol>"},{"location":"reference/classes/#implementation-status","title":"Implementation Status","text":"<p>Classes in firescript are planned but not yet implemented in the current compiler:</p> <ul> <li>\u2705 Class definitions</li> <li>\u2705 Instance fields and methods</li> <li>\u2705 Constructors</li> <li>\u274c Static methods</li> <li>\u2705 Inheritance</li> <li>\u274c Method overriding</li> <li>\u274c Polymorphism</li> <li>\u274c Interfaces</li> <li>\u274c Access modifiers</li> <li>\u274c Abstract classes</li> <li>\u274c Meta-attributes/annotations</li> <li>\u274c Generics on classes</li> </ul>"},{"location":"reference/control_flow/","title":"Control Flow","text":"<p>firescript supports several control flow structures: conditional statements (<code>if</code>/<code>else</code>), while loops, C-style for loops, and for-in loops. Range loops and the ternary operator are not yet supported by the compiler.</p>"},{"location":"reference/control_flow/#introduction-to-control-flow","title":"Introduction to Control Flow","text":"<p>Control flow structures determine the order in which statements are executed in a program. They allow for conditional execution (if/else) and repeated execution (loops) of code blocks. In firescript, control flow constructs use curly braces <code>{}</code> to define code blocks.</p>"},{"location":"reference/control_flow/#conditional-statements","title":"Conditional Statements","text":"<p>Conditional statements execute different blocks of code depending on whether a specified condition evaluates to <code>true</code> or <code>false</code>. firescript supports <code>if</code>, <code>else if</code>, and <code>else</code> statements.</p>"},{"location":"reference/control_flow/#basic-if-statement","title":"Basic If Statement","text":"<p>The simplest form executes a block of code only if the condition is true:</p> <pre><code>if (condition) {\n    // Code executed only if condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nint8 age = 18;\nif (age &gt;= 18) {\n    print(\"You are eligible to vote\");\n}\n</code></pre>"},{"location":"reference/control_flow/#if-else-statement","title":"If-Else Statement","text":"<p>You can specify an alternative block of code to execute when the condition is false:</p> <pre><code>if (condition) {\n    // Code executed if condition is true\n} else {\n    // Code executed if condition is false\n}\n</code></pre> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nint8 score = 65;\nif (score &gt;= 70) {\n    print(\"Pass\");\n} else {\n    print(\"Fail\");\n}\n</code></pre>"},{"location":"reference/control_flow/#if-else-if-else-chains","title":"If-Else If-Else Chains","text":"<p>For multiple conditions, you can use <code>else if</code>:</p> <pre><code>if (condition1) {\n    // Executed if condition1 is true\n} else if (condition2) {\n    // Executed if condition1 is false and condition2 is true\n} else if (condition3) {\n    // Executed if condition1 and condition2 are false and condition3 is true\n} else {\n    // Executed if all conditions are false\n}\n</code></pre> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nint8 grade = 85;\n\nif (grade &gt;= 90) {\n    print(\"A\");\n} else if (grade &gt;= 80) {\n    print(\"B\");\n} else if (grade &gt;= 70) {\n    print(\"C\");\n} else if (grade &gt;= 60) {\n    print(\"D\");\n} else {\n    print(\"F\");\n}\n</code></pre>"},{"location":"reference/control_flow/#nested-conditional-statements","title":"Nested Conditional Statements","text":"<p>Conditional statements can be nested within other conditional statements:</p> <pre><code>import @firescript/std.io.{print};\n\nbool hasDiscount = true;\nint8 totalAmount = 120;\n\nif (totalAmount &gt; 100) {\n    if (hasDiscount) {\n        print(\"You qualify for a 15% discount\");\n    } else {\n        print(\"You qualify for a 10% discount\");\n    }\n} else {\n    print(\"No discount available\");\n}\n</code></pre>"},{"location":"reference/control_flow/#boolean-expressions-in-conditions","title":"Boolean Expressions in Conditions","text":"<p>Conditions can use various boolean operators:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li> <li>Logical operators: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> </ul> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nint8 age = 25;\nbool hasLicense = true;\n\nif (age &gt;= 18 &amp;&amp; hasLicense) {\n    print(\"You can drive\");\n}\n\nif (!(age &lt; 18 || !hasLicense)) {\n    print(\"Also, you can drive\"); // Equivalent to the above\n}\n</code></pre>"},{"location":"reference/control_flow/#loops","title":"Loops","text":"<p>Loops allow for repeated execution of a block of code. firescript supports <code>while</code> loops and plans to support various forms of <code>for</code> loops in the future.</p>"},{"location":"reference/control_flow/#while-loops","title":"While Loops","text":"<p>A <code>while</code> loop repeatedly executes a block of code as long as a specified condition is <code>true</code>:</p> <pre><code>while (condition) {\n    // Loop body: code executed repeatedly as long as condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nuint8 count = 0;\nwhile (count &lt; 5) {\n    print(count);\n    count = count + 1;\n}\n// Outputs: 0, 1, 2, 3, 4\n</code></pre>"},{"location":"reference/control_flow/#infinite-loops","title":"Infinite Loops","text":"<p>A <code>while</code> loop with a condition that is always <code>true</code> creates an infinite loop. These should be used with caution and should include a break statement:</p> <pre><code>while (true) {\n    // This will run forever unless broken\n    if (someCondition) {\n        break; // Exit the loop\n    }\n}\n</code></pre>"},{"location":"reference/control_flow/#loop-control-statements","title":"Loop Control Statements","text":"<p>The following statements can control loop execution:</p> <ul> <li><code>break</code> - Immediately exits the loop</li> <li><code>continue</code> - Skips the rest of the current iteration and starts the next one</li> </ul> <p>Example:</p> <pre><code>import @firescript/std.io.{print};\n\nuint8 i = 0;\nwhile (i &lt; 10) {\n    i = i + 1;\n\n    if (i == 3) {\n        continue; // Skip the rest of this iteration\n    }\n\n    if (i == 8) {\n        break; // Exit the loop\n    }\n\n    print(i);\n}\n// Outputs: 1, 2, 4, 5, 6, 7\n</code></pre>"},{"location":"reference/control_flow/#combining-loops-and-conditionals","title":"Combining Loops and Conditionals","text":"<p>Loops and conditional statements can be combined to create powerful control flows:</p> <pre><code>import @firescript/std.io.{print};\n\nint8[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nint8 sum = 0;\nuint8 i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        sum = sum + numbers[i]; // Add only even numbers\n    }\n    i = i + 1;\n}\n\nprint(sum); // Outputs: 30 (2 + 4 + 6 + 8 + 10)\n</code></pre>"},{"location":"reference/control_flow/#for-loops","title":"For Loops","text":"<p>firescript supports two types of for loops: C-style for loops and for-in loops.</p>"},{"location":"reference/control_flow/#c-style-for-loops","title":"C-style For Loops","text":"<p>C-style for loops consist of three parts: initialization, condition, and increment. They are ideal for counting iterations.</p> <pre><code>import @firescript/std.io.{println};\n\nfor (int32 i = 0; i &lt; 5; i++) {\n    println(i);\n}\n</code></pre> <p>Any or all parts can be omitted:</p> <pre><code>import @firescript/std.io.{println};\n\nint32 i = 0;\nfor (; i &lt; 5; i++) {  // Init omitted\n    println(i);\n}\n\nfor (int32 j = 0; j &lt; 10;) {  // Increment omitted\n    println(j);\n    j++;\n}\n</code></pre> <p>Variables declared in the initialization section are scoped to the for loop:</p> <pre><code>import @firescript/std.io.{println};\n\nfor (int32 i = 0; i &lt; 3; i++) {\n    println(i);\n}\n// i is not accessible here\n\n// This is valid - i is redeclared in a new scope\nfor (int32 i = 0; i &lt; 5; i++) {\n    println(i);\n}\n</code></pre> <p>Nested for loops:</p> <pre><code>import @firescript/std.io.{println};\n\nfor (int32 i = 0; i &lt; 3; i++) {\n    for (int32 j = 0; j &lt; 3; j++) {\n        println(i * 3 + j);\n    }\n}\n</code></pre>"},{"location":"reference/control_flow/#for-in-loops","title":"For-In Loops","text":"<p>For-in loops iterate over elements in a collection (currently arrays). The loop variable must be declared with a type:</p> <pre><code>import @firescript/std.io.{println};\n\nint32[] numbers = [1, 2, 3, 4, 5];\nfor (int32 num in numbers) {\n    println(num);\n}\n</code></pre> <p>For-in with array literals:</p> <pre><code>import @firescript/std.io.{println};\n\nfor (int32 value in [10, 20, 30, 40, 50]) {\n    println(value);\n}\n</code></pre>"},{"location":"reference/control_flow/#break-and-continue-in-for-loops","title":"Break and Continue in For Loops","text":"<p>Both <code>break</code> and <code>continue</code> work in for loops:</p> <pre><code>import @firescript/std.io.{println};\n\n// Break: exit the loop early\nfor (int32 i = 0; i &lt; 10; i++) {\n    if (i == 5) {\n        break;  // Exit when i reaches 5\n    }\n    println(i);  // Prints 0, 1, 2, 3, 4\n}\n\n// Continue: skip to next iteration\nfor (int32 i = 0; i &lt; 5; i++) {\n    if (i == 2) {\n        continue;  // Skip when i is 2\n    }\n    println(i);  // Prints 0, 1, 3, 4\n}\n</code></pre>"},{"location":"reference/control_flow/#future-control-flow-features","title":"Future Control Flow Features","text":"<p>The following control flow features are planned but not yet implemented in the current compiler:</p>"},{"location":"reference/control_flow/#range-loops","title":"Range Loops","text":"<pre><code>// Future syntax\nimport @firescript/std.io.{print};\\n\\nfor (uint8 i : range(5)) {\n    print(i); // 0, 1, 2, 3, 4\n}\n\nfor (uint8 i : range(2, 8)) {\n    print(i); // 2, 3, 4, 5, 6, 7\n}\n\nfor (uint8 i : range(1, 10, 2)) {\n    print(i); // 1, 3, 5, 7, 9\n}\n</code></pre>"},{"location":"reference/control_flow/#ternary-operator","title":"Ternary Operator","text":"<pre><code>// Future syntax\nint8 max = ternary a &gt; b then a else b;\n</code></pre>"},{"location":"reference/control_flow/#switch-statements","title":"Switch Statements","text":"<p>Switch statements provide a way to execute different parts of code based on the value of a variable:</p> <pre><code>// Future syntax\nswitch (value) {\n    case (1) {\n        // code for case 1\n    }\n    case (2) {\n        // code for case 2\n    }\n    case (value &gt; 2 &amp;&amp; value &lt; 5) {\n        // code for range case\n    }\n    default {\n        // default code\n        // executed if no cases match\n    }\n}\n</code></pre>"},{"location":"reference/control_flow/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Keep conditions simple: Split complex conditions into multiple variables for better readability.</p> </li> <li> <p>Avoid deep nesting: Too many nested if/else statements make code hard to follow. Consider refactoring deeply nested code.</p> </li> <li> <p>Be careful with while loops: Always ensure that the condition will eventually become false to avoid infinite loops.</p> </li> <li> <p>Use appropriate loop types: Once implemented, choose the right loop for the task: <code>while</code> for unknown iteration counts, <code>for</code> for counting, and <code>for-in</code> for collections.</p> </li> </ol>"},{"location":"reference/control_flow/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 <code>if</code>/<code>else</code>/<code>else if</code> conditional statements</li> <li>\u2705 <code>while</code> loops</li> <li>\u2705 C-style <code>for</code> loops</li> <li>\u2705 <code>for-in</code> loops (for arrays)</li> <li>\u2705 <code>break</code> and <code>continue</code> statements</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c Range-based loops</li> <li>\u274c Ternary operator</li> <li>\u274c <code>switch</code>/<code>case</code> statements</li> </ul>"},{"location":"reference/error_handling/","title":"Runtime Error Handling","text":"<p>firescript is designed in a way that minimizes runtime errors through static type checking and compile-time validation. However, some errors may still occur during execution, such as division by zero or out-of-bounds array access.</p>"},{"location":"reference/error_handling/#error-types","title":"Error Types","text":"<ol> <li>Syntax Errors: Caught at compile-time, these errors occur when the code is not well-formed.</li> <li>Type Errors: Also caught at compile-time, these occur when operations are applied to incompatible types.</li> <li>Runtime Errors: These occur during execution and can include:</li> <li>Division by zero</li> <li>Null reference access</li> <li>Array index out of bounds</li> </ol>"},{"location":"reference/error_handling/#error-handling","title":"Error Handling","text":"<p>firescript provides a way to handle runtime errors gracefully:</p> <ul> <li>Try/Catch Blocks: You can wrap code that may throw an error in a try block, and handle the error in a catch block.</li> </ul> <pre><code>try {\n    int8 result = 10 / 0;\n} catch (DivisionByZeroError e) {\n    print(\"Error: \" + e.message);\n}\n</code></pre> <ul> <li>Assertions: Use the <code>assert</code> function to check for conditions that must be true. If the condition is false, an error is raised.</li> </ul> <pre><code>assert(x &gt; 0, \"x must be positive\");\n</code></pre>"},{"location":"reference/error_handling/#best-practices","title":"Best Practices","text":"<ul> <li>Always validate user input to prevent errors.</li> <li>Use try/catch blocks to handle potential runtime errors.</li> <li>Write unit tests to catch errors early in the development process.</li> </ul>"},{"location":"reference/functions/","title":"Functions &amp; Methods","text":""},{"location":"reference/functions/#built-in-functions","title":"Built-in Functions","text":"<p>For the purposes of most code, firescript does not provide any built-in functions. Things like io and math are provided by the standard library.</p>"},{"location":"reference/functions/#user-defined-functions","title":"User-defined Functions","text":"<pre><code>// Basic function definition\nreturnType functionName(paramType1 param1, paramType2 param2) {\n    // function body\n    return returnValue;\n}\n\n// Examples:\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(string name) {\n    print(\"Hello, \" + name);\n}\n\nfloat calculateAverage(int[] numbers) {\n    int sum = 0;\n    int i = 0;\n    while (i &lt; numbers.length) {\n        sum = sum + numbers[i];\n        i = i + 1;\n    }\n    return toFloat(sum) / toFloat(numbers.length);\n}\n</code></pre>"},{"location":"reference/functions/#ownership-notes-planned-semantics","title":"Ownership Notes (Planned Semantics)","text":"<ul> <li>Parameters of owned types (strings, arrays, user-defined objects) move into the function. After a call, an argument of an owned type is no longer valid unless the function returns it.</li> <li>Future explicit borrow syntax (<code>&amp;T</code>) will allow passing a read-only view without moving ownership. Borrowed arguments remain valid after the call.</li> <li>For Copyable types (e.g., <code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>), calls pass by value; borrowing is not defined for Copyable types.</li> <li><code>toString()</code> and string concatenation produce new <code>string</code> values. Strings are Owned and use move semantics.</li> <li>Arrays are Owned and use move semantics.</li> <li>Cloning is explicit for Owned values (needed for <code>string</code>, arrays, and user-defined objects).</li> <li>Examples currently show simple pass semantics until borrow syntax is implemented.</li> </ul>"},{"location":"reference/functions/#methods-planned-not-implemented","title":"Methods (Planned, Not Implemented)","text":"<p>Methods are functions that belong to objects. This feature is planned but not yet implemented:</p> <pre><code>class Person {\n    string name\n    int age\n\n    // Constructor method\n    Person(&amp;this, string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Instance method\n    string introduce(&amp;this) {\n        return \"My name is \" + this.name + \" and I'm \" + toString(this.age) + \" years old\";\n    }\n\n    // Static method\n    static string getSpecies() {\n        return \"Human\";\n    }\n}\n</code></pre>"},{"location":"reference/functions/#best-practices-for-functions","title":"Best Practices for Functions","text":"<p>Although user-defined functions aren't implemented yet, here are best practices to follow when they become available:</p> <ol> <li> <p>Single responsibility: Each function should perform a single, well-defined task.</p> </li> <li> <p>Descriptive names: Use verb-based names that clearly describe what the function does.</p> </li> <li> <p>Input validation: Check function arguments for validity when appropriate.</p> </li> <li> <p>Error handling: Consider how your function will handle error conditions.</p> </li> <li> <p>Pure functions: When possible, write pure functions (functions without side-effects that return the same output for the same input).</p> </li> </ol>"},{"location":"reference/functions/#future-function-features","title":"Future Function Features","text":"<p>The following function-related features are planned but not yet implemented:</p> <ul> <li>Optional parameters with default values:</li> </ul> <pre><code>// Future syntax\nvoid greet(string name, string greeting = \"Hello\") {\n    print(greeting + \", \" + name);\n}\n</code></pre> <ul> <li>Named arguments in calls:</li> </ul> <pre><code>// Future syntax\ncalculateRectangle(width: 10, height: 20);\n</code></pre> <ul> <li>Variadic parameters (variable number of arguments):</li> </ul> <pre><code>// Future syntax\nint sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total = total + num;\n    }\n    return total;\n}\n</code></pre> <ul> <li>Function overloading:</li> </ul> <pre><code>// Future syntax\nint add(int a, int b) {\n    return a + b;\n}\n\nfloat add(float a, float b) {\n    return a + b;\n}\n</code></pre>"},{"location":"reference/functions/#implementation-status","title":"Implementation Status","text":"<ul> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, type conversions, <code>typeof</code></li> <li>\u2705 Array methods: <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, <code>length</code></li> <li>\u2705 User-defined function definitions</li> <li>\u2705 Methods on objects</li> <li>\u274c Optional, named, or variadic parameters</li> <li>\u274c Function overloading</li> </ul>"},{"location":"reference/imports/","title":"Imports","text":"<p>firescript uses an explicit, Java-inspired import system for organizing code across files and (in the future) external packages. All imports must specify full paths; there is no implicit or relative import behavior.</p>"},{"location":"reference/imports/#import-syntax","title":"Import Syntax","text":""},{"location":"reference/imports/#importing-local-modules","title":"Importing local modules","text":"<ul> <li>Import an entire module:</li> </ul> <pre><code>import src.utils.utils\n</code></pre> <ul> <li>Import a specific symbol from a module:</li> </ul> <pre><code>import src.utils.utils.helper\n</code></pre> <ul> <li>Import multiple symbols from a module:</li> </ul> <pre><code>import src.utils.utils.{helper, CONSTANT}\n</code></pre> <ul> <li>Import all symbols from a module (allowed, but discouraged for explicitness):</li> </ul> <pre><code>import src.utils.utils.*\n</code></pre> <ul> <li>Aliasing imports (optional):</li> </ul> <pre><code>import src.utils.utils.helper as help\nimport src.utils.utils as Utils\n</code></pre>"},{"location":"reference/imports/#importing-external-packages-reserved","title":"Importing external packages (reserved)","text":"<p>These forms are reserved for future package management and standard library support:</p> <pre><code>import @user/package\nimport @firescript/std\n</code></pre> <p>These imports can be used the same as local imports, like so:</p> <pre><code>import @firescript/std.math\n\nimport @firescript/std.math.sqrt\n\nimport @firescript/std.{math, io}\n\nimport @firescript/std.math.*\n\nimport @firescript/std.math.sqrt as squareRoot\n</code></pre>"},{"location":"reference/imports/#paths-and-resolution","title":"Paths and Resolution","text":"<ul> <li>Import paths are absolute from the project root. For example, <code>src.utils.utils</code> maps to <code>{project-root}/src/utils/utils.fire</code>.</li> <li>Relative imports (e.g., <code>import ../utils</code>) are not permitted.</li> <li>There are no default or magic imports\u2014every symbol must be explicitly imported.</li> <li>The <code>.fire</code> extension is omitted in import statements but always resolves to a file with that extension.</li> <li>A configurable import root may be supported in the future; the default is the project root.</li> </ul>"},{"location":"reference/imports/#examples","title":"Examples","text":"<p>Given the structure:</p> <pre><code>src/\n    main.fire\n    utils/\n        utils.fire\n    enums/\n        colors.fire\n</code></pre> <p>From <code>colors.fire</code>, to import a function <code>helper</code> from <code>utils.fire</code>:</p> <pre><code>import src.utils.utils.helper\n</code></pre> <p>To import the entire module:</p> <pre><code>import src.utils.utils\n</code></pre> <p>To import multiple symbols:</p> <pre><code>import src.utils.utils.{helper, CONSTANT}\n</code></pre>"},{"location":"reference/imports/#wildcards-aliasing-and-explicitness","title":"Wildcards, Aliasing, and Explicitness","text":"<ul> <li>Wildcards via <code>*</code> are allowed but discouraged; prefer explicit symbol lists.</li> <li>Aliasing is available for both modules and symbols to improve clarity and resolve naming conflicts.</li> <li>Explicitness is required\u2014no implicit re-exports or default imports.</li> </ul>"},{"location":"reference/imports/#reserved-future-features","title":"Reserved &amp; Future Features","text":"<ul> <li><code>import @user/package</code> is reserved for future package management.</li> <li><code>import @firescript/std</code> is reserved for standard library modules.</li> </ul>"},{"location":"reference/imports/#best-practices","title":"Best Practices","text":"<ol> <li>Prefer explicit symbol imports over wildcards.</li> <li>Avoid broad module imports unless you intentionally need many symbols.</li> <li>Use aliasing when names conflict or when a shorter local name improves readability.</li> </ol>"},{"location":"reference/imports/#not-supported","title":"Not Supported","text":"<ul> <li>Relative imports</li> <li>Implicit \u201cimport everything\u201d behavior</li> <li>Omitting paths or symbols</li> </ul>"},{"location":"reference/imports/#syntax-summary","title":"Syntax Summary","text":"Syntax Meaning <code>import src.utils.utils</code> Import entire module <code>import src.utils.utils.helper</code> Import a specific symbol <code>import src.utils.utils.{a, b}</code> Import multiple symbols <code>import src.utils.utils.*</code> Import all symbols (discouraged) <code>import src.utils.utils.helper as h</code> Alias an imported symbol <code>import @user/package</code> External package (future)"},{"location":"reference/imports/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Import statements are only valid at the top level of a source file.</li> <li>The compiler will resolve imports from the project root and report missing files or symbols.</li> <li>Cyclic imports should be detected and reported as errors.</li> </ul>"},{"location":"reference/imports/#implementation-status","title":"Implementation Status","text":"<ul> <li>\u2705 Import syntax parsing (Phase 0) - fully implemented</li> <li>\u2705 Module resolution and dependency loading (Phase 1) - fully implemented</li> <li>\u2705 Multi-module compilation with merged AST (Phase 2 basic) - fully implemented</li> <li>\u2705 Wildcard imports (<code>import module.*</code>)</li> <li>\u2705 Symbol imports (<code>import module.{a, b}</code>)</li> <li>\u2705 Cyclic import detection</li> <li>\u2705 Standard library imports (<code>import @firescript/std</code>)</li> <li>\u26a0\ufe0f  Module aliases and qualified access (e.g., <code>Utils.helper()</code>) - not yet implemented</li> <li>\u274c External packages (<code>@user/package</code>) - not supported yet</li> </ul>"},{"location":"reference/memory_management/","title":"Memory Management","text":"<p>Status: This is the authoritative specification of firescript's ownership-based memory model. Some described behaviors (e.g., last-use drop insertion, borrow checking) may not yet be enforced in current builds. If another document conflicts with this page, this page takes precedence.</p>"},{"location":"reference/memory_management/#overview","title":"Overview","text":"<p>firescript uses a deterministic ownership model rather than a tracing garbage collector. Values are categorized as either copyable or owned. Owned values move by default; borrowing (<code>&amp;T</code>) provides a temporary, read\u2011only view only for Owned types. Copyable types are always passed and assigned by value (bitwise copy); they cannot be borrowed. The compiler (planned) inserts destruction (\u201cdrop\u201d) at the last proven use or at scope end. Ordinary owned values incur no runtime reference counting.</p> <p>This page is layered: first core concepts, then detailed rules. Other documentation pages should link here instead of redefining terminology.</p>"},{"location":"reference/memory_management/#core-concepts-concept-map","title":"Core Concepts (Concept Map)","text":"<ol> <li>Categorize each value: copyable or owned</li> <li>Moving an Owned value transfers ownership; the previous binding becomes invalid</li> <li>Borrowing (<code>&amp;T</code>) is only allowed for Owned types; it grants a read-only, non-owning view tied to the original owner\u2019s lifetime</li> <li>Copyable types are simply copied; \u201cmove\u201d is indistinguishable from copy; borrowing does not exist for Copyable types</li> <li>The compiler performs last-use analysis to place deterministic drop points (Owned types only)</li> <li>Scope exit drops any remaining owned values</li> <li>Cloning is explicit (<code>.clone()</code> / <code>clone(x)</code>) for Owned values</li> </ol>"},{"location":"reference/memory_management/#terminology","title":"Terminology","text":"<p>Core terms (Copyable, Owned, Move, Borrow, Clone, Drop) are defined centrally in the glossary. This document applies those definitions normatively and adds the constraint:</p> <ul> <li>Borrow (<code>&amp;T</code>) is only defined for Owned types. Attempting to borrow a Copyable type (e.g., <code>&amp;int</code>) is a compile error.</li> </ul>"},{"location":"reference/memory_management/#how-this-interacts-with-other-features","title":"How This Interacts With Other Features","text":"<ul> <li>Scoping: Scope exit triggers drops of any still-owned values (see Scoping).</li> <li>Functions: Owned parameters move; borrowed parameters (<code>&amp;T</code>) (Owned types only) do not transfer ownership (see Functions).</li> <li>Future Closures: Captures of Owned variables default to move; borrow captures are allowed only if the closure cannot escape.</li> </ul>"},{"location":"reference/memory_management/#detailed-rules","title":"Detailed Rules","text":""},{"location":"reference/memory_management/#1-value-categories","title":"1. Value Categories","text":"<ul> <li>Copyable: Fixed-size scalars with no destructor (e.g., <code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>). These values are stored on the stack. Copy is bitwise; there is no drop. Borrowing a Copyable type is disallowed (<code>&amp;int</code> is invalid).</li> <li>Owned: Heap-backed or resource-managing values (e.g., user-defined objects, closures, arrays, strings). These values are stored on the heap with pointers on the stack. Ownership is unique; assignment/pass/return moves ownership. Destruction runs at drop points.</li> </ul> <p>Cloning Owned values is explicit via <code>.clone()</code> or <code>clone(x)</code>.</p>"},{"location":"reference/memory_management/#2-regions-and-lifetimes","title":"2. Regions and Lifetimes","text":"<ul> <li>Each lexical scope defines a region. An owned value lives in the region of its current owner.</li> <li>On scope exit, all owned values remaining in the region are dropped (reverse creation order).</li> <li>The compiler performs last-use analysis and inserts earlier drops when safe.</li> <li>Copyable values have no lifetime actions; they are ignored by drop logic.</li> </ul> <p>Moving a value transfers it to the destination region: - Passing to a function that takes <code>T</code> moves into the callee's region. - Returning <code>T</code> moves into the caller\u2019s region. - Assigning to a variable moves into that variable\u2019s region.</p>"},{"location":"reference/memory_management/#3-function-parameters-and-returns","title":"3. Function Parameters and Returns","text":"<p>Parameters may be:</p> <ul> <li><code>T</code>: (T is Owned) callee receives ownership; caller loses it unless returned. All parameters default to move semantics.</li> <li><code>&amp;T</code>: (T is Owned) borrowed, read-only; callee cannot retain or return it in a longer-lived form. Borrowing must be explicit.</li> </ul> <p>For Copyable types: - There is only pass-by-value (copy). No borrow syntax is permitted. <code>intN</code>, <code>bool</code>, etc. are always copied; moves do not invalidate the source.</p> <p>Returns: - Returning <code>T</code> (Owned) transfers ownership to the caller. - Returning <code>&amp;T</code> (Owned) only allowed if the referenced value is owned by the caller (non-escaping). Borrow returns of Copyable types are invalid (they cannot be borrowed).</p> <p>Notes: - For owned types, <code>T</code> means move semantics. If you want to borrow, you must use <code>&amp;T</code>. - There is no implicit borrowing - borrowing must be explicitly requested with the <code>&amp;</code> marker. - At call sites, passing an owned value to a function expecting <code>T</code> moves ownership; passing to <code>&amp;T</code> borrows. - Attempting to pass a Copyable value where <code>&amp;T</code> is required is a type error (cannot borrow Copyable). - Generic Parameters Exception: For generic type parameters (e.g., <code>&amp;T</code> in a generic function), Copyable values are implicitly copied rather than borrowed. This allows generic functions to accept both Copyable and Owned types. For concrete (non-generic) Owned types, the borrow restriction still applies.</p>"},{"location":"reference/memory_management/#4-borrowing-rules-owned-types-only","title":"4. Borrowing Rules (Owned Types Only)","text":"<ul> <li>Borrowing is only defined for Owned types.</li> <li>A borrowed <code>&amp;OwnedType</code> is a non-owning, read-only view.</li> <li>A borrow cannot be stored in any owned field or global location that outlives the borrow expression/call.</li> <li>Mutability of Owned values occurs via methods on an owned receiver or a consuming pattern (no mutable borrow form yet).</li> <li>If a function must retain or store a value, it must take ownership (<code>owned T</code>) or clone inside the borrow\u2019s scope.</li> </ul> <p>TL;DRL Borrowing passes a read-only pointer.</p>"},{"location":"reference/memory_management/#5-closures-and-coroutines","title":"5. Closures and Coroutines","text":"<ul> <li>Capturing by move transfers ownership into the closure\u2019s region (Owned types only).</li> <li>Capturing by borrow is only allowed for non-escaping closures and only for Owned types.</li> <li>Copyable values captured are copied; no borrow form exists. (Copyable capture has no ownership effect.)</li> <li>Escaping closures cannot have borrowed captures.</li> </ul>"},{"location":"reference/memory_management/#6-destruction-and-drop","title":"6. Destruction and <code>Drop</code>","text":"<ul> <li>Owned (Owned) types may define <code>drop(this)</code>.</li> <li>Drops occur deterministically:</li> <li>At last use (if provable).</li> <li>At scope exit.</li> <li>Along all control-flow exits (return, break, exception).</li> <li>Moves prevent duplicate drops (previous binding invalidated).</li> <li>Copyable values never have drops.</li> </ul> <p>Example:</p> <pre><code>File f = File.open(\"log.txt\");\nf.write(\"hello\");\nf.flush();\n// f dropped here even on early return/exception; File.drop closes the descriptor.\n</code></pre>"},{"location":"reference/memory_management/#7-method-receivers","title":"7. Method Receivers","text":"<p>Method receiver kinds apply only to Owned types (Copyable methods implicitly copy the receiver):</p> <ul> <li>Borrowed receiver (default for Owned): signature form <code>name(...) ReturnType</code> implicitly receives <code>&amp;OwnedType this</code> (read-only).</li> <li>Consuming receiver: <code>name(this, ...) ReturnType</code> takes ownership; caller's binding is invalid unless the method returns it.</li> </ul> <p>For Copyable types: - Methods always receive the value by copy; \u201cconsuming\u201d semantics do not apply.</p> <p>Consuming example:</p> <pre><code>Account upgrade(this) {\n  // ... mutate internal state\n  return this;\n}\n\nacct = acct.upgrade(); // rebind because ownership moved and was returned\n</code></pre>"},{"location":"reference/memory_management/#8-control-flow-and-last-use-owned-types","title":"8. Control Flow and Last Use (Owned Types)","text":"<ul> <li>Conditional joins: if both branches use a value, drop inserted after merge; otherwise at last branch that uses it.</li> <li>Loops: Values used across iterations drop after loop. Iteration-temporary owned values drop at iteration end.</li> <li>Copyable values ignored by last-use logic (always trivially copyable).</li> </ul>"},{"location":"reference/memory_management/#9-conversions-and-sharing","title":"9. Conversions and Sharing","text":"<ul> <li>To create multiple independent owners of an Owned value: <code>.clone()</code>.</li> <li>Opt-in reference-counted or shared abstractions may be provided (e.g., <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, arenas). These layer explicit runtime or bulk management semantics on top of the ownership core.</li> <li>Copyable values never require sharing constructs.</li> </ul>"},{"location":"reference/memory_management/#10-interop-and-backends","title":"10. Interop and Backends","text":"<ul> <li>Native: Drops become direct destructor calls.</li> <li>JavaScript: Destruction logic executes at specified points; underlying JS GC handles memory backing where applicable; resource closures are deterministic.</li> </ul>"},{"location":"reference/memory_management/#11-diagnostics","title":"11. Diagnostics","text":"<ul> <li>Use-after-move (Owned) is an error: primary note at move, secondary at invalid use.</li> <li>Illegal borrow of a Copyable type (e.g., <code>&amp;int</code>) is an error: \u201cCannot borrow trivially copyable type \u2018int\u2019; pass by value.\u201d</li> <li>Borrow escape detection flags returning or storing a borrow beyond its allowed lifetime.</li> <li>Deterministic destruction order may be visualized (tooling).</li> </ul>"},{"location":"reference/memory_management/#declaring-a-copyable-class","title":"Declaring a Copyable Class","text":"<p>A class may be annotated <code>copyable</code> to become Copyable if it satisfies: 1. All fields are Copyable. 2. No <code>drop</code> defined. 3. Fixed-size representation. 4. No disallowed interior references.</p> <p>Example:</p> <pre><code>copyable class Vec2 {\n    float32 x; // float32 is Copyable\n    float32 y;\n}\n</code></pre> <p><code>Vec2</code> values copy bitwise; moves do not invalidate the source.</p>"},{"location":"reference/memory_management/#examples","title":"Examples","text":"<p>The following examples illustrate planned semantics. Some features (e.g., full last-use optimization) may not yet be implemented.</p>"},{"location":"reference/memory_management/#example-move-vs-copy-takeaway-owned-moves-copyable-copies","title":"Example: Move vs Copy (Takeaway: Owned moves; Copyable copies)","text":"<pre><code>Object o1 = Object(); // owned\nObject o2 = o1;      // move; o1 invalid afterward\n// print(o1);        // error: moved value\n\nint8 x = 42;\nint8 y = x;          // copy (Copyable); x still valid\nprint(x);           // OK\n</code></pre>"},{"location":"reference/memory_management/#example-clone-takeaway-explicit-duplication-for-owned","title":"Example: Clone (Takeaway: explicit duplication for Owned)","text":"<pre><code>string s1 = \"fire\";\nstring s2 = s1.clone(); // independent\nprint(s1);\nprint(s2);\n</code></pre>"},{"location":"reference/memory_management/#example-borrowed-parameter-owned-only","title":"Example: Borrowed Parameter (Owned only)","text":"<pre><code>int length(&amp;string s) {\n    return s.length;\n}\n\nstring name = \"firescript\";\nint8 n = length(name); // borrow; name still valid\n</code></pre>"},{"location":"reference/memory_management/#example-invalid-borrow-of-copyable-compile-error","title":"Example: Invalid Borrow of Copyable (Compile Error)","text":"<pre><code>int8 id = 10;\nprintId(&amp;id);   // ERROR: cannot borrow Copyable type 'int'; remove '&amp;'\n\n// Correct version:\nvoid printId(int8 v) {\n    print(v);\n}\nprintId(id);    // copies 'id'\nprint(id);      // still valid\n</code></pre>"},{"location":"reference/memory_management/#example-owned-parameter-consumed-move","title":"Example: Owned Parameter Consumed (Move)","text":"<pre><code>void addUser(string username);  // Plain 'string' means owned/move\n\nstring u = \"alice\";\naddUser(u);   // move; u invalid afterward\n// print(u);  // ERROR: use after move\n</code></pre> <p>Or equivalently with explicit <code>owned</code>:</p> <pre><code>void addUser(owned string username);  // Explicit owned\n\nstring u = \"alice\";\naddUser(u);   // move; u invalid afterward\n</code></pre>"},{"location":"reference/memory_management/#example-returning-borrow-owned-only-non-escaping","title":"Example: Returning Borrow (Owned Only, Non-Escaping)","text":"<pre><code>&amp;string head(string[] xs) {\n    return xs[0];   // OK: element owned by caller's array\n}\n</code></pre>"},{"location":"reference/memory_management/#example-consuming-method","title":"Example: Consuming Method","text":"<pre><code>Account activate(owned this) {\n    // mutate state\n    return this;\n}\n\nacct = acct.activate(); // rebind with returned owned value\n</code></pre>"},{"location":"reference/memory_management/#summary-of-borrowing-availability","title":"Summary of Borrowing Availability","text":"Kind Copyable Types Owned Types Borrow (<code>&amp;T</code>) Not allowed (error) Allowed (read-only, non-owning) Move Degenerate (copy) Transfers ownership; source invalid Clone Not needed Explicit, creates new owner Drop Not applicable Invokes destructor deterministically <p>Borrowing is intentionally restricted to Owned types to: 1. Preserve simplicity (no redundant alias form for scalars). 2. Keep ownership-focused diagnostics clear. 3. Avoid needless syntactic noise for trivially cheap copies.</p> <p>If a future revision broadens Copyable to include large POD aggregates, this restriction may be reconsidered; until then it is normative.</p>"},{"location":"reference/modules/","title":"Modules","text":"<p>A module is a unit of firescript code that you can import. Modules are similar to Python modules and can be:</p> <ul> <li>A single source file, or</li> <li>A directory that contains firescript source files.</li> </ul> <p>A package is something you can install from the package manager. Packages are modules, but not all modules are packages.</p> <p>A library is a package included with the Firescript installation.</p>"},{"location":"reference/modules/#directory-modules-and-initfire","title":"Directory Modules and init.fire","text":"<p>If a directory contains an <code>init.fire</code> file, that file defines the module for the directory name.</p> <p>Example layout:</p> <pre><code>math/\n  init.fire\n  trig.fire\n</code></pre> <ul> <li>The contents of <code>math/init.fire</code> are imported with:</li> </ul> <pre><code>import math\n</code></pre> <ul> <li>The contents of <code>math/trig.fire</code> are imported with:</li> </ul> <pre><code>import math.trig\n</code></pre>"},{"location":"reference/modules/#nested-modules","title":"Nested Modules","text":"<p>Modules can be nested by creating subdirectories with their own source files:</p> <pre><code>math/\n  init.fire\n  trig.fire\n  geometry/\n    init.fire\n    angles.fire\n</code></pre> <p>Examples:</p> <pre><code>import math\nimport math.trig\nimport math.geometry\nimport math.geometry.angles\n</code></pre>"},{"location":"reference/modules/#definitions","title":"Definitions","text":"<ul> <li>Module: A single <code>.fire</code> file, or a directory containing <code>.fire</code> files.</li> <li>Package: An installable module from the package manager.</li> <li>Rule: All packages are modules, but not all modules are packages.</li> </ul>"},{"location":"reference/overview/","title":"Language Reference Overview","text":"<p>This section provides a comprehensive reference for the firescript programming language. firescript is a statically and strongly typed language that prioritizes readability, explicitness, and predictable behavior.</p>"},{"location":"reference/overview/#core-design-principles","title":"Core Design Principles","text":"<p>firescript's design follows several key principles:</p> <ul> <li>Static &amp; Strong Typing: Every variable has a defined type that is checked at compile-time</li> <li>Explicit Behavior: No implicit type conversions or hidden behaviors</li> <li>Simple Syntax: Draws inspiration from C, Java, JavaScript, and Python</li> <li>Consistent Rules: Language constructs follow consistent patterns</li> <li>Predictable Execution: Code behaves as written, minimizing surprises</li> </ul>"},{"location":"reference/overview/#implementation-status","title":"Implementation Status","text":"<p>The firescript compiler is under active development. Current status:</p> Feature Status Notes Copyable Types \u26a0\ufe0f Partial <code>bool</code>, <code>char</code>, <code>intN</code>, <code>floatN</code> (stack-allocated scalars) Owned Types \u26a0\ufe0f Partial <code>string</code>, arrays (heap-allocated with move semantics) Memory Model \u26a0\ufe0f In Progress Ownership model documented; compiler enforcement WIP. Arrays are targeted as the first Owned type. See Memory Management. Control Flow \u26a0\ufe0f Partial <code>if/else</code> and <code>while</code> loops work; <code>for</code> loops planned Functions \u26a0\ufe0f Partial Functions can be defined and used but lack some planned features Classes \u274c Planned Object-oriented features planned for future versions Modules \u274c Planned Code organization across files planned for future versions"},{"location":"reference/overview/#getting-started","title":"Getting Started","text":"<p>For those new to firescript, we recommend starting with the following guides:</p> <ol> <li>Types &amp; Variables - Learn how to declare and use variables</li> <li>Arrays - Working with collections of data</li> <li>Control Flow - Conditionals and loops</li> <li>Functions &amp; Methods - Using built-in functions</li> </ol>"},{"location":"reference/overview/#detailed-reference","title":"Detailed Reference","text":"<p>For more detailed information, each section of this reference covers specific aspects of the language:</p> <ul> <li>Type System - Comprehensive information about the firescript type system</li> <li>Scoping Rules - How variable scoping works</li> <li>Classes &amp; Inheritance - Object-oriented programming (future)</li> </ul>"},{"location":"reference/overview/#example-code","title":"Example Code","text":"<pre><code>// Calculate fibonacci numbers\nint8 i = 0;\nint8 j = 1;\nint8 count = 10;\n\nprint(\"Fibonacci Sequence:\");\nprint(i);\nprint(j);\n\nwhile (count &gt; 0) {\n    int8 next = i + j;\n    print(next);\n    i = j;\n    j = next;\n    count = count - 1;\n}\n</code></pre> <p>For the complete language specification, see the Language Specification document.</p>"},{"location":"reference/project_structure/","title":"Project Structure","text":""},{"location":"reference/project_structure/#initfire","title":"init.fire","text":"<p>say you have the following project structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.fire\n\u2502   \u2514\u2500\u2500 math\n\u2502       \u2514\u2500\u2500 constants.fire\n</code></pre> <p>and you wanted to have functions directly available on <code>math</code>. You would create an <code>init.fire</code> file in the <code>math</code> directory:</p> <p>```my_project/ \u251c\u2500\u2500 src/ \u2502   \u251c\u2500\u2500 main.fire \u2502   \u2514\u2500\u2500 math \u2502       \u251c\u2500\u2500 init.fire \u2502       \u2514\u2500\u2500 constants.fire</p> <pre><code>\nThe `init.fire` file could look like this:\n\n```firescript\n// math/init.fire\nint32 add(int32 a, int32 b) {\n    return a + b;\n}\n</code></pre> <p>Now, in your <code>main.fire</code>, you can import the <code>math</code> module and use the <code>add</code> function directly:</p> <p>```firescript// main.fire import math.add;</p> <p>int32 result = add(5, 10); ```</p>"},{"location":"reference/scoping/","title":"Scoping in firescript","text":"<p>Status: This section references planned ownership semantics. See Memory Management for authoritative definitions.</p> <p>In firescript, scopes define the visibility and lifetime of variables. Understanding how scopes work is crucial for writing correct and predictable code.</p>"},{"location":"reference/scoping/#scope-creation","title":"Scope Creation","text":"<p>A new scope is created by any set of curly braces <code>{}</code>. This includes:</p> <ul> <li>Control Flow Statements: The bodies of <code>if</code>, <code>else if</code>, <code>else</code>, <code>for</code>, <code>while</code>, and other control flow statements each create their own scope.</li> <li>Function Bodies: The body of a function defines a scope.</li> <li>Class Bodies: The body of a class defines a scope.</li> <li>Bare Braces: You can create an explicit scope simply by using a pair of curly braces <code>{}</code> anywhere they are syntactically allowed.</li> </ul> <pre><code>import @firescript/std.io.{print};\n\n// Global scope\n\nint globalVar = 10;\n\nif (globalVar &gt; 5) {\n    // Inner scope 1 (if body)\n    int innerVar1 = 20;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar1);  // Accessing current scope variable: OK (prints 20)\n}\n\n// print(innerVar1)  // ERROR: innerVar1 is not accessible here\n\n{\n    // Inner scope 2 (bare braces)\n    int innerVar2 = 30;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar2);  // Accessing current scope variable: OK (prints 30)\n\n    if (true) {\n        // Inner scope 3 (nested if body)\n        int innerVar3 = 40;\n        print(globalVar);  // OK (prints 10)\n        print(innerVar2);  // OK (prints 30)\n        print(innerVar3);  // OK (prints 40)\n    }\n    // print(innerVar3)  // ERROR: innerVar3 is not accessible here\n}\n\n// print(innerVar2)  // ERROR: innerVar2 is not accessible here\n</code></pre>"},{"location":"reference/scoping/#scope-hierarchy-and-variable-access","title":"Scope Hierarchy and Variable Access","text":"<ul> <li>Outer Scope Access: An inner scope can access variables declared in any of its enclosing (outer) scopes, all the way up to the global scope.</li> <li>Inner Scope Isolation: An outer scope cannot access variables declared within any of its inner scopes. Once a scope block is exited, all variables declared directly within that scope are destroyed and become inaccessible.</li> <li>Variable Shadowing: Variable shadowing is not allowed. firescript will throw an error if you try to declare a variable with the same name in an inner scope that already exists in an outer scope. This is to prevent confusion and ensure that the intended variable is always accessed.</li> </ul>"},{"location":"reference/scoping/#detailed-scoping-rules","title":"Detailed Scoping Rules","text":""},{"location":"reference/scoping/#1-variable-declaration-and-initialization","title":"1. Variable Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement. They are only accessible within their scope:</p> <pre><code>import @firescript/std.io.{print};\n\n{\n    int x = 5;  // x is declared and initialized\n\n    {\n        // New inner scope\n        print(x);  // Accessible, prints 5\n\n        // int x = 10;  // ERROR: Cannot redeclare 'x' - shadowing is not allowed\n        int y = 15;  // y is only accessible in this scope\n    }\n\n    // print(y)  // ERROR: y is not defined in this scope\n}\n// print(x)  // ERROR: x is not defined in this scope\n</code></pre>"},{"location":"reference/scoping/#2-variable-lifetime","title":"2. Variable Lifetime","text":"<p>Variables exist only from the point of their declaration to the end of their containing scope:</p> <pre><code>{\n    // print(a)  // ERROR: Cannot use 'a' before declaration\n\n    int a = 1;\n    print(a);  // OK: 'a' exists here\n\n    {\n        int b = 2;\n        print(a);  // OK: 'a' from outer scope\n        print(b);  // OK: 'b' from current scope\n    }  // 'b' is destroyed here\n\n    // print(b)  // ERROR: 'b' no longer exists\n}  // 'a' is destroyed here\n</code></pre>"},{"location":"reference/scoping/#3-global-scope","title":"3. Global Scope","text":"<p>Variables declared outside any braces are in the global scope and are accessible throughout the entire program:</p> <pre><code>int globalValue = 100;  // Global variable\n\n{\n    print(globalValue);  // Accessible anywhere in the program\n\n    {\n        print(globalValue);  // Still accessible\n    }\n}\n\n// User-defined functions would also have access to global variables\n// when this feature is implemented\n</code></pre>"},{"location":"reference/scoping/#4-loop-scopes","title":"4. Loop Scopes","text":"<p>Each iteration of a loop has its own scope:</p> <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    // New scope for each loop iteration\n    int temp = i * 10;\n    print(temp);  // Prints 0, 10, 20\n    i = i + 1;\n}  // 'temp' is destroyed at the end of each iteration\n\n// print(temp)  // ERROR: 'temp' is not accessible here\n</code></pre>"},{"location":"reference/scoping/#5-conditional-scopes","title":"5. Conditional Scopes","text":"<p>Each branch of a conditional statement creates its own scope. This pattern prevents runtime issues where a variable may or may not be defined depending on the execution path:</p> <pre><code>int value = 5;\n\nif (value &gt; 10) {\n    // Scope A\n    int result = value * 2;\n    print(result);\n} else if (value &gt; 0) {\n    // Scope B (different from Scope A)\n    int result = value + 10;  // OK to reuse the name 'result' here\n    print(result);  // Prints 15\n} else {\n    // Scope C (different from Scopes A and B)\n    int result = 0;\n    print(result);\n}\n\n// print(result)  // ERROR: 'result' is not accessible here\n</code></pre>"},{"location":"reference/scoping/#6-nested-function-scopes-future-feature","title":"6. Nested Function Scopes (Future Feature)","text":"<p>When user-defined functions are implemented, they will create their own scopes:</p> <pre><code>// Global scope\nint globalVar = 10;\n\n// Future syntax when functions are implemented\nvoid exampleFunction() {\n    // Function scope\n    int functionVar = 20;\n    print(globalVar);  // OK: access to global scope\n\n    {\n        // Inner scope within the function\n        int innerVar = 30;\n        print(functionVar);  // OK: access to containing function scope\n        print(globalVar);    // OK: access to global scope\n    }\n\n    // print(innerVar)  // ERROR: not accessible outside its scope\n}\n\n// print(functionVar)  // ERROR: function variables only exist in function scope\n</code></pre>"},{"location":"reference/scoping/#variable-scope-vs-object-lifetime","title":"Variable Scope vs. Object Lifetime","text":"<p>It's important to distinguish between a variable's scope (where it can be accessed) and an object's lifetime (how long it exists in memory and when it is dropped):</p> <pre><code>// When object-oriented features are implemented:\n{\n    // myObj variable is scoped to this block\n    Person myObj = Person(\"John\", 30);\n\n    // myObj reference goes out of scope here\n    // The Person object will be dropped (its destructor run) when its final owner goes out of scope.\n    // (Deterministic planned behavior \u2013 see Memory Management.)\n}\n</code></pre>"},{"location":"reference/scoping/#best-practices-for-effective-scoping","title":"Best Practices for Effective Scoping","text":"<ol> <li> <p>Keep scopes as small as possible: Declare variables in the smallest scope where they are needed.</p> </li> <li> <p>Declare variables close to their first use: This improves code readability and maintainability.</p> </li> <li> <p>Use explicit scopes for temporary variables: Use bare braces <code>{}</code> to create explicit scopes for temporary variables.</p> </li> </ol> <p><code>firescript    {        // Temporary calculation scope        int temp = complexCalculation();        result = temp * 2;    }  // 'temp' is no longer accessible, reducing scope pollution</code></p> <ol> <li> <p>Be consistent with variable naming: Use clear, descriptive names to avoid confusion, especially with variables in different scopes.</p> </li> <li> <p>Avoid deeply nested scopes: Excessive nesting can make code harder to read and understand.</p> </li> </ol>"},{"location":"reference/scoping/#interaction-with-ownership-planned","title":"Interaction With Ownership (Planned)","text":"<ul> <li>Scope exit triggers deterministic drop of all still-owned values declared in that scope.</li> <li>A move transfers ownership; the original variable becomes invalid immediately after the move.</li> <li>A borrow (<code>&amp;T</code>) never extends lifetime; it relies on the original owner remaining in scope.</li> <li>Last-use analysis may drop a value before the lexical end of the scope if no further uses are provable.</li> </ul>"},{"location":"reference/scoping/#implementation-details","title":"Implementation Details","text":"<p>firescript's scoping mechanism is implemented as a stack of symbol tables. When looking up a variable:</p> <ol> <li>The compiler first checks the innermost scope (top of the stack)</li> <li>If not found, it progressively checks outer scopes</li> <li>If the variable is not found in any scope, a compilation error occurs</li> </ol>"},{"location":"reference/scoping/#common-scoping-errors","title":"Common Scoping Errors","text":""},{"location":"reference/scoping/#1-accessing-variables-outside-their-scope","title":"1. Accessing Variables Outside Their Scope","text":"<pre><code>{\n    int8 value = 10;\n}\nprint(value)  // ERROR: 'value' is not defined in this scope\n</code></pre>"},{"location":"reference/scoping/#2-redeclaring-variables-in-the-same-scope","title":"2. Redeclaring Variables in the Same Scope","text":"<pre><code>int8 count = 5;\nint8 count = 10;  // ERROR: 'count' is already defined\n</code></pre>"},{"location":"reference/scoping/#3-attempting-variable-shadowing","title":"3. Attempting Variable Shadowing","text":"<pre><code>int8 value = 10;\nif (true) {\n    int8 value = 20;  // ERROR: Shadowing is not allowed in firescript\n}\n</code></pre>"},{"location":"reference/scoping/#4-using-variables-before-declaration","title":"4. Using Variables Before Declaration","text":"<pre><code>print(result);  // ERROR: Cannot use 'result' before declaration\nint8 result = 42;\n</code></pre>"},{"location":"reference/scoping/#implementation-status","title":"Implementation Status","text":"<p>Scope handling in firescript is fully implemented:</p> <ul> <li>\u2705 Block scopes with curly braces</li> <li>\u2705 Variable visibility rules</li> <li>\u2705 Prohibition of variable shadowing</li> <li>\u2705 Scope nesting and hierarchy</li> <li>\u2705 Variable lifetime management</li> </ul>"},{"location":"reference/type_system/","title":"Type System in firescript","text":"<p>firescript employs a static type system to enhance code reliability and catch errors early during the compilation phase. This means that the type of every variable and expression is checked before the code is run.</p>"},{"location":"reference/type_system/#built-in-types","title":"Built-in Types","text":"<p>firescript provides several fundamental data types categorized by their memory semantics:</p>"},{"location":"reference/type_system/#copyable-types-stack-allocated","title":"Copyable Types (Stack-Allocated)","text":"<p>These are fixed-size scalars stored on the stack and copied by value:</p> <ul> <li>Numeric Types:</li> <li><code>int8</code>: 8-bit signed integer</li> <li><code>int16</code>: 16-bit signed integer</li> <li><code>int32</code>: 32-bit signed integer</li> <li><code>int64</code>: 64-bit signed integer</li> <li><code>uint8</code>: 8-bit unsigned integer</li> <li><code>uint16</code>: 16-bit unsigned integer</li> <li><code>uint32</code>: 32-bit unsigned integer</li> <li><code>uint64</code>: 64-bit unsigned integer</li> <li><code>float32</code>: 32-bit floating point number</li> <li><code>float64</code>: 64-bit floating point number</li> <li><code>float128</code>: 128-bit floating point number</li> <li><code>bool</code>: Represents boolean values, either <code>true</code> or <code>false</code>. Example: <code>bool isActive = true;</code></li> <li><code>char</code>: Represents a single character. (Note: Currently handled similarly to strings in some contexts, formal <code>char</code> type might be refined). Example: <code>char initial = \"A\";</code></li> </ul>"},{"location":"reference/type_system/#owned-types-heap-allocated","title":"Owned Types (Heap-Allocated)","text":"<p>These values are stored on the heap with pointers on the stack and use move semantics:</p> <ul> <li><code>string</code>: Represents sequences of characters. Example: <code>string message = \"Hello, World!\";</code></li> <li>Arrays: Collections of elements (see Arrays)</li> <li>User-defined classes: Custom objects (planned)</li> </ul>"},{"location":"reference/type_system/#special-types","title":"Special Types","text":"<ul> <li><code>void</code>: Represents the absence of a type, primarily used as the return type for functions that do not return a value.</li> </ul>"},{"location":"reference/type_system/#type-semantics","title":"Type Semantics","text":""},{"location":"reference/type_system/#explicit-casts-as","title":"Explicit Casts (<code>as</code>)","text":"<p>firescript requires explicit numeric conversions. There are no implicit casts between integer widths/signedness.</p> <p>Use Rust-style casts:</p> <pre><code>int8 myInt = (59i16 as int8);\nuint8 u = (255i16 as uint8);\nfloat64 f = (42i32 as float64);\n</code></pre> <p>Notes:</p> <ul> <li><code>as</code> is a postfix operator: <code>expr as type</code>.</li> <li>For readability, parentheses are recommended when mixing with other operators.</li> <li><code>as</code> is currently supported for numeric-to-numeric casts.</li> </ul>"},{"location":"reference/type_system/#integer-type-intn-and-uintn","title":"Integer Type (<code>intN</code> and <code>uintN</code>)","text":"<p>The <code>intN</code> types in firescript represent N-bit signed integers, while the <code>uintN</code> types represent N-bit unsigned integers.</p> <pre><code>int8 small = 42;\nint64 large = 9223372036854775807;  // Large integers are supported\nint64 calculation = ((small as int64) + large) * 2i64;  // Arithmetic operations\n</code></pre> <p>Integers support the following operations:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo), <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Bit manipulation (planned but not yet implemented): <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li> </ul>"},{"location":"reference/type_system/#integer-literals","title":"Integer Literals","text":"<p>Integer literals can be made more readable using underscores:</p> <pre><code>int32 million = 1_000_000;  // One million\nint64 bigNumber = 9_223_372_036_854_775_807;  // Large integer\n</code></pre> <p>Integer literals can be specified in decimal, hexadecimal, binary, or octal formats:</p> <pre><code>int8 decimal = 42;        // Decimal\nint8 hex = 0x2A;          // Hexadecimal\nint8 binary = 0b00101010; // Binary\nint8 octal = 0o52;        // Octal\n</code></pre> <p>Type Inference for Literals:</p> <p>When you assign a literal to a variable with an explicit type, the literal automatically takes on that type:</p> <pre><code>int8 small = 42;          // Literal 42 inferred as int8\nuint16 medium = 30000;    // Literal 30000 inferred as uint16\nint64 large = 9223372036854775807;  // Literal inferred as int64\nfloat32 pi = 3.14;        // Literal 3.14 inferred as float32\nfloat64 e = 2.71828;      // Literal 2.71828 inferred as float64\n</code></pre> <p>If the literal is too large or too small for the target type, you'll get a compile-time error:</p> <pre><code>// int8 overflow = 200;   // \u274c Compile error: 200 exceeds int8 range (-128 to 127)\n// uint8 negative = -1;   // \u274c Compile error: -1 invalid for unsigned type\n</code></pre> <p>Explicit Type Suffixes:</p> <p>You can also explicitly specify the type using a suffix, which is useful in contexts where the type cannot be inferred (like in expressions):</p> <pre><code>int8 small = 42i8;\nint16 medium = 30000i16;\nint64 large = 9223372036854775807i64;\nuint8 usmall = 255u8;\nuint16 umedium = 60000u16;\nuint64 ularge = 18446744073709551615u64;\n</code></pre> <p>You can define a base and a suffix together:</p> <pre><code>int8 hexSmall = 0x2Ai8;\nuint16 binMedium = 0b111010100110u16;\n</code></pre>"},{"location":"reference/type_system/#integer-overflow-and-underflow-behavior","title":"Integer Overflow and Underflow Behavior","text":"<p>For all fixed-size integer types (<code>intN</code> and <code>uintN</code>), arithmetic operations that exceed the representable range will throw an error at runtime. This is to prevent silent overflow/underflow issues.</p> <pre><code>int8 max = 127i8;\nint8 overflow = max + 1i8;  // Runtime error: Integer overflow\n</code></pre> <p>Overflows that can be detected at compile-time (e.g., constant expressions) will result in a compile-time error.</p> <pre><code>int8 compileTimeOverflow = 128i8;  // Compile-time error: Integer overflow\n</code></pre>"},{"location":"reference/type_system/#floating-point-types-floatn","title":"Floating Point Types (<code>floatN</code>)","text":"<p>The <code>floatN</code> types represent N-bit floating point numbers.</p> <pre><code>float32 simpleDecimal = 3.14;\nfloat64 highPrecision = 3.141592653589793;\n</code></pre> <p>Floating point numbers support:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> </ul>"},{"location":"reference/type_system/#floating-point-literals","title":"Floating Point Literals","text":"<p>Floating point literals can be specified in decimal or scientific notation.</p> <p>Type Inference for Literals:</p> <p>When you assign a floating-point literal to a variable with an explicit type, the literal automatically takes on that type:</p> <pre><code>float32 pi = 3.14159;              // Literal inferred as float32\nfloat64 e = 2.71828;               // Literal inferred as float64\nfloat128 phi = 1.618033988749;     // Literal inferred as float128\nfloat64 scientific = 6.022e23;     // Scientific notation, inferred as float64\n</code></pre> <p>Explicit Type Suffixes:</p> <p>You can also explicitly specify the type using a suffix:</p> <pre><code>float32 f32Value = 3.14f32;\nfloat64 f64Value = 3.14f64;\nfloat128 f128Value = 3.14f128;\n</code></pre>"},{"location":"reference/type_system/#special-floating-point-values","title":"Special Floating Point Values","text":"<p>Floating point types support special values such as <code>NaN</code> (Not a Number), <code>Infinity</code>, and <code>-Infinity</code>:</p> <pre><code>float32 notANumber = 0.0f32 / 0.0f32;  // NaN\nfloat64 positiveInfinity = 1.0f64 / 0.0f64;  // Infinity\nfloat64 negativeInfinity = -1.0f64 / 0.0f64; // -Infinity\n</code></pre>"},{"location":"reference/type_system/#floating-point-overflow-and-underflow-behavior","title":"Floating Point Overflow and Underflow Behavior","text":"<p>Floating point operations that exceed the representable range will result in <code>Infinity</code> or <code>-Infinity</code>, while operations resulting in values too close to zero will result in <code>0.0</code>. Operations resulting in undefined values will yield <code>NaN</code>.</p> <pre><code>float32 large = 3.4e38f32 * 10.0f32;  // Results in Infinity\nfloat32 small = 1.0e-38f32 / 10.0f32; // Results in 0.0\nfloat32 undefined = 0.0f32 / 0.0f32;      // Results in NaN\n</code></pre>"},{"location":"reference/type_system/#boolean-type-bool","title":"Boolean Type (<code>bool</code>)","text":"<p>The <code>bool</code> type has only two possible values: <code>true</code> and <code>false</code>. It's commonly used in conditional expressions.</p> <pre><code>bool userLoggedIn = true;\nbool hasPermission = false;\n\n// Boolean operations\nbool canAccess = userLoggedIn &amp;&amp; hasPermission;  // Logical AND\nbool needsAttention = !userLoggedIn || !hasPermission;  // Logical OR and NOT\n</code></pre> <p>Boolean values support:</p> <ul> <li>Logical operations: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"reference/type_system/#string-type-string","title":"String Type (<code>string</code>)","text":"<p>The <code>string</code> type represents sequences of characters. Strings in firescript are immutable.</p> <pre><code>string greeting = \"Hello\";\nstring name = \"World\";\nstring message = greeting + \", \" + name + \"!\";  // String concatenation with +\n\n// Multi-line strings\nstring paragraph = \"This is a\nmulti-line\nstring\";\n</code></pre> <p>Strings support:</p> <ul> <li>Concatenation: <code>+</code></li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"reference/type_system/#character-type-char","title":"Character Type (<code>char</code>)","text":"<p>The <code>char</code> type represents a single character and is currently implemented as a string with length 1.</p> <pre><code>char letter = \"A\";\nchar digit = \"7\";\nchar newline = \"\\n\";  // Special character\n</code></pre>"},{"location":"reference/type_system/#arrays","title":"Arrays","text":"<p>Arrays are fixed-size ordered collections of elements of the same type.</p>"},{"location":"reference/type_system/#declaration-and-initialization","title":"Declaration and Initialization","text":"<pre><code>// With initial values\nint8[5] numbers = [1, 2, 3, 4, 5];\nstring[3] fruits = [\"apple\", \"banana\", \"cherry\"];\n</code></pre>"},{"location":"reference/type_system/#array-operations","title":"Array Operations","text":"<pre><code>int8[3] scores = [85, 92, 78];\n\n// Accessing elements (zero-based indexing)\nint8 firstScore = scores[0];  // 85\n\n// Modifying elements\nscores[1] = 95;  // Array becomes [85, 95, 78]\n\n// Array properties\nint8 count = scores.length;  // 3\n</code></pre>"},{"location":"reference/type_system/#nullability","title":"Nullability","text":"<p>By default, variables cannot hold the value <code>null</code>. To allow a variable to be assigned <code>null</code>, you must explicitly declare it as <code>nullable</code>.</p>"},{"location":"reference/type_system/#declaring-nullable-variables","title":"Declaring Nullable Variables","text":"<pre><code>nullable string username = null;  // Allowed\nstring title = \"Default\";\n\n// title = null;  // Error: Cannot assign null to non-nullable type 'string'\n\nusername = \"John\";  // Can be assigned a non-null value later\n</code></pre>"},{"location":"reference/type_system/#working-with-nullable-values","title":"Working with Nullable Values","text":"<p>When working with nullable variables, it's important to check for null before using them:</p> <pre><code>import @firescript/std.io.{print};\n\nnullable string data = null;\n\n// Safe pattern\nif (data != null) {\n    print(data);\n}\n\n// Could cause a runtime error if not checked\nprint(data);  // Might try to print null\n</code></pre>"},{"location":"reference/type_system/#type-compatibility-and-conversions","title":"Type Compatibility and Conversions","text":"<p>firescript has strict typing rules and requires explicit type conversions using casting syntax.</p>"},{"location":"reference/type_system/#explicit-type-casting","title":"Explicit Type Casting","text":"<p>To convert between types, use Java-style casting with parentheses:</p> <pre><code>// Numeric conversions\nint32 intVal = 42;\nfloat64 floatVal = (float64)intVal;     // 42.0\n\nfloat32 pi = 3.14f32;\nint32 truncated = (int32)pi;            // 3 (truncates decimal)\n\n// Between numeric types\nint8 small = 100i8;\nint64 large = (int64)small;             // 100i64\n\nuint32 unsigned = 42u32;\nint32 signed = (int32)unsigned;         // 42i32\n\n// String conversions\nstring numStr = \"42\";\nint32 parsed = (int32)numStr;           // 42\nfloat64 parsedFloat = (float64)\"3.14\";  // 3.14\n\n// To string\nstring str1 = (string)42;               // \"42\"\nstring str2 = (string)3.14f32;          // \"3.14\"\nstring str3 = (string)true;             // \"true\"\n\n// Boolean conversions\nbool fromString = (bool)\"true\";         // true\nbool fromInt = (bool)1;                 // true (non-zero is true)\n\n// Character conversions\nchar first = (char)\"Hello\";             // \"H\" - first character\n</code></pre> <p>Casting Rules:</p> <ol> <li>Numeric to numeric: Always allowed, may lose precision or truncate</li> <li>String to numeric: Parses the string, throws error if invalid format</li> <li>Numeric to string: Converts to string representation</li> <li>Boolean to string: \"true\" or \"false\"</li> <li>String to boolean: \"true\" \u2192 true, anything else \u2192 false</li> <li>Numeric to boolean: 0 \u2192 false, non-zero \u2192 true</li> <li>String to char: Takes first character</li> </ol> <p>Invalid Casts:</p> <p>Some casts are not allowed and will result in compile-time errors:</p> <pre><code>// int32 x = (int32)[1, 2, 3];  // \u274c Error: Cannot cast array to int32\n// bool b = (bool)\"hello\";       // \u26a0\ufe0f Runtime error: Invalid boolean string\n</code></pre>"},{"location":"reference/type_system/#mixed-type-arithmetic","title":"Mixed-Type Arithmetic","text":"<p>firescript does not perform implicit type conversions in arithmetic operations. When performing operations between different types or precisions, you must explicitly cast to the desired result type.</p> <pre><code>int32 a = 10;\nint64 b = 20i64;\n\n// int32 result = a + b;  // \u274c Error: Cannot mix int32 and int64\n\n// Must explicitly cast to desired type\nint32 result1 = (int32)(a + (int32)b);  // Cast b to int32 first\nint64 result2 = (int64)((int64)a + b);  // Cast a to int64 first\n\n// Mixed integer and float\nint32 intVal = 5;\nfloat32 floatVal = 2.5f32;\n\n// float32 mixed = intVal + floatVal;  // \u274c Error: Cannot mix int32 and float32\n\nfloat32 result3 = (float32)((float32)intVal + floatVal);  // Cast int to float\nint32 result4 = (int32)((int32)floatVal + intVal);        // Cast float to int (truncates)\n\n// Different float precisions\nfloat32 f32 = 3.14f32;\nfloat64 f64 = 2.71f64;\n\n// float64 sum = f32 + f64;  // \u274c Error: Cannot mix float32 and float64\n\nfloat64 result5 = (float64)((float64)f32 + f64);  // Cast to float64\nfloat32 result6 = (float32)(f32 + (float32)f64);  // Cast to float32\n</code></pre> <p>Design Rationale:</p> <p>This explicit approach prevents silent precision loss and makes data type conversions visible in the code, aligning with firescript's philosophy of explicitness and safety.</p>"},{"location":"reference/type_system/#string-concatenation","title":"String Concatenation","text":"<p>String concatenation with <code>+</code> is an exception - it will implicitly convert non-string values to strings:</p> <pre><code>string message = \"Count: \" + 42;  // \"Count: 42\" - int32 converted to string\nstring status = \"Active: \" + true;  // \"Active: true\" - bool converted to string\nstring pi = \"Pi is approximately \" + 3.14f32;  // Converts float to string\n</code></pre>"},{"location":"reference/type_system/#type-checking-and-enforcement","title":"Type Checking and Enforcement","text":"<p>The firescript parser includes a type-checking phase that runs after the initial syntax parsing.</p>"},{"location":"reference/type_system/#static-type-checking","title":"Static Type Checking","text":"<ol> <li> <p>Variable Declarations: When you declare a variable (<code>int8 x = 5i8;</code>), the type checker verifies that the type of the initializer (<code>5i8</code>, which is <code>int8</code>) matches the declared type (<code>int8</code>).</p> </li> <li> <p>Assignments: When assigning a value to an existing variable (<code>x = 10i8;</code>), the checker ensures the assigned value's type is compatible with the variable's declared type.</p> </li> <li> <p>Expressions: Operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&gt;</code>, etc.) are checked to ensure they are used with compatible operand types. For example, arithmetic operators generally require numeric types (<code>intN</code>, <code>floatN</code>), while <code>+</code> can also be used for string concatenation. The result type of an expression is also determined (e.g., <code>1 + 2.0</code> results in a <code>float32</code>).</p> </li> <li> <p>Function Calls: Arguments passed to functions are checked against the expected parameter types. The return value type is also enforced.</p> </li> <li> <p>Method Calls: Similar to functions, arguments and the object the method is called on are type-checked.</p> </li> <li> <p>Array Operations: Indexing requires an integer, and assigning elements requires matching the array's element type.</p> </li> </ol>"},{"location":"reference/type_system/#type-errors","title":"Type Errors","text":"<p>Type errors found during the checking phase will prevent the code from compiling further, providing early feedback on potential issues:</p> <pre><code>string name = \"John\";\nint8 age = 30;\n\nage = \"thirty\";  // Type error: Cannot assign string to int\nname = 25;       // Type error: Cannot assign int to string\nbool result = age + name;  // Type error: Cannot add int and string\n                           // Also cannot assign result to bool\n</code></pre>"},{"location":"reference/type_system/#type-introspection","title":"Type Introspection","text":"<p>The <code>typeof</code> built-in function returns a string representing the type of a value:</p> <pre><code>// Future syntax\nstring type1 = typeof(42);        // \"int8\"\nstring type2 = typeof(3.14);      // \"float32\"\nstring type3 = typeof(\"hello\");   // \"string\"\nstring type4 = typeof(true);      // \"bool\"\nstring type5 = typeof([1, 2, 3]); // \"int8[]\"\n</code></pre>"},{"location":"reference/type_system/#standard-library-types-planned","title":"Standard Library Types (Planned)","text":"<p>The following standard library types are planned but not yet implemented: * <code>BigInt</code>: Arbitrary-precision integers for calculations requiring more than 64 bits. * <code>Decimal</code>: Fixed-point, arbitrary-precision decimal type for precise calculations. * <code>list&lt;T&gt;</code>: A dynamic array type that can grow and shrink, unlike fixed-size arrays.</p>"},{"location":"reference/type_system/#advanced-type-features-planned","title":"Advanced Type Features (Planned)","text":"<p>The following advanced type features are planned but not yet implemented:</p>"},{"location":"reference/type_system/#tuples","title":"Tuples","text":"<p>Tuples will allow grouping of values with different types. They will be immutable and can be accessed by index:</p> <pre><code>// Future syntax\ntuple&lt;int8, string&gt; person = (30, \"John\");\nint8 age = person[0];  // 30\nstring name = person[1];  // \"John\"\n</code></pre>"},{"location":"reference/type_system/#generics","title":"Generics","text":"<p>Generics allow you to write flexible, reusable code that works with multiple types while maintaining type safety. Instead of writing separate functions for each type, you write one generic function that works with any compatible type.</p>"},{"location":"reference/type_system/#basic-generic-functions","title":"Basic Generic Functions","text":"<p>A generic function is declared with type parameters in angle brackets after the function name:</p> <pre><code>T max&lt;T&gt;(T a, T b) {\n    if (a &gt; b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// Type parameter is inferred from arguments\nint8 largerInt = max(5i8, 10i8);        // T inferred as int8\nstring largerString = max(\"apple\", \"banana\");  // T inferred as string\n\n// Or explicitly specified\nfloat32 largerFloat = max&lt;float32&gt;(3.14f32, 2.71f32);\n</code></pre>"},{"location":"reference/type_system/#type-constraints","title":"Type Constraints","text":"<p>Type constraints restrict which types can be used with a generic function. This ensures the function only accepts types that support the required operations.</p> <p>Interface Constraints:</p> <pre><code>// T must satisfy the Comparable interface\nT max&lt;T: Comparable&gt;(T a, T b) {\n    return a &gt; b ? a : b;\n}\n\n// T must satisfy the Numeric interface\nT add&lt;T: Numeric&gt;(T a, T b) {\n    return a + b;\n}\n</code></pre> <p>Type Union Constraints:</p> <p>For simpler cases, you can use type unions to explicitly list which types are allowed:</p> <pre><code>// T can be int32, int64, or float64\nT add&lt;T: int32 | int64 | float64&gt;(T a, T b) {\n    return a + b;\n}\n\n// Works with any of the specified types\nint32 result1 = add(5i32, 10i32);        // \u2705 Works\nfloat64 result2 = add(3.14f64, 2.71f64); // \u2705 Works\n// int8 result3 = add(1i8, 2i8);         // \u274c Error: int8 not in union\n\n// Type unions work with any types, including custom classes\nclass Point { /* ... */ }\nclass Circle { /* ... */ }\n\nT process&lt;T: Point | Circle&gt;(T shape) {\n    // Can work with Point or Circle\n    return shape;\n}\n</code></pre> <p>Multiple Constraints:</p> <p>You can combine both interface constraints and type unions:</p> <pre><code>import @firescript/std.io.{print};\n\n// T must satisfy Comparable AND be in the union\nT clamp&lt;T: Comparable &amp; (int32 | float64)&gt;(T value, T min, T max) {\n    if (value &lt; min) return min;\n    if (value &gt; max) return max;\n    return value;\n}\n\n// Multiple interface constraints\nT process&lt;T: Printable &amp; Drawable&gt;(T item) {\n    print(item.toString());\n    item.draw();\n    return item;\n}\n</code></pre> <p>When to Use Each:</p> <ul> <li>Interface constraints (<code>T: Comparable</code>): When you need types with specific capabilities, works with any type that implements the interface</li> <li>Type unions (<code>T: int32 | float64</code>): When you want to explicitly list allowed types, simple and explicit</li> <li>Built-in interfaces (<code>T: Numeric</code>, <code>SignedInt</code>, <code>Float</code>): For common operations across type families</li> </ul>"},{"location":"reference/type_system/#type-union-constraints","title":"Type Union Constraints","text":"<p>Type unions provide a simple, explicit way to define generic constraints by listing the exact types allowed. This is inspired by Python's <code>Union</code> but with firescript's explicit syntax.</p> <p>Basic Type Unions:</p> <pre><code>// Simple union - T can be int32 or float64\nT convert&lt;T: int32 | float64&gt;(T value) {\n    return value;\n}\n\n// Multiple types in union\nT process&lt;T: int8 | int16 | int32 | int64&gt;(T value) {\n    return value * 2;\n}\n\n// Works with custom types too\nclass Dog { /* ... */ }\nclass Cat { /* ... */ }\n\nT feed&lt;T: Dog | Cat&gt;(T animal) {\n    // Feed the animal\n    return animal;\n}\n</code></pre> <p>Combining Unions with Interfaces:</p> <p>You can require that types satisfy both an interface AND be in a specific union:</p> <pre><code>// T must be Comparable AND one of these specific types\nT max&lt;T: Comparable &amp; (int32 | int64 | float64)&gt;(T a, T b) {\n    return a &gt; b ? a : b;\n}\n\n// Custom interface with type union\ninterface Drawable {\n    void draw(&amp;this);\n}\n\nclass Square implements Drawable { /* ... */ }\nclass Circle implements Drawable { /* ... */ }\n\n// T must implement Drawable AND be one of these types\nT render&lt;T: Drawable &amp; (Square | Circle)&gt;(T shape) {\n    shape.draw();\n    return shape;\n}\n</code></pre> <p>Type Unions vs. Interfaces:</p> <pre><code>// Using interface - open-ended, any type that implements Numeric\nT addWithInterface&lt;T: Numeric&gt;(T a, T b) {\n    return a + b;\n}\n\n// Using type union - closed, only these specific types\nT addWithUnion&lt;T: int32 | int64 | float64&gt;(T a, T b) {\n    return a + b;\n}\n\n// Interface: More flexible, allows future types\n// Union: More explicit, you know exactly what's allowed\n</code></pre> <p>Practical Example:</p> <pre><code>// Define a function that only works with specific numeric types\nT safeDivide&lt;T: float32 | float64&gt;(T a, T b) {\n    if (b == 0.0) {\n        return 0.0;  // Safe default for floats\n    }\n    return a / b;\n}\n\nfloat32 result1 = safeDivide(10.0f32, 2.0f32);  // \u2705 Works\nfloat64 result2 = safeDivide(10.0f64, 2.0f64);  // \u2705 Works\n// int32 result3 = safeDivide(10i32, 2i32);     // \u274c Error: int32 not in union\n</code></pre>"},{"location":"reference/type_system/#built-in-type-constraints","title":"Built-in Type Constraints","text":"<p>firescript provides several built-in constraint interfaces that are automatically implemented by appropriate types:</p> <p>Numeric Constraints:</p> <ul> <li><code>Numeric</code> - Any numeric type (int, uint, float of any precision)</li> <li>Supports: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code></li> <li> <p>Implemented by: All <code>intN</code>, <code>uintN</code>, and <code>floatN</code> types</p> </li> <li> <p><code>Integer</code> - Any integer type (signed or unsigned)</p> </li> <li>Supports: All <code>Numeric</code> operations plus bitwise operations</li> <li> <p>Implemented by: All <code>intN</code> and <code>uintN</code> types</p> </li> <li> <p><code>SignedInt</code> - Signed integers only</p> </li> <li>Supports: All <code>Integer</code> operations plus unary negation</li> <li> <p>Implemented by: All <code>intN</code> types (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>)</p> </li> <li> <p><code>UnsignedInt</code> - Unsigned integers only</p> </li> <li>Supports: All <code>Integer</code> operations</li> <li> <p>Implemented by: All <code>uintN</code> types (<code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>)</p> </li> <li> <p><code>Float</code> - Floating-point types only</p> </li> <li>Supports: All <code>Numeric</code> operations</li> <li>Implemented by: All <code>floatN</code> types (<code>float32</code>, <code>float64</code>, <code>float128</code>)</li> </ul> <p>Behavioral Constraints:</p> <ul> <li><code>Comparable</code> - Types that can be compared</li> <li>Supports: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></li> <li> <p>Implemented by: All numeric types, <code>string</code>, <code>char</code>, <code>bool</code></p> </li> <li> <p><code>Equatable</code> - Types that support equality testing</p> </li> <li>Supports: <code>==</code>, <code>!=</code></li> <li> <p>Implemented by: All built-in types</p> </li> <li> <p><code>Copyable</code> - Types that can be copied (as opposed to moved)</p> </li> <li>All primitive types are <code>Copyable</code></li> <li>Classes are <code>Owned</code> by default (not <code>Copyable</code>)</li> </ul> <p>Examples:</p> <pre><code>// Works with any numeric type\nT square&lt;T: Numeric&gt;(T x) {\n    return x * x;\n}\n\n// Only works with floating-point types\nT sqrt&lt;T: Float&gt;(T value) {\n    // Implementation uses floating-point operations\n    return __builtin_sqrt(value);\n}\n\n// Only works with signed integers\nT abs&lt;T: SignedInt&gt;(T value) {\n    return value &lt; 0 ? -value : value;\n}\n\n// Works with any comparable type\nT clamp&lt;T: Comparable&gt;(T value, T min, T max) {\n    if (value &lt; min) return min;\n    if (value &gt; max) return max;\n    return value;\n}\n</code></pre>"},{"location":"reference/type_system/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<p>Functions can have multiple generic type parameters:</p> <pre><code>// Convert from one type to another\nR convert&lt;T, R&gt;(T value) {\n    return cast&lt;R&gt;(value);\n}\n\n// Map a function over a value\nR map&lt;T, R&gt;(T value, R func(T)) {\n    return func(value);\n}\n\n// Combine two values of different types\nR combine&lt;T1, T2, R: Numeric&gt;(T1 a, T2 b) {\n    return cast&lt;R&gt;(a) + cast&lt;R&gt;(b);\n}\n\n// With constraints on each parameter\nR interpolate&lt;T: Float, R: Float&gt;(T a, T b, R t) {\n    return cast&lt;R&gt;(a) + cast&lt;R&gt;((b - a) * cast&lt;T&gt;(t));\n}\n</code></pre>"},{"location":"reference/type_system/#generic-constants-and-type-associated-values","title":"Generic Constants and Type-Associated Values","text":"<p>For constants that need to adapt to the type precision, use type-associated constant functions:</p> <pre><code>// Type-associated constants (planned syntax)\nT pi&lt;T: float&lt;N&gt;&gt;() {\n    // Compiler provides appropriate precision for each float type\n    return cast&lt;T&gt;(3.141592653589793238462643383279502884197);\n}\n\nT e&lt;T: float&lt;N&gt;&gt;() {\n    return cast&lt;T&gt;(2.718281828459045235360287471352662497757);\n}\n\n// Usage - type is inferred from context\nfloat32 circumference32(float32 radius) {\n    return 2.0f32 * pi&lt;float32&gt;() * radius;\n}\n\nfloat64 circumference64(float64 radius) {\n    return 2.0f64 * pi&lt;float64&gt;() * radius;\n}\n\n// Or with type inference\nfloat32 area(float32 radius) {\n    float32 piValue = pi();  // Type inferred as float32 from variable type\n    return piValue * radius * radius;\n}\n</code></pre>"},{"location":"reference/type_system/#type-inference","title":"Type Inference","text":"<p>The firescript compiler can infer generic type parameters from function arguments in most cases:</p> <pre><code>T identity&lt;T&gt;(T value) {\n    return value;\n}\n\n// Type parameter inferred from argument\nint32 x = identity(42i32);        // T inferred as int32\nstring s = identity(\"hello\");      // T inferred as string\n\n// Explicit type parameter when needed\nfloat64 y = identity&lt;float64&gt;(42); // Converts 42 to float64\n</code></pre> <p>Type inference follows these rules:</p> <ol> <li>If argument types match the parameter types, infer from arguments</li> <li>If return type is known and argument types are ambiguous, infer from return type</li> <li>If neither works, require explicit type parameters</li> <li>All type parameters must be consistently inferred</li> </ol> <pre><code>T add&lt;T: Numeric&gt;(T a, T b) {\n    return a + b;\n}\n\nint32 result1 = add(10i32, 20i32);  // \u2705 T inferred as int32\nfloat32 result2 = add(1.5f32, 2.5f32);  // \u2705 T inferred as float32\n\n// int32 result3 = add(10i32, 20i64);  // \u274c Error: T cannot be both int32 and int64\n</code></pre>"},{"location":"reference/type_system/#generic-classes-planned","title":"Generic Classes (Planned)","text":"<p>Generic classes will allow creating data structures that work with any type:</p> <pre><code>// Planned syntax\nclass Box&lt;T&gt; {\n    T value;\n\n    Box(&amp;this, T value) {\n        this.value = value;\n    }\n\n    T getValue(&amp;this) {\n        return this.value;\n    }\n\n    void setValue(&amp;this, T newValue) {\n        this.value = newValue;\n    }\n}\n\n// Usage\nBox&lt;int32&gt; intBox = Box(42i32);\nBox&lt;string&gt; strBox = Box(\"hello\");\n\nint32 x = intBox.getValue();    // 42\nstring s = strBox.getValue();    // \"hello\"\n</code></pre> <p>Generic classes with constraints:</p> <pre><code>// Planned syntax\nclass Pair&lt;T: Comparable&gt; {\n    T first;\n    T second;\n\n    Pair(&amp;this, T first, T second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    T max(&amp;this) {\n        return this.first &gt; this.second ? this.first : this.second;\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#generic-arrays-and-collections-planned","title":"Generic Arrays and Collections (Planned)","text":"<p>The standard library will provide generic collection types:</p> <pre><code>// Planned syntax\nlist&lt;T&gt; myList = list&lt;int32&gt;();\nmyList.push(1);\nmyList.push(2);\nmyList.push(3);\n\nmap&lt;string, int32&gt; scores = map&lt;string, int32&gt;();\nscores.set(\"Alice\", 100);\nscores.set(\"Bob\", 95);\n\nnullable int32 aliceScore = scores.get(\"Alice\");  // 100\n</code></pre>"},{"location":"reference/type_system/#implementation-notes","title":"Implementation Notes","text":"<p>Generics in firescript use monomorphization at compile time:</p> <ol> <li>When you call a generic function with specific types, the compiler generates a specialized version</li> <li>Each unique combination of type parameters gets its own compiled function</li> <li>This means zero runtime overhead - generic code is as fast as hand-written type-specific code</li> <li>The tradeoff is slightly larger binary size (one copy of the function per type combination used)</li> </ol> <pre><code>// You write this once:\nT max&lt;T: Comparable&gt;(T a, T b) {\n    return a &gt; b ? a : b;\n}\n\n// If you call it with int32 and float32:\nint32 x = max(5i32, 10i32);\nfloat32 y = max(3.14f32, 2.71f32);\n\n// The compiler generates (conceptually):\nint32 max_int32(int32 a, int32 b) { return a &gt; b ? a : b; }\nfloat32 max_float32(float32 a, float32 b) { return a &gt; b ? a : b; }\n\n// And replaces your calls with:\nint32 x = max_int32(5i32, 10i32);\nfloat32 y = max_float32(3.14f32, 2.71f32);\n</code></pre> <p>This approach is similar to C++ templates and Rust generics, ensuring that generic code has no performance penalty.</p>"},{"location":"reference/type_system/#custom-type-constraints","title":"Custom Type Constraints","text":"<p>For frequently used type union constraints, you can define named constraint aliases to avoid repetition and improve code readability.</p> <p>Defining Constraint Aliases:</p> <pre><code>// Define a constraint alias using the 'constraint' keyword\nconstraint NumericPrimitive = int32 | int64 | float32 | float64;\n\nconstraint SignedInteger = int8 | int16 | int32 | int64;\n\nconstraint UnsignedInteger = uint8 | uint16 | uint32 | uint64;\n\nconstraint FloatingPoint = float32 | float64 | float128;\n</code></pre> <p>Using Constraint Aliases:</p> <pre><code>// Use the constraint alias just like a built-in constraint\nT add&lt;T: NumericPrimitive&gt;(T a, T b) {\n    return a + b;\n}\n\nT abs&lt;T: SignedInteger&gt;(T x, T zero) {\n    if (x &lt; zero) {\n        return -x;\n    }\n    return x;\n}\n\nT clamp&lt;T: FloatingPoint&gt;(T value, T min, T max) {\n    if (value &lt; min) return min;\n    if (value &gt; max) return max;\n    return value;\n}\n\n// Usage is natural\nint32 sum = add(10i32, 20i32);          // \u2705 Works with NumericPrimitive\nfloat64 clamped = clamp(5.5, 0.0, 10.0); // \u2705 Works with FloatingPoint\n</code></pre> <p>Combining Constraint Aliases:</p> <p>You can combine constraint aliases with other constraints:</p> <pre><code>constraint IntegerType = SignedInteger | UnsignedInteger;\n\n// Combine with interface constraints\nT process&lt;T: Comparable &amp; IntegerType&gt;(T value) {\n    // T must be comparable AND one of the integer types\n    return value;\n}\n\n// Combine multiple constraint aliases with unions\nconstraint AllNumeric = SignedInteger | UnsignedInteger | FloatingPoint;\n\nT compute&lt;T: AllNumeric&gt;(T value) {\n    return value * value;\n}\n</code></pre> <p>Constraint Aliases for Custom Types:</p> <p>Constraint aliases also work with custom classes:</p> <pre><code>class Circle { /* ... */ }\nclass Square { /* ... */ }\nclass Triangle { /* ... */ }\n\n// Define a constraint for shape types\nconstraint Shape2D = Circle | Square | Triangle;\n\n// Use in generic functions\nT area&lt;T: Shape2D&gt;(T shape) {\n    // Calculate area for any 2D shape\n    return shape.calculateArea();\n}\n\n// Can be combined with interfaces\ninterface Drawable {\n    void draw(&amp;this);\n}\n\nT render&lt;T: Drawable &amp; Shape2D&gt;(T shape) {\n    shape.draw();\n    return shape;\n}\n</code></pre> <p>Benefits:</p> <ol> <li>DRY (Don't Repeat Yourself): Define the constraint once, use it many times</li> <li>Readability: <code>T: NumericPrimitive</code> is clearer than <code>T: int32 | int64 | float32 | float64</code></li> <li>Maintainability: Change the constraint in one place instead of updating every function</li> <li>Semantic clarity: Names like <code>SignedInteger</code> convey intent better than type lists</li> </ol> <p>Constraint Aliases vs. Interfaces:</p> <pre><code>// Constraint alias - just a shorthand for a type union\nconstraint FastInt = int32 | int64;\nT add&lt;T: FastInt&gt;(T a, T b) { return a + b; }\n// Expands to: T add&lt;T: int32 | int64&gt;(T a, T b)\n\n// Interface - defines required capabilities\ninterface Printable {\n    string toString(&amp;this);\n}\nT print&lt;T: Printable&gt;(T value) { /* ... */ }\n// Requires T to have a toString() method\n</code></pre> <p>Scope and Visibility:</p> <p>Constraint aliases follow the same scoping rules as other declarations:</p> <pre><code>// Module-level constraint (usable throughout the file)\nconstraint ModuleNumeric = int32 | float32;\n\n// Within a namespace (planned)\nnamespace Math {\n    constraint PreciseFloat = float64 | float128;\n\n    T compute&lt;T: PreciseFloat&gt;(T value) {\n        return value;\n    }\n}\n\n// Import constraints from other modules (planned)\nimport std.types.{NumericPrimitive, SignedInteger};\n</code></pre>"},{"location":"reference/type_system/#interfaces","title":"Interfaces","text":"<p>Interfaces define a set of capabilities that types can implement. They are used primarily as constraints for generic type parameters, ensuring that generic code only accepts types that support the required operations.</p> <p>Key Design Principles:</p> <ol> <li>Primitive types are closed: You cannot implement interfaces directly on primitive types like <code>int32</code>, <code>float64</code>, etc.</li> <li>Built-in interfaces have compiler support: Interfaces like <code>Numeric</code>, <code>Comparable</code>, etc. work with primitives through compiler magic.</li> <li>Custom interfaces need wrappers: For custom interfaces, create wrapper classes or use standard library wrappers.</li> <li>Classes use <code>implements</code>: Custom classes declare interfaces using the <code>implements</code> keyword (Java-style).</li> </ol> <pre><code>// Built-in interfaces work with primitives (compiler support)\nT max&lt;T: Comparable&gt;(T a, T b) { return a &gt; b ? a : b; }\nint32 result = max(5i32, 10i32);  // \u2705 Works\n\n// Custom interfaces need wrapper classes\ninterface Printable {\n    string toString(&amp;this);\n}\n\nclass PrintableInt implements Printable {\n    int32 value;\n    string toString(&amp;this) { return toString(this.value); }\n}\n</code></pre>"},{"location":"reference/type_system/#defining-an-interface","title":"Defining an Interface","text":"<p>An interface is defined using the <code>interface</code> keyword followed by the interface name and a body:</p> <pre><code>// Basic interface definition\ninterface Printable {\n    // Method signature that implementing types must provide\n    string toString(&amp;this);\n}\n\n// Interface with multiple methods\ninterface Drawable {\n    void draw(&amp;this);\n    void move(&amp;this, int32 x, int32 y);\n    bool isVisible(&amp;this);\n}\n</code></pre>"},{"location":"reference/type_system/#interface-inheritance","title":"Interface Inheritance","text":"<p>Interfaces can inherit from other interfaces, creating a hierarchy of capabilities:</p> <pre><code>// Base interface\ninterface Equatable {\n    bool equals(&amp;this, &amp;this other);\n}\n\n// Child interface inherits parent's requirements\ninterface Comparable from Equatable {\n    int32 compare(&amp;this, &amp;this other);  // Returns -1, 0, or 1\n}\n\n// Types implementing Comparable must also implement Equatable\n</code></pre>"},{"location":"reference/type_system/#implementing-interfaces-for-types","title":"Implementing Interfaces for Types","text":"<p>Classes declare which interfaces they implement using the <code>implements</code> keyword:</p> <pre><code>import @firescript/std.io.{print};\\n\\n// Define a class that implements an interface\nclass Point implements Printable {\n    float32 x;\n    float32 y;\n\n    Point(&amp;this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // Implement the required method from Printable\n    string toString(&amp;this) {\n        return \"Point(\" + toString(this.x) + \", \" + toString(this.y) + \")\";\n    }\n}\n\n// Implement multiple interfaces\nclass Circle implements Drawable, Printable {\n    float32 radius;\n\n    Circle(&amp;this, float32 radius) {\n        this.radius = radius;\n    }\n\n    // Implement Drawable methods\n    void draw(&amp;this) {\n        print(\"Drawing circle with radius \" + toString(this.radius));\n    }\n\n    void move(&amp;this, int32 dx, int32 dy) {\n        // Movement logic\n    }\n\n    bool isVisible(&amp;this) {\n        return true;\n    }\n\n    // Implement Printable method\n    string toString(&amp;this) {\n        return \"Circle(radius=\" + toString(this.radius) + \")\";\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#primitives-with-generic-constraints","title":"Primitives with Generic Constraints","text":"<p>Built-in interfaces like <code>Numeric</code>, <code>Comparable</code>, etc. work directly with primitive types through compiler magic. You don't need wrappers for these:</p> <pre><code>// Built-in interfaces work with primitives directly\nT max&lt;T: Comparable&gt;(T a, T b) {\n    return a &gt; b ? a : b;\n}\n\nint32 result = max(5i32, 10i32);  // \u2705 Works! No wrapper needed\nfloat64 fResult = max(3.14f64, 2.71f64);  // \u2705 Works!\n\n// This is compiler magic - the compiler knows int32 satisfies Comparable\n</code></pre> <p>For custom interfaces, you need wrappers:</p> <pre><code>import @firescript/std.io.{print};\n\n// Custom interface\ninterface Printable {\n    string toString(&amp;this);\n}\n\n// This won't work with primitives directly\nvoid printValue&lt;T: Printable&gt;(T value) {\n    print(value.toString());\n}\n\n// printValue(42i32);  // \u274c Error: int32 does not implement Printable\n\n// Create a wrapper class\nclass PrintableInt implements Printable {\n    int32 value;\n\n    PrintableInt(&amp;this, int32 value) {\n        this.value = value;\n    }\n\n    string toString(&amp;this) {\n        return \"Value: \" + toString(this.value);\n    }\n}\n\n// Now it works\nprintValue(PrintableInt(42));  // \u2705 Works!\n</code></pre> <p>Summary: - Type unions (<code>T: int32 | float64</code>): Simplest way to constrain primitives - use this first! - Built-in interfaces (<code>SignedInt</code>, <code>Float</code>, <code>Comparable</code>, etc.): Work with primitives directly for broader type families - Custom interfaces with wrappers: Only when you need custom methods on primitives</p>"},{"location":"reference/type_system/#using-interfaces-as-generic-constraints","title":"Using Interfaces as Generic Constraints","text":"<p>Interfaces are most commonly used to constrain generic type parameters:</p> <pre><code>import @firescript/std.io.{print};\n\n// Function that works with any Printable type\nvoid printValue&lt;T: Printable&gt;(T value) {\n    print(value.toString());\n}\n\n// Function that works with any Drawable type\nvoid renderAll&lt;T: Drawable&gt;(T[] items) {\n    for (int32 i = 0; i &lt; items.length; i = i + 1) {\n        items[i].draw();\n    }\n}\n\n// Multiple interface constraints\nvoid processItem&lt;T: Printable &amp; Drawable&gt;(T item) {\n    print(\"Processing: \" + item.toString());\n    item.draw();\n}\n</code></pre>"},{"location":"reference/type_system/#marker-interfaces","title":"Marker Interfaces","text":"<p>Some interfaces don't require any methods - they simply mark that a type has certain properties. These are called marker interfaces:</p> <pre><code>// Marker interface - no methods required\ninterface Copyable {\n    // Types implementing this can be copied bitwise\n}\n\ninterface Serializable {\n    // Types implementing this can be serialized\n}\n\n// Implementing marker interfaces in class definition\nclass Point implements Copyable, Serializable {\n    float32 x;\n    float32 y;\n\n    // No methods to implement - just marks Point as copyable and serializable\n    Point(&amp;this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#built-in-interfaces","title":"Built-in Interfaces","text":"<p>firescript provides several built-in interfaces that are automatically \"implemented\" by primitive types through compiler support. These are defined in <code>std/interfaces/</code>:</p> <p>Numeric Interfaces (in <code>std/interfaces/numeric.fire</code>): - <code>Numeric</code> - Any numeric type supporting arithmetic operations - <code>Integer</code> - Any integer type (signed or unsigned) - <code>SignedInt</code> - Signed integers only - <code>UnsignedInt</code> - Unsigned integers only - <code>Float</code> - Floating-point types only</p> <p>Comparison Interfaces (in <code>std/interfaces/comparable.fire</code>): - <code>Equatable</code> - Types supporting <code>==</code> and <code>!=</code> - <code>Comparable</code> - Types supporting comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)</p> <p>Memory Interfaces (in <code>std/interfaces/copyable.fire</code>): - <code>Copyable</code> - Types that can be copied (vs. moved)</p> <p>These interfaces are automatically imported and available without explicit <code>import</code> statements.</p> <p>How Built-in Interfaces Work:</p> <ul> <li>Primitive types (<code>int32</code>, <code>float64</code>, etc.): The compiler automatically recognizes that they satisfy built-in interfaces. You can use them directly with generic constraints.</li> <li>Custom classes: Must explicitly implement interfaces using <code>implements</code> in their class definition.</li> </ul> <pre><code>// Built-in interfaces work with primitives\nT add&lt;T: Numeric&gt;(T a, T b) {\n    return a + b;\n}\n\nint32 sum = add(5i32, 10i32);  // \u2705 Compiler knows int32 satisfies Numeric\n\n// Custom classes must explicitly implement\nclass MyNumber implements Numeric {\n    int32 value;\n\n    MyNumber(&amp;this, int32 value) {\n        this.value = value;\n    }\n\n    // Must implement Numeric operations...\n}\n</code></pre>"},{"location":"reference/type_system/#combining-interface-constraints","title":"Combining Interface Constraints","text":"<p>You can combine multiple interface constraints to require specific capabilities:</p> <pre><code>// Works with any signed integer precision\nT negate&lt;T: SignedInt&gt;(T value) {\n    return -value;\n}\n\n// Works with any float precision\nT normalize&lt;T: Float&gt;(T value, T min, T max) {\n    return (value - min) / (max - min);\n}\n\n// Combine interface constraints\nT clamp&lt;T: Comparable &amp; Numeric&gt;(T value, T min, T max) {\n    if (value &lt; min) return min;\n    if (value &gt; max) return max;\n    return value;\n}\n</code></pre>"},{"location":"reference/type_system/#default-implementations-planned","title":"Default Implementations (Planned)","text":"<p>In the future, interfaces may support default method implementations:</p> <pre><code>// Planned syntax\ninterface Comparable from Equatable {\n    int32 compare(&amp;this, &amp;this other);\n\n    // Default implementations based on compare()\n    bool lessThan(&amp;this, &amp;this other) {\n        return this.compare(other) &lt; 0;\n    }\n\n    bool greaterThan(&amp;this, &amp;this other) {\n        return this.compare(other) &gt; 0;\n    }\n}\n\n// Types implementing Comparable only need to provide compare()\n// They get lessThan() and greaterThan() for free\n</code></pre>"},{"location":"reference/type_system/#associated-types-planned","title":"Associated Types (Planned)","text":"<p>Interfaces may support associated types for more flexible generic programming:</p> <pre><code>// Planned syntax\ninterface Container {\n    type Item;  // Associated type\n\n    Item get(&amp;this, int32 index);\n    void set(&amp;this, int32 index, Item value);\n    int32 size(&amp;this);\n}\n\nimpl Container for IntArray {\n    type Item = int32;  // Specify the associated type\n\n    int32 get(&amp;this, int32 index) {\n        return this.data[index];\n    }\n\n    void set(&amp;this, int32 index, int32 value) {\n        this.data[index] = value;\n    }\n\n    int32 size(&amp;this) {\n        return this.length;\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#interface-objects-planned","title":"Interface Objects (Planned)","text":"<p>In the future, interfaces may be used as types themselves, allowing for dynamic dispatch:</p> <pre><code>import @firescript/std.io.{print};\n\n// Planned syntax\nvoid printAll(Printable[] items) {  // Array of interface objects\n    for (int32 i = 0; i &lt; items.length; i = i + 1) {\n        print(items[i].toString());\n    }\n}\n\n// Can pass any type implementing Printable\nPoint p = Point(1.0f32, 2.0f32);\nCircle c = Circle(3.0f32);\nPrintable[] mixed = [p, c];  // Different types, same interface\nprintAll(mixed);\n</code></pre>"},{"location":"reference/type_system/#design-guidelines-for-interfaces","title":"Design Guidelines for Interfaces","text":"<p>When designing interfaces, follow these guidelines:</p> <ol> <li>Single Responsibility: Each interface should represent one cohesive capability</li> <li>Small and Focused: Prefer many small interfaces over few large ones</li> <li>Composable: Use interface inheritance to build complex capabilities from simple ones</li> <li>Clear Naming: Interface names should clearly indicate the capability (e.g., <code>Readable</code>, <code>Writable</code>, <code>Comparable</code>)</li> <li>Minimal Requirements: Only include methods that are truly essential to the interface</li> </ol> <pre><code>// Good: Small, focused interfaces\ninterface Readable {\n    string read(&amp;this);\n}\n\ninterface Writable {\n    void write(&amp;this, string data);\n}\n\ninterface Seekable {\n    void seek(&amp;this, int64 position);\n}\n\n// Can combine them as needed\nclass File implements Readable, Writable, Seekable {\n    // ... fields ...\n\n    // Implement all required methods\n    string read(&amp;this) { /* ... */ }\n    void write(&amp;this, string data) { /* ... */ }\n    void seek(&amp;this, int64 position) { /* ... */ }\n}\n\n// Bad: One monolithic interface\ninterface FileOperations {\n    string read(&amp;this);\n    void write(&amp;this, string data);\n    void seek(&amp;this, int64 position);\n    bool exists(&amp;this);\n    void delete(&amp;this);\n    // Too many unrelated operations!\n}\n</code></pre>"},{"location":"reference/type_system/#user-defined-types-classes","title":"User-Defined Types (Classes)","text":"<p>Classes will enable user-defined types with methods and properties:</p> <pre><code>// Future syntax\nclass Point {\n    float32 x;\n    float32 y;\n\n    Point(this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    float32 distanceTo(this, Point other) {\n        float32 dx = this.x - other.x;\n        float32 dy = this.y - other.y;\n        return toFloat((dx * dx + dy * dy) ** 0.5);\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 All integer types (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>)</li> <li>\u2705 All floating point types (<code>float32</code>, <code>float64</code>, <code>float128</code>)</li> <li>\u2705 Nullable type modifiers</li> <li>\u2705 Arrays (as Owned heap-allocated types)</li> <li>\u2705 Static type checking for expressions and assignments</li> <li>\u26a0\ufe0f Explicit type casting (only for numeric types at present)</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c Type inference on variable declarations</li> <li>\u274c Type introspection with <code>typeof</code></li> <li>\u274c Tuples</li> <li>\u274c Interfaces (syntax and semantics documented, implementation pending)</li> <li>\u274c Interface definitions (<code>interface Name { }</code>)</li> <li>\u274c Interface inheritance (<code>interface Child from Parent { }</code>)</li> <li>\u274c Interface implementations (<code>class Type implements Interface { }</code>)</li> <li>\u274c Built-in interfaces with compiler support (Numeric, Comparable, etc.)</li> <li>\u274c Primitive type wrapper classes (<code>Integer</code>, <code>Float</code>, etc.)</li> <li>\u274c Marker interfaces</li> <li>\u274c Default implementations in interfaces</li> <li>\u274c Associated types</li> <li>\u274c Interface objects / dynamic dispatch</li> <li>\u274c Generics (syntax and semantics documented, implementation pending)</li> <li>\u274c Generic functions</li> <li>\u274c Type constraints with interfaces</li> <li>\u274c Type union constraints (<code>T: int32 | float64</code>)</li> <li>\u274c Generic classes</li> <li>\u274c Type inference for generics</li> <li>\u274c User-defined types (classes)</li> <li>\u274c Function types</li> </ul>"},{"location":"reference/variables/","title":"Types &amp; Variables","text":"<p>Note: Tuple types, the generic placeholder <code>T</code>, and declarations without an initializer are not supported by the compiler. Built-in Copyable types (<code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>) are stack-allocated. Owned types (<code>string</code>, arrays) are heap-allocated with move semantics.</p>"},{"location":"reference/variables/#types","title":"Types","text":"<p>Types are defined in the Type System documentation.</p>"},{"location":"reference/variables/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement:</p> <pre><code>int8 age = 30;\nstring name = \"Alice\";\nbool isRegistered = false;\n</code></pre>"},{"location":"reference/variables/#type-inference","title":"Type Inference","text":"<p>firescript does not support automatic type inference:</p> <pre><code>var score = 95;  // Not supported - must specify the type explicitly\nint8 score = 95;  // Supported\n</code></pre>"},{"location":"reference/variables/#constants","title":"Constants","text":"<p>Use the <code>const</code> keyword to declare immutable variables:</p> <pre><code>const int8 MAX_USERS = 100;\nconst string APP_VERSION = \"1.0.0\";\n</code></pre> <p>Constants must be initialized when declared and cannot be reassigned later:</p> <pre><code>const float32 PI = 3.14;\nPI = 3.14159;  // Error: cannot reassign a constant\n</code></pre>"},{"location":"reference/variables/#nullability","title":"Nullability","text":"<p>By default, variables cannot be assigned <code>null</code>. The <code>nullable</code> keyword explicitly allows a variable to hold <code>null</code>:</p> <pre><code>nullable string username = null;  // Valid\nstring password = null;           // Invalid - non-nullable type cannot hold null\n</code></pre> <p>Attempting to use a nullable variable without checking for null may result in runtime errors:</p> <pre><code>import @firescript/std.io.{print};\\n\\nnullable string message = null;\n\n// Safe access pattern\nif (message != null) {\n    print(message);\n}\n</code></pre>"},{"location":"reference/variables/#implementation-status","title":"Implementation Status","text":"<p>Variable declaration and initialization is fully supported for some built-in Copyable types. User-defined types and tuples are planned for future versions. Constants and nullability are also planned features.</p>"}]}