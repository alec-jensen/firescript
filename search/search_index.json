{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"firescript v0.2.0 Documentation","text":"<p>Note: The current compiler does not support all language features. Unsupported features are explicitly marked in each guide with Not yet implemented or Note.</p> <p>This documentation is organized to help both newcomers and experienced developers understand and use the firescript language effectively.</p>"},{"location":"#1-language-reference-manual","title":"1. Language Reference Manual","text":"<ul> <li>Type System - Formal definition of types, nullability, arrays</li> <li>Scoping Rules - Variable visibility, lifetime, and scope creation</li> <li>Control Flow - Conditional statements and loops</li> </ul>"},{"location":"#2-getting-started-tutorials","title":"2. Getting Started &amp; Tutorials","text":"<ul> <li>Types &amp; Variables - Basic variable declarations and types</li> <li>Arrays - Working with array data structures</li> <li>Functions &amp; Methods - Built-in functions and user-defined functions</li> </ul>"},{"location":"#3-language-features","title":"3. Language Features","text":"<ul> <li>Classes &amp; Inheritance - Object-oriented programming fundamentals</li> </ul>"},{"location":"#4-standard-library-reference","title":"4. Standard Library Reference","text":"<ul> <li>Built-in functions: <code>print</code>, <code>input</code>, <code>toInt</code>, <code>toFloat</code>, etc.</li> <li>Array operations: <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, <code>length</code></li> </ul>"},{"location":"#5-examples","title":"5. Examples","text":"<p>Check the <code>/examples</code> directory for complete code samples:</p> <ul> <li>Basic usage of built-in functions</li> <li>Fibonacci sequence implementation</li> <li>Array manipulation</li> <li>Scope and variable visibility demonstrations</li> </ul>"},{"location":"#6-changelog","title":"6. Changelog","text":"<p>For the latest updates and changes to the firescript language, see the changelog.</p>"},{"location":"#implementation-status","title":"Implementation Status","text":"<p>firescript is under active development. Key limitations in the current compiler version:</p> <ul> <li>\u2705 Primitive types (<code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>string</code>, <code>char</code>) are fully supported.</li> <li>\u2705 Arrays support basic operations: <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, and <code>length</code>.</li> <li>\u2705 Static type checking for expressions and assignments.</li> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, and type conversions.</li> <li>\u274c User-defined functions are not yet implemented.</li> <li>\u274c Classes and inheritance are planned but not implemented.</li> <li>\u274c Advanced array features like slicing and negative indices are not supported.</li> <li>\u274c Control flow is limited to <code>if</code>/<code>else</code> and <code>while</code> loops; <code>for</code> loops and <code>switch</code> statements are not implemented.</li> </ul>"},{"location":"arrays/","title":"Arrays","text":"<p>Note: Only dynamic arrays with literal initialization and methods <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, and <code>length</code> are supported by the compiler. Array slicing, negative indices, and other utility methods are not implemented.</p>"},{"location":"arrays/#array-basics","title":"Array Basics","text":"<p>In firescript, arrays are dynamic, ordered collections of elements that all share the same type. Arrays can grow and shrink in size through various operations and are declared using square brackets after the type.</p>"},{"location":"arrays/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Arrays are declared by appending <code>[]</code> to any valid type and initializing with values in square brackets:</p> <pre><code>// Array initialization with values\nint[] numbers = [10, 20, 30, 40, 50];\nstring[] names = [\"Alice\", \"Bob\", \"Charlie\"];\nbool[] flags = [true, false, true];\n\n// Empty array initialization\nfloat[] prices = [];\n</code></pre> <p>All elements in an array must be of the same type as specified in the declaration.</p>"},{"location":"arrays/#accessing-array-elements","title":"Accessing Array Elements","text":"<p>Individual array elements can be accessed using zero-based indexing:</p> <pre><code>int[] scores = [85, 92, 78, 90, 88];\n\n// Access individual elements\nint firstScore = scores[0];    // 85\nint thirdScore = scores[2];    // 78\n\n// Modifying elements\nscores[1] = 95;                // Array becomes [85, 95, 78, 90, 88]\n</code></pre> <p>\u26a0\ufe0f Warning: Accessing an index outside the array bounds will cause a runtime error. Always ensure your index is valid before access.</p>"},{"location":"arrays/#array-operations","title":"Array Operations","text":"<p>firescript provides several built-in methods for manipulating arrays:</p>"},{"location":"arrays/#adding-elements","title":"Adding Elements","text":"<ul> <li><code>append(element)</code> \u2013 Add an element to the end of the array</li> </ul> <pre><code>int[] numbers = [1, 2, 3];\nnumbers.append(4);        // Array becomes [1, 2, 3, 4]\n</code></pre> <ul> <li><code>insert(index, element)</code> \u2013 Insert an element at the specified position</li> </ul> <pre><code>string[] fruits = [\"apple\", \"orange\", \"banana\"];\nfruits.insert(1, \"grape\");   // Array becomes [\"apple\", \"grape\", \"orange\", \"banana\"]\n</code></pre>"},{"location":"arrays/#removing-elements","title":"Removing Elements","text":"<ul> <li><code>pop()</code> \u2013 Remove and return the last element of the array</li> </ul> <pre><code>int[] stack = [10, 20, 30];\nint lastItem = stack.pop();  // lastItem = 30, stack becomes [10, 20]\n</code></pre> <ul> <li><code>pop(index)</code> \u2013 Remove and return the element at the specified index</li> </ul> <pre><code>string[] colors = [\"red\", \"green\", \"blue\", \"yellow\"];\nstring removed = colors.pop(1);  // removed = \"green\", colors becomes [\"red\", \"blue\", \"yellow\"]\n</code></pre>"},{"location":"arrays/#other-operations","title":"Other Operations","text":"<ul> <li><code>clear()</code> \u2013 Removes all elements from the array</li> </ul> <pre><code>bool[] flags = [true, false, true];\nflags.clear();               // Array becomes []\n</code></pre> <ul> <li><code>length</code> \u2013 Property that returns the current size of the array</li> </ul> <pre><code>int[] data = [5, 10, 15, 20, 25];\nint size = data.length;      // size = 5\n</code></pre>"},{"location":"arrays/#working-with-arrays","title":"Working with Arrays","text":""},{"location":"arrays/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Use a <code>while</code> loop with an index variable to iterate over array elements:</p> <pre><code>string[] cities = [\"New York\", \"London\", \"Tokyo\", \"Paris\", \"Sydney\"];\nint i = 0;\nwhile (i &lt; cities.length) {\n    print(cities[i]);\n    i = i + 1;\n}\n</code></pre>"},{"location":"arrays/#array-as-function-arguments","title":"Array as Function Arguments","text":"<p>Arrays can be passed to functions:</p> <pre><code>// Example of how it would work when user-defined functions are implemented\nint sum(int[] numbers) {\n    int total = 0;\n    int i = 0;\n    while (i &lt; numbers.length) {\n        total = total + numbers[i];\n        i = i + 1;\n    }\n    return total;\n}\n\n// Usage\nint[] values = [1, 2, 3, 4, 5];\nint result = sum(values);  // 15\n</code></pre>"},{"location":"arrays/#nested-arrays","title":"Nested Arrays","text":"<p>Arrays can contain other arrays (though this is not fully implemented yet):</p> <pre><code>// 2D array example\nint[][] matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\n// Accessing elements\nint element = matrix[1][2];  // 6\n</code></pre>"},{"location":"arrays/#common-array-patterns","title":"Common Array Patterns","text":""},{"location":"arrays/#finding-an-element","title":"Finding an Element","text":"<pre><code>int[] numbers = [10, 20, 30, 40, 50];\nint target = 30;\nint index = -1;\nint i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] == target) {\n        index = i;\n        break;\n    }\n    i = i + 1;\n}\n\n// index = 2 if found, -1 if not found\n</code></pre>"},{"location":"arrays/#filtering-elements","title":"Filtering Elements","text":"<pre><code>int[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nint[] evenNumbers = [];\nint i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evenNumbers.append(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// evenNumbers = [2, 4, 6, 8, 10]\n</code></pre>"},{"location":"arrays/#transforming-arrays","title":"Transforming Arrays","text":"<pre><code>int[] numbers = [1, 2, 3, 4, 5];\nint[] doubled = [];\nint i = 0;\n\nwhile (i &lt; numbers.length) {\n    doubled.append(numbers[i] * 2);\n    i = i + 1;\n}\n\n// doubled = [2, 4, 6, 8, 10]\n</code></pre>"},{"location":"arrays/#features-not-yet-implemented","title":"Features Not Yet Implemented","text":"<p>The following array features are planned but not yet implemented in the current compiler:</p> <ul> <li>Array slicing (<code>arr[start:end:step]</code>) \u2013 Extract a portion of the array</li> </ul> <pre><code>// Future syntax\nint[] numbers = [10, 20, 30, 40, 50];\nint[] subset = numbers[1:4];  // Would be [20, 30, 40]\n</code></pre> <ul> <li>Negative indices \u2013 Access elements from the end of the array</li> </ul> <pre><code>// Future syntax\nstring[] words = [\"apple\", \"banana\", \"cherry\"];\nstring last = words[-1];     // Would be \"cherry\"\n</code></pre> <ul> <li>Additional utility methods:</li> <li><code>remove(value)</code> \u2013 Remove the first occurrence of a value</li> <li><code>index(value)</code> \u2013 Find the index of the first occurrence of a value</li> <li><code>count(value)</code> \u2013 Count occurrences of a value</li> <li><code>sort()</code> \u2013 Sort the array elements</li> </ul>"},{"location":"arrays/#implementation-status","title":"Implementation Status","text":"<p>Arrays are functional but with limited operations in the current compiler:</p> <ul> <li>\u2705 Array declaration and initialization</li> <li>\u2705 Element access with positive indices</li> <li>\u2705 Basic methods: append, insert, pop, clear</li> <li>\u2705 Length property</li> <li>\u274c Array slicing</li> <li>\u274c Negative indices</li> <li>\u274c Advanced utility methods</li> <li>\u274c Multi-dimensional array operations</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>firescript follows Semantic Versioning. This makes it easier to understand the impact of changes in each release.</p>"},{"location":"changelog/#020-current-version-may-2025","title":"0.2.0 (Current Version - May 2025)","text":""},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Improved Syntax Handling and Error Reporting:</li> <li>Refactored the lexer and parser for enhanced syntax handling</li> <li>The lexer now correctly handles greater than (<code>&gt;</code>) and less than (<code>&lt;</code>) operators</li> <li>The parser includes stricter checks for Abstract Syntax Tree (AST) node children to prevent unexpected errors from <code>None</code> values</li> <li>Introduced new logic for parsing <code>if</code> and <code>while</code> statements to properly support nested structures</li> <li> <p>Improved error messages with more context for syntax errors</p> </li> <li> <p>Enhanced Memory Management:</p> </li> <li>Added a new reference counter for automated memory management</li> <li>Currently runs in the runtime, with plans to move to the compiler in future versions</li> <li>Helps prevent memory leaks and dangling pointers in the generated code</li> <li> <p>Improved garbage collection for dynamic arrays</p> </li> <li> <p>Arbitrary Precision Integers:</p> </li> <li>The <code>int</code> type is now represented using <code>mpz_t</code> in the generated code</li> <li>Enables arbitrary precision integers for handling large numbers</li> <li>Provides improved accuracy and reliability for complex calculations</li> <li> <p>No practical limit to integer size (constrained only by available memory)</p> </li> <li> <p>Organized Build Outputs:</p> </li> <li>Build outputs and temporary files are now stored in a dedicated <code>build</code> directory</li> <li>Temporary files are specifically located under <code>build/temp</code></li> <li> <p>Cleaner project structure with separate directories for source, documentation, and build artifacts</p> </li> <li> <p>Expanded Array Operations:</p> </li> <li>Added new array methods: <code>clear()</code> and improved <code>pop()</code> functionality</li> <li>Enhanced array bounds checking for safer indexing operations</li> <li> <p>Optimized memory allocation for arrays to improve performance</p> </li> <li> <p>More Operators</p> </li> <li>Added support for compound assignment operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, and <code>%=</code></li> <li>Added support for increment (<code>++</code>) and decrement (<code>--</code>) operators</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed parser issue causing incorrect handling of complex nested expressions</li> <li>Addressed memory leak in string operations when concatenating multiple strings</li> <li>Corrected type checking for nullable values in conditional statements</li> <li>Fixed compilation errors in C code generation for complex boolean expressions</li> <li>Resolved issue with array element access in while loop conditions</li> </ul>"},{"location":"changelog/#code-quality-improvements","title":"Code Quality Improvements","text":"<ul> <li>Comprehensive refactoring of the C code generator for improved maintainability</li> <li>Added more detailed debug logging throughout the compilation process</li> <li>Improved documentation with examples for all supported language features</li> <li>Enhanced test coverage with new test cases for core functionality</li> </ul>"},{"location":"changelog/#011-january-2025","title":"0.1.1 (January 2025)","text":"<p>There is not a version 0.1.0 because of a versioning mishap during initial release.</p>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>Enhanced Variable Scoping:</li> <li>Strict enforcement of variable scoping rules</li> <li>Prevention of variable shadowing to avoid common programming errors</li> <li> <p>Clear error messages for scope-related issues</p> </li> <li> <p>Improved Type System:</p> </li> <li>Comprehensive type checking for variable assignments</li> <li>Type compatibility verification for expressions</li> <li>Function and method call parameter validation</li> <li> <p>Support for nullable types with explicit declaration</p> </li> <li> <p>Control Flow Structures:</p> </li> <li>Basic implementation of <code>if</code>, <code>else if</code>, and <code>else</code> statements</li> <li>Support for <code>while</code> loops with condition checking</li> <li> <p><code>break</code> and <code>continue</code> statements in loops</p> </li> <li> <p>Basic Standard Library:</p> </li> <li>Implementation of essential built-in functions:<ul> <li><code>print()</code> for output</li> <li><code>input()</code> for user input</li> <li>Type conversion functions (<code>toInt()</code>, <code>toFloat()</code>, <code>toString()</code>, etc.)</li> <li><code>typeof()</code> function for runtime type introspection</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Resolved parsing issues for nested expressions</li> <li>Fixed incorrect operator precedence in complex expressions</li> <li>Addressed memory management issues in the runtime library</li> </ul>"},{"location":"changelog/#001-november-2024","title":"0.0.1 (November 2024)","text":""},{"location":"changelog/#initial-release","title":"Initial Release","text":"<ul> <li>First Public Alpha:</li> <li>Basic language structure and syntax</li> <li>Simple variable declarations with primitive types</li> <li>Arithmetic and logical operations</li> <li> <p>First iteration of the compilation pipeline</p> </li> <li> <p>Array Support:</p> </li> <li>Initial implementation of arrays with literal initialization</li> <li>Basic array operations: indexing, assignment</li> <li> <p>Simple array methods: <code>append()</code> and <code>insert()</code></p> </li> <li> <p>Compiler Infrastructure:</p> </li> <li>Lexer for tokenizing source code</li> <li>Parser for building the abstract syntax tree</li> <li>Simple C code generator for compilation</li> <li>Runtime library with basic functions</li> </ul>"},{"location":"changelog/#roadmap-for-future-releases","title":"Roadmap for Future Releases","text":""},{"location":"changelog/#planned-for-version-030","title":"Planned for Version 0.3.0","text":"<ul> <li>Implementation of user-defined functions</li> <li>Enhanced array operations including slicing and negative indices</li> <li>For loop implementations (C-style, for-in, range loops)</li> <li>Better error recovery during compilation</li> <li>Performance optimizations for generated code</li> </ul>"},{"location":"changelog/#planned-for-version-040","title":"Planned for Version 0.4.0","text":"<ul> <li>Basic class system with instance fields and methods</li> <li>Improved standard library with more built-in functions</li> <li>Support for importing code from other files</li> <li>Optional and named function parameters</li> </ul>"},{"location":"changelog/#long-term-goals","title":"Long-term Goals","text":"<ul> <li>Full object-oriented programming support with inheritance</li> <li>Module system for code organization</li> <li>Tuple types and operations</li> <li>Generic type parameters</li> <li>First-class functions and closures</li> <li>Additional language tooling (formatter, linter, debugger)</li> </ul>"},{"location":"classes/","title":"Classes &amp; Inheritance","text":"<p>Note: Class definitions, inheritance, and methods are currently not supported by the compiler. This documentation describes the planned implementation.</p>"},{"location":"classes/#object-oriented-programming-in-firescript","title":"Object-Oriented Programming in firescript","text":"<p>firescript's class system is designed to provide a clean, intuitive approach to object-oriented programming with features like single inheritance, constructors, and both instance and static methods.</p>"},{"location":"classes/#defining-a-class","title":"Defining a Class","text":"<p>A class in firescript is defined using the <code>class</code> keyword, followed by the class name and a block containing fields and methods:</p> <pre><code>class Person {\n    // Fields (instance variables)\n    string name;\n    nullable int age;\n    bool isEmployed;\n\n    // Constructor: 'this' refers to the instance being created\n    Person(this, string name, nullable int age = null, bool isEmployed = false) {\n        this.name = name;\n        this.age = age;\n        this.isEmployed = isEmployed;\n    }\n\n    // Instance methods\n    string getName(this) {\n        return this.name;\n    }\n\n    nullable int getAge(this) {\n        return this.age;\n    }\n\n    void celebrate(this) {\n        if (this.age != null) {\n            this.age = this.age + 1;\n            print(this.name + \" is now \" + toString(this.age) + \" years old!\");\n        } else {\n            print(this.name + \" is celebrating!\");\n        }\n    }\n\n    // Static method (belongs to the class, not instances)\n    static string species() {\n        return \"Homo sapiens\";\n    }\n}\n</code></pre>"},{"location":"classes/#fields","title":"Fields","text":"<p>Fields declare the data that each instance of a class will contain. Each field must have a type:</p> <pre><code>class Rectangle {\n    float width;\n    float height;\n    string color;\n}\n</code></pre> <p>Fields can be nullable or const:</p> <pre><code>class Configuration {\n    const string APP_NAME;       // Constant field\n    nullable string lastUser;    // Can be null\n}\n</code></pre>"},{"location":"classes/#constructors","title":"Constructors","text":"<p>Constructors are special methods that initialize a new instance of a class. They always take <code>this</code> as their first parameter, which refers to the instance being created:</p> <pre><code>class Point {\n    float x;\n    float y;\n\n    // Basic constructor\n    Point(this, float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // With default values (when implemented)\n    Point(this, float x = 0.0, float y = 0.0) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"classes/#instance-methods","title":"Instance Methods","text":"<p>Instance methods are functions that belong to an instance of a class. They always take <code>this</code> as their first parameter:</p> <pre><code>class Circle {\n    float radius;\n\n    Circle(this, float radius) {\n        this.radius = radius;\n    }\n\n    // Instance methods\n    float getArea(this) {\n        return 3.14159 * this.radius * this.radius;\n    }\n\n    float getCircumference(this) {\n        return 2.0 * 3.14159 * this.radius;\n    }\n\n    void scale(this, float factor) {\n        this.radius = this.radius * factor;\n    }\n}\n</code></pre>"},{"location":"classes/#static-methods","title":"Static Methods","text":"<p>Static methods belong to the class itself rather than any instance. They don't take a <code>this</code> parameter:</p> <pre><code>class MathUtils {\n    // Static methods\n    static int max(int a, int b) {\n        if (a &gt; b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    static float average(float a, float b) {\n        return (a + b) / 2.0;\n    }\n}\n</code></pre>"},{"location":"classes/#creating-and-using-objects","title":"Creating and Using Objects","text":"<p>Once a class is defined, you can create instances (objects) of that class:</p> <pre><code>// Creating objects\nPerson alice = Person(\"Alice\", 30, true);\nPerson bob = Person(\"Bob\", null);\n\n// Using instance methods\nstring aliceName = alice.getName();\nalice.celebrate();\n\n// Using static methods\nstring speciesName = Person.species();\n</code></pre>"},{"location":"classes/#inheritance","title":"Inheritance","text":"<p>Inheritance allows a class to inherit fields and methods from another class. firescript supports single inheritance using the <code>from</code> keyword:</p> <pre><code>class Student from Person {\n    string school;\n    string[] courses;\n\n    Student(this, string name, int age, string school) {\n        super.Student(name, age);  // Call parent constructor\n        this.school = school;\n        this.courses = [];\n    }\n\n    // Additional methods\n    void enroll(this, string course) {\n        this.courses.append(course);\n        print(this.name + \" enrolled in \" + course);\n    }\n\n    string[] getCourses(this) {\n        return this.courses;\n    }\n\n    // Override parent method\n    void celebrate(this) {\n        super.celebrate();  // Call parent method\n        print(\"Time for a student party!\");\n    }\n}\n</code></pre>"},{"location":"classes/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override methods from the parent class. To call the parent class's implementation, use <code>super</code>:</p> <pre><code>class Shape {\n    string color;\n\n    Shape(this, string color) {\n        this.color = color;\n    }\n\n    string describe(this) {\n        return \"A \" + this.color + \" shape\";\n    }\n}\n\nclass Square from Shape {\n    float side;\n\n    Square(this, float side, string color) {\n        super.Shape(color);\n        this.side = side;\n    }\n\n    // Override the parent's describe method\n    string describe(this) {\n        return super.describe() + \" (square with side \" + toString(this.side) + \")\";\n    }\n}\n</code></pre>"},{"location":"classes/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism allows objects of different classes in the same inheritance hierarchy to be treated as objects of a common superclass:</p> <pre><code>// Example of future planned polymorphism\nPerson[] people = [\n    Person(\"Alice\", 25),\n    Student(\"Bob\", 20, \"State University\")\n];\n\nint i = 0;\nwhile (i &lt; people.length) {\n    print(people[i].getName());\n    i = i + 1;\n}\n</code></pre>"},{"location":"classes/#planned-class-features-not-yet-implemented","title":"Planned Class Features (Not Yet Implemented)","text":"<p>The following features are planned for future versions of firescript:</p>"},{"location":"classes/#interfaces","title":"Interfaces","text":"<pre><code>// Future syntax\ninterface Drawable {\n    void draw(this)\n    bool isVisible(this)\n}\n\nclass Circle implements Drawable {\n    // Must implement all interface methods\n    void draw(this) {\n        // Drawing implementation\n    }\n\n    bool isVisible(this) {\n        return true;\n    }\n}\n</code></pre>"},{"location":"classes/#generics-on-classes","title":"Generics on Classes","text":"<pre><code>// Future syntax\nclass Box&lt;T&gt; {\n    nullable T value;\n\n    Box(this) {\n        this.value = null;\n    }\n\n    void set(this, T newValue) {\n        this.value = newValue;\n    }\n\n    nullable T get(this) {\n        return this.value;\n    }\n}\n\n// Usage\nBox&lt;int&gt; intBox = Box&lt;int&gt;();\nintBox.set(42);\n</code></pre>"},{"location":"classes/#abstract-classes-and-methods","title":"Abstract Classes and Methods","text":"<pre><code>// Future syntax\nabstract class Animal {\n    string species;\n\n    Animal(this, string species) {\n        this.species = species;\n    }\n\n    // Abstract method - no implementation\n    abstract string makeSound(this);\n\n    // Regular method with implementation\n    string getSpecies(this) {\n        return this.species;\n    }\n}\n\nclass Cat from Animal {\n    // Must implement abstract methods\n    string makeSound(this) {\n        return \"Meow\";\n    }\n}\n</code></pre>"},{"location":"classes/#best-practices-for-class-design","title":"Best Practices for Class Design","text":"<ol> <li>Single Responsibility Principle: Each class should have only one reason to change.\\</li> <li>Favor Composition Over Inheritance: Use object composition rather than complex inheritance hierarchies.</li> <li>Keep Inheritance Hierarchies Shallow: Deep inheritance can lead to complexity.</li> <li>Use Descriptive Names: Class names should be nouns, method names should be verbs.</li> </ol>"},{"location":"classes/#implementation-status","title":"Implementation Status","text":"<p>Classes in firescript are planned but not yet implemented in the current compiler:</p> <ul> <li>\u274c Class definitions</li> <li>\u274c Instance fields and methods</li> <li>\u274c Constructors</li> <li>\u274c Static methods</li> <li>\u274c Inheritance</li> <li>\u274c Method overriding</li> <li>\u274c Polymorphism</li> <li>\u274c Interfaces</li> <li>\u274c Access modifiers</li> <li>\u274c Abstract classes</li> <li>\u274c Meta-attributes/annotations</li> <li>\u274c Generics on classes</li> </ul>"},{"location":"control_flow/","title":"Control Flow","text":"<p>Note: Only <code>if</code>/<code>else</code> chains and <code>while</code> loops are currently supported. C-style <code>for</code> loops, for-in loops, range loops, and the ternary operator are not supported by the compiler.</p>"},{"location":"control_flow/#introduction-to-control-flow","title":"Introduction to Control Flow","text":"<p>Control flow structures determine the order in which statements are executed in a program. They allow for conditional execution (if/else) and repeated execution (loops) of code blocks. In firescript, control flow constructs use curly braces <code>{}</code> to define code blocks.</p>"},{"location":"control_flow/#conditional-statements","title":"Conditional Statements","text":"<p>Conditional statements execute different blocks of code depending on whether a specified condition evaluates to <code>true</code> or <code>false</code>. firescript supports <code>if</code>, <code>else if</code>, and <code>else</code> statements.</p>"},{"location":"control_flow/#basic-if-statement","title":"Basic If Statement","text":"<p>The simplest form executes a block of code only if the condition is true:</p> <pre><code>if (condition) {\n    // Code executed only if condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>int age = 18;\nif (age &gt;= 18) {\n    print(\"You are eligible to vote\");\n}\n</code></pre>"},{"location":"control_flow/#if-else-statement","title":"If-Else Statement","text":"<p>You can specify an alternative block of code to execute when the condition is false:</p> <pre><code>if (condition) {\n    // Code executed if condition is true\n} else {\n    // Code executed if condition is false\n}\n</code></pre> <p>Example:</p> <pre><code>int score = 65;\nif (score &gt;= 70) {\n    print(\"Pass\");\n} else {\n    print(\"Fail\");\n}\n</code></pre>"},{"location":"control_flow/#if-else-if-else-chains","title":"If-Else If-Else Chains","text":"<p>For multiple conditions, you can use <code>else if</code>:</p> <pre><code>if (condition1) {\n    // Executed if condition1 is true\n} else if (condition2) {\n    // Executed if condition1 is false and condition2 is true\n} else if (condition3) {\n    // Executed if condition1 and condition2 are false and condition3 is true\n} else {\n    // Executed if all conditions are false\n}\n</code></pre> <p>Example:</p> <pre><code>int grade = 85;\n\nif (grade &gt;= 90) {\n    print(\"A\");\n} else if (grade &gt;= 80) {\n    print(\"B\");\n} else if (grade &gt;= 70) {\n    print(\"C\");\n} else if (grade &gt;= 60) {\n    print(\"D\");\n} else {\n    print(\"F\");\n}\n</code></pre>"},{"location":"control_flow/#nested-conditional-statements","title":"Nested Conditional Statements","text":"<p>Conditional statements can be nested within other conditional statements:</p> <pre><code>bool hasDiscount = true;\nint totalAmount = 120;\n\nif (totalAmount &gt; 100) {\n    if (hasDiscount) {\n        print(\"You qualify for a 15% discount\");\n    } else {\n        print(\"You qualify for a 10% discount\");\n    }\n} else {\n    print(\"No discount available\");\n}\n</code></pre>"},{"location":"control_flow/#boolean-expressions-in-conditions","title":"Boolean Expressions in Conditions","text":"<p>Conditions can use various boolean operators:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li> <li>Logical operators: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> </ul> <p>Example:</p> <pre><code>int age = 25;\nbool hasLicense = true;\n\nif (age &gt;= 18 &amp;&amp; hasLicense) {\n    print(\"You can drive\");\n}\n\nif (!(age &lt; 18 || !hasLicense)) {\n    print(\"Also, you can drive\"); // Equivalent to the above\n}\n</code></pre>"},{"location":"control_flow/#loops","title":"Loops","text":"<p>Loops allow for repeated execution of a block of code. firescript supports <code>while</code> loops and plans to support various forms of <code>for</code> loops in the future.</p>"},{"location":"control_flow/#while-loops","title":"While Loops","text":"<p>A <code>while</code> loop repeatedly executes a block of code as long as a specified condition is <code>true</code>:</p> <pre><code>while (condition) {\n    // Loop body: code executed repeatedly as long as condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>int count = 0;\nwhile (count &lt; 5) {\n    print(count);\n    count = count + 1;\n}\n// Outputs: 0, 1, 2, 3, 4\n</code></pre>"},{"location":"control_flow/#infinite-loops","title":"Infinite Loops","text":"<p>A <code>while</code> loop with a condition that is always <code>true</code> creates an infinite loop. These should be used with caution and should include a break statement:</p> <pre><code>while (true) {\n    // This will run forever unless broken\n    if (someCondition) {\n        break; // Exit the loop\n    }\n}\n</code></pre>"},{"location":"control_flow/#loop-control-statements","title":"Loop Control Statements","text":"<p>The following statements can control loop execution:</p> <ul> <li><code>break</code> - Immediately exits the loop</li> <li><code>continue</code> - Skips the rest of the current iteration and starts the next one</li> </ul> <p>Example:</p> <pre><code>int i = 0;\nwhile (i &lt; 10) {\n    i = i + 1;\n\n    if (i == 3) {\n        continue; // Skip the rest of this iteration\n    }\n\n    if (i == 8) {\n        break; // Exit the loop\n    }\n\n    print(i);\n}\n// Outputs: 1, 2, 4, 5, 6, 7\n</code></pre>"},{"location":"control_flow/#combining-loops-and-conditionals","title":"Combining Loops and Conditionals","text":"<p>Loops and conditional statements can be combined to create powerful control flows:</p> <pre><code>int[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nint sum = 0;\nint i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        sum = sum + numbers[i]; // Add only even numbers\n    }\n    i = i + 1;\n}\n\nprint(sum); // Outputs: 30 (2 + 4 + 6 + 8 + 10)\n</code></pre>"},{"location":"control_flow/#future-control-flow-features","title":"Future Control Flow Features","text":"<p>The following control flow features are planned but not yet implemented in the current compiler:</p>"},{"location":"control_flow/#c-style-for-loops","title":"C-style For Loops","text":"<pre><code>// Future syntax\nfor (int i = 0; i &lt; 5; i++) {\n    print(i);\n}\n</code></pre>"},{"location":"control_flow/#for-in-loops","title":"For-In Loops","text":"<pre><code>// Future syntax\nstring[] fruits = [\"apple\", \"banana\", \"cherry\"];\nfor (string fruit : fruits) {\n    print(fruit);\n}\n</code></pre>"},{"location":"control_flow/#range-loops","title":"Range Loops","text":"<pre><code>// Future syntax\nfor (int i : range(5)) {\n    print(i); // 0, 1, 2, 3, 4\n}\n\nfor (int i : range(2, 8)) {\n    print(i); // 2, 3, 4, 5, 6, 7\n}\n\nfor (int i : range(1, 10, 2)) {\n    print(i); // 1, 3, 5, 7, 9\n}\n</code></pre>"},{"location":"control_flow/#ternary-operator","title":"Ternary Operator","text":"<pre><code>// Future syntax\nint max = ternary a &gt; b then a else b;\n</code></pre>"},{"location":"control_flow/#switch-statements","title":"Switch Statements","text":"<pre><code>// Future syntax\nswitch (value) {\n    case 1:\n        // code for case 1\n        break;\n    case 2:\n        // code for case 2\n        break;\n    default:\n        // default code\n}\n</code></pre>"},{"location":"control_flow/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Keep conditions simple: Split complex conditions into multiple variables for better readability.</p> </li> <li> <p>Avoid deep nesting: Too many nested if/else statements make code hard to follow. Consider refactoring deeply nested code.</p> </li> <li> <p>Be careful with while loops: Always ensure that the condition will eventually become false to avoid infinite loops.</p> </li> <li> <p>Use appropriate loop types: Once implemented, choose the right loop for the task: <code>while</code> for unknown iteration counts, <code>for</code> for counting, and <code>for-in</code> for collections.</p> </li> </ol>"},{"location":"control_flow/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 <code>if</code>/<code>else</code>/<code>else if</code> conditional statements</li> <li>\u2705 <code>while</code> loops</li> <li>\u2705 <code>break</code> and <code>continue</code> statements</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c C-style <code>for</code> loops</li> <li>\u274c <code>for-in</code> loops</li> <li>\u274c Range-based loops</li> <li>\u274c Ternary operator</li> <li>\u274c <code>switch</code>/<code>case</code> statements</li> </ul>"},{"location":"functions/","title":"Functions &amp; Methods","text":"<p>Note: User-defined function definitions, methods on objects, optional or named parameters, variadic parameters, and function overloading are currently not supported by the compiler. Only built-in functions are available in the current implementation.</p>"},{"location":"functions/#built-in-functions","title":"Built-in Functions","text":"<p>firescript provides a set of built-in functions that are available for use without requiring any imports. These functions provide essential functionality for input/output, type conversion, and type introspection.</p>"},{"location":"functions/#inputoutput-functions","title":"Input/Output Functions","text":"<ul> <li><code>print(value)</code> \u2013 Outputs a value to the console</li> </ul> <pre><code>print(\"Hello, world!\");  // Prints: Hello, world!\nprint(42);               // Prints: 42\nprint(true);             // Prints: true\n</code></pre> <p>This function accepts values of any type and converts them to strings for display.</p> <ul> <li><code>input(prompt)</code> \u2013 Reads a string from the console</li> </ul> <pre><code>string name = input(\"Enter your name: \");\nprint(\"Hello, \" + name);\n</code></pre> <p>The <code>prompt</code> parameter is displayed to the user before waiting for input.</p>"},{"location":"functions/#type-conversion-functions","title":"Type Conversion Functions","text":"<p>These functions convert values from one type to another:</p> <ul> <li><code>toInt(value)</code> \u2013 Converts a value to an integer</li> </ul> <pre><code>string numberString = \"123\";\nint number = toInt(numberString);  // 123\n\nfloat floatVal = 45.7;\nint intVal = toInt(floatVal);      // 45 (truncated)\n\nfloat floatCount = toFloat(count);  // 5.0\nstring pi = \"3.14159\";\nfloat piValue = toFloat(pi);        // 3.14159\n</code></pre> <ul> <li><code>toDouble(value)</code> \u2013 Converts a value to a double (64-bit floating point)</li> </ul> <pre><code>int bigNumber = 1000000;\ndouble doubleBig = toDouble(bigNumber);  // 1000000.0 (with double precision)\n\nstring sciNotation = \"6.022e23\";\ndouble avogadro = toDouble(sciNotation);  // 6.022e23\n\n- **`toBool(value)`** \u2013 Converts a value to a boolean\n\n```firescript\nstring truthy = \"true\";\nbool flag = toBool(truthy);  // true\n\nstring falsy = \"false\";\nbool notFlag = toBool(falsy);  // false\n\n// Non-string inputs:\nbool nonZero = toBool(1);      // true\nbool zero = toBool(0);         // false\n</code></pre> <ul> <li><code>toString(value)</code> \u2013 Converts a value to a string</li> </ul> <pre><code>int number = 42;\nstring text = toString(number);  // \"42\"\n\nbool state = true;\nstring stateText = toString(state);  // \"true\"\n\nfloat decimal = 3.14;\nstring piText = toString(decimal);  // \"3.14\"\n</code></pre> <ul> <li><code>toChar(value)</code> \u2013 Converts a value to a character (represented as a string)</li> </ul> <pre><code>string word = \"Hello\";\nchar firstLetter = toChar(word);  // \"H\" (first character)\n\nint codePoint = 65;\nchar letter = toChar(codePoint);  // \"A\" (ASCII value 65)\n</code></pre>"},{"location":"functions/#type-introspection","title":"Type Introspection","text":"<ul> <li><code>typeof(value)</code> \u2013 Returns the type name of a value as a string</li> </ul> <pre><code>string typeOfNumber = typeof(42);         // \"int\"\nstring typeOfText = typeof(\"hello\");      // \"string\"\nstring typeOfArray = typeof([1, 2, 3]);   // \"int[]\"\n</code></pre> <p>This can be useful for debugging and for implementing type-dependent behavior.</p>"},{"location":"functions/#using-built-in-functions","title":"Using Built-in Functions","text":"<p>Functions are called by specifying the function name followed by parentheses containing the arguments:</p> <pre><code>// Converting user input to a number\nstring inputValue = input(\"Enter a number: \");\nint parsedValue = toInt(inputValue);\nprint(\"You entered: \" + toString(parsedValue));\n\n// Type checking\nint number = 42;\nstring typeInfo = typeof(number);\nprint(\"The type of \" + toString(number) + \" is \" + typeInfo);\n</code></pre>"},{"location":"functions/#chain-of-function-calls","title":"Chain of Function Calls","text":"<p>Built-in functions can be chained together:</p> <pre><code>// Get input, convert to int, double it, and print\nint result = toInt(input(\"Enter a number: \")) * 2;\nprint(\"Double of your number is: \" + toString(result));\n</code></pre>"},{"location":"functions/#user-defined-functions-planned-not-implemented","title":"User-defined Functions (Planned, Not Implemented)","text":"<p>The following syntax is planned for user-defined functions but is not yet implemented in the current compiler:</p> <pre><code>// Basic function definition\nreturnType functionName(paramType1 param1, paramType2 param2) {\n    // function body\n    return returnValue;\n}\n\n// Examples:\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(string name) {\n    print(\"Hello, \" + name);\n}\n\nfloat calculateAverage(int[] numbers) {\n    int sum = 0;\n    int i = 0;\n    while (i &lt; numbers.length) {\n        sum = sum + numbers[i];\n        i = i + 1;\n    }\n    return toFloat(sum) / toFloat(numbers.length);\n}\n</code></pre>"},{"location":"functions/#methods-planned-not-implemented","title":"Methods (Planned, Not Implemented)","text":"<p>Methods are functions that belong to objects. This feature is planned but not yet implemented:</p> <pre><code>class Person {\n    string name\n    int age\n\n    // Constructor method\n    Person(this, string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Instance method\n    string introduce(this) {\n        return \"My name is \" + this.name + \" and I'm \" + toString(this.age) + \" years old\";\n    }\n\n    // Static method\n    static string getSpecies() {\n        return \"Human\";\n    }\n}\n</code></pre>"},{"location":"functions/#best-practices-for-functions","title":"Best Practices for Functions","text":"<p>Although user-defined functions aren't implemented yet, here are best practices to follow when they become available:</p> <ol> <li> <p>Single responsibility: Each function should perform a single, well-defined task.</p> </li> <li> <p>Descriptive names: Use verb-based names that clearly describe what the function does.</p> </li> <li> <p>Input validation: Check function arguments for validity when appropriate.</p> </li> <li> <p>Error handling: Consider how your function will handle error conditions.</p> </li> <li> <p>Pure functions: When possible, write pure functions (functions without side-effects that return the same output for the same input).</p> </li> </ol>"},{"location":"functions/#future-function-features","title":"Future Function Features","text":"<p>The following function-related features are planned but not yet implemented:</p> <ul> <li>Optional parameters with default values:</li> </ul> <pre><code>// Future syntax\nvoid greet(string name, string greeting = \"Hello\") {\n    print(greeting + \", \" + name);\n}\n</code></pre> <ul> <li>Named arguments:</li> </ul> <pre><code>// Future syntax\ncalculateRectangle(width: 10, height: 20);\n</code></pre> <ul> <li>Variadic parameters (variable number of arguments):</li> </ul> <pre><code>// Future syntax\nint sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total = total + num;\n    }\n    return total;\n}\n</code></pre> <ul> <li>Function overloading:</li> </ul> <pre><code>// Future syntax\nint add(int a, int b) {\n    return a + b;\n}\n\nfloat add(float a, float b) {\n    return a + b;\n}\n</code></pre>"},{"location":"functions/#implementation-status","title":"Implementation Status","text":"<ul> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, type conversions, <code>typeof</code></li> <li>\u2705 Array methods: <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, <code>length</code></li> <li>\u274c User-defined function definitions</li> <li>\u274c Methods on objects</li> <li>\u274c Optional, named, or variadic parameters</li> <li>\u274c Function overloading</li> </ul>"},{"location":"language_specification/","title":"firescript Language Specification","text":"<p>This document serves as the formal reference for the firescript programming language's syntax and semantics.</p>"},{"location":"language_specification/#1-lexical-structure","title":"1. Lexical Structure","text":""},{"location":"language_specification/#character-set","title":"Character Set","text":"<p>firescript source files are Unicode text files. The lexical grammar is defined in terms of Unicode code points.</p>"},{"location":"language_specification/#comments","title":"Comments","text":"<pre><code>// Single line comment\n\n/* Multi-line\n   comment */\n</code></pre>"},{"location":"language_specification/#tokens","title":"Tokens","text":"<ul> <li>Keywords: <code>if</code>, <code>else</code>, <code>elif</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>nullable</code>, <code>generator</code>, <code>const</code>, <code>ternary</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>string</code>, <code>tuple</code></li> <li>Operators: Assignment (<code>=</code>), Arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code>), Comparison (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>), Logical (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>)</li> <li>Separators: <code>;</code>, <code>,</code>, <code>.</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code></li> <li>Literals: Integer, floating-point, double, boolean, string, null</li> </ul>"},{"location":"language_specification/#2-types","title":"2. Types","text":""},{"location":"language_specification/#primitive-types","title":"Primitive Types","text":"<ul> <li><code>int</code>: Integer numbers with arbitrary precision</li> <li><code>float</code>: Single-precision floating-point numbers</li> <li><code>double</code>: Double-precision floating-point numbers</li> <li><code>bool</code>: Boolean values (<code>true</code> or <code>false</code>)</li> <li><code>string</code>: Text strings</li> <li><code>char</code>: Single characters (currently handled similarly to strings)</li> </ul>"},{"location":"language_specification/#nullability","title":"Nullability","text":"<p>By default, variables cannot hold the value <code>null</code>. The <code>nullable</code> keyword must be used to explicitly allow variables to be assigned <code>null</code>.</p> <pre><code>nullable string name = null;  // Valid\nstring title = null;          // Invalid - cannot assign null to non-nullable type\n</code></pre>"},{"location":"language_specification/#arrays","title":"Arrays","text":"<p>Arrays are dynamically sized ordered collections of elements of the same type.</p> <pre><code>int[] numbers = [1, 2, 3];\nstring[] names = [\"Alice\", \"Bob\"];\n</code></pre>"},{"location":"language_specification/#3-variable-declarations-and-assignments","title":"3. Variable Declarations and Assignments","text":""},{"location":"language_specification/#declaration-syntax","title":"Declaration Syntax","text":"<pre><code>[nullability-modifier] [const-modifier] type identifier = expression;\n</code></pre>"},{"location":"language_specification/#examples","title":"Examples","text":"<pre><code>int count = 10;\nnullable string message = null;\nconst float PI = 3.14;\nbool isActive = true;\n</code></pre>"},{"location":"language_specification/#4-expressions","title":"4. Expressions","text":""},{"location":"language_specification/#primary-expressions","title":"Primary Expressions","text":"<ul> <li>Variables: <code>x</code></li> <li>Literals: <code>42</code>, <code>3.14</code>, <code>\"hello\"</code>, <code>true</code>, <code>null</code></li> <li>Parenthesized expressions: <code>(x + y)</code></li> <li>Function calls: <code>print(\"Hello\")</code></li> <li>Method calls: <code>array.append(5)</code></li> <li>Array access: <code>scores[0]</code></li> </ul>"},{"location":"language_specification/#operators-in-order-of-precedence","title":"Operators (in order of precedence)","text":"<ol> <li>Method/property access: <code>.</code></li> <li>Array access: <code>[]</code></li> <li>Function call: <code>()</code></li> <li>Unary: <code>+</code>, <code>-</code>, <code>!</code></li> <li>Power: <code>**</code></li> <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li> <li>Additive: <code>+</code>, <code>-</code></li> <li>Relational: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Equality: <code>==</code>, <code>!=</code></li> <li>Logical AND: <code>&amp;&amp;</code></li> <li>Logical OR: <code>||</code></li> <li>Assignment: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>**=</code></li> </ol>"},{"location":"language_specification/#5-control-flow","title":"5. Control Flow","text":""},{"location":"language_specification/#conditional-statements","title":"Conditional Statements","text":"<pre><code>if (condition) {\n    // then branch\n} else if (otherCondition) {\n    // else-if branch\n} else {\n    // else branch\n}\n</code></pre>"},{"location":"language_specification/#while-loop","title":"While Loop","text":"<pre><code>while (condition) {\n    // body\n}\n</code></pre>"},{"location":"language_specification/#6-functions","title":"6. Functions","text":""},{"location":"language_specification/#built-in-functions","title":"Built-in Functions","text":"<ul> <li><code>print(value)</code>: Output a value</li> <li><code>input(prompt)</code>: Read string from console</li> <li><code>toInt(x)</code>, <code>toFloat(x)</code>, <code>toDouble(x)</code>, <code>toBool(x)</code>, <code>toString(x)</code>, <code>toChar(x)</code>: Type conversions</li> <li><code>typeof(x)</code>: Returns type name</li> </ul>"},{"location":"language_specification/#user-defined-functions-syntax","title":"User-defined Functions (Syntax)","text":"<pre><code>returnType functionName(paramType1 param1, paramType2 param2) {\n    // function body\n    return expression;\n}\n</code></pre>"},{"location":"language_specification/#7-arrays","title":"7. Arrays","text":""},{"location":"language_specification/#operations","title":"Operations","text":"<ul> <li><code>append(element)</code>: Add to end</li> <li><code>insert(index, element)</code>: Insert at position</li> <li><code>pop(index?)</code>: Remove and return element; default removes last</li> <li><code>clear()</code>: Remove all elements</li> <li><code>length</code>: Property for size</li> </ul>"},{"location":"language_specification/#8-scoping-rules","title":"8. Scoping Rules","text":"<p>A new scope is created by any set of curly braces <code>{}</code>. Variables declared in an inner scope are not accessible in outer scopes. Variables declared in an outer scope are accessible in inner scopes. Variable shadowing is not allowed.</p>"},{"location":"language_specification/#9-syntax-flexibility","title":"9. Syntax Flexibility","text":""},{"location":"language_specification/#whitespace-handling","title":"Whitespace Handling","text":"<p>firescript is flexible with whitespace, which means that spaces, tabs, and line breaks are largely ignored by the compiler. While proper formatting with indentation and spacing is recommended for readability, the language allows code to be written in a more compact form.</p> <p>For example, the following well-formatted code:</p> <pre><code>int x = 1;\nx += 2;\nprint(x);\nint i = 0;\nwhile (i &lt; 10) {\n    x += i;\n    i++;\n    print(x);\n}\n</code></pre> <p>Could also be written as a single line with no spacing:</p> <pre><code>intx=1;x+=2;print(x);inti=0;while(i&lt;10){x+=i;i++;print(x);}\n</code></pre> <p>Although the compiler accepts both forms, it is strongly recommended to use clear formatting with appropriate whitespace for better code readability and maintainability.</p>"},{"location":"language_specification/#10-not-yet-implemented-features","title":"10. Not Yet Implemented Features","text":"<ul> <li>Array slicing and negative indices</li> <li>typeof() function</li> <li>User-defined function definitions</li> <li>Classes and inheritance</li> <li>For loops</li> <li>Ternary operator</li> </ul>"},{"location":"scoping/","title":"Scoping in firescript","text":"<p>In firescript, scopes define the visibility and lifetime of variables. Understanding how scopes work is crucial for writing correct and predictable code.</p>"},{"location":"scoping/#scope-creation","title":"Scope Creation","text":"<p>A new scope is created by any set of curly braces <code>{}</code>. This includes:</p> <ul> <li>Control Flow Statements: The bodies of <code>if</code>, <code>else if</code>, <code>else</code>, <code>for</code>, <code>while</code>, and other control flow statements each create their own scope.</li> <li>Function Bodies: The body of a function defines a scope.</li> <li>Class Bodies: The body of a class defines a scope.</li> <li>Bare Braces: You can create an explicit scope simply by using a pair of curly braces <code>{}</code> anywhere they are syntactically allowed.</li> </ul> <pre><code>// Global scope\n\nint globalVar = 10;\n\nif (globalVar &gt; 5) {\n    // Inner scope 1 (if body)\n    int innerVar1 = 20;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar1);  // Accessing current scope variable: OK (prints 20)\n}\n\n// print(innerVar1)  // ERROR: innerVar1 is not accessible here\n\n{\n    // Inner scope 2 (bare braces)\n    int innerVar2 = 30;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar2);  // Accessing current scope variable: OK (prints 30)\n\n    if (true) {\n        // Inner scope 3 (nested if body)\n        int innerVar3 = 40;\n        print(globalVar);  // OK (prints 10)\n        print(innerVar2);  // OK (prints 30)\n        print(innerVar3);  // OK (prints 40)\n    }\n    // print(innerVar3)  // ERROR: innerVar3 is not accessible here\n}\n\n// print(innerVar2)  // ERROR: innerVar2 is not accessible here\n</code></pre>"},{"location":"scoping/#scope-hierarchy-and-variable-access","title":"Scope Hierarchy and Variable Access","text":"<ul> <li>Outer Scope Access: An inner scope can access variables declared in any of its enclosing (outer) scopes, all the way up to the global scope.</li> <li>Inner Scope Isolation: An outer scope cannot access variables declared within any of its inner scopes. Once a scope block is exited, all variables declared directly within that scope are destroyed and become inaccessible.</li> <li>Variable Shadowing: Variable shadowing is not allowed. firescript will throw an error if you try to declare a variable with the same name in an inner scope that already exists in an outer scope. This is to prevent confusion and ensure that the intended variable is always accessed.</li> </ul>"},{"location":"scoping/#detailed-scoping-rules","title":"Detailed Scoping Rules","text":""},{"location":"scoping/#1-variable-declaration-and-initialization","title":"1. Variable Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement. They are only accessible within their scope:</p> <pre><code>{\n    int x = 5;  // x is declared and initialized\n\n    {\n        // New inner scope\n        print(x);  // Accessible, prints 5\n\n        // int x = 10;  // ERROR: Cannot redeclare 'x' - shadowing is not allowed\n        int y = 15;  // y is only accessible in this scope\n    }\n\n    // print(y)  // ERROR: y is not defined in this scope\n}\n// print(x)  // ERROR: x is not defined in this scope\n</code></pre>"},{"location":"scoping/#2-variable-lifetime","title":"2. Variable Lifetime","text":"<p>Variables exist only from the point of their declaration to the end of their containing scope:</p> <pre><code>{\n    // print(a)  // ERROR: Cannot use 'a' before declaration\n\n    int a = 1;\n    print(a);  // OK: 'a' exists here\n\n    {\n        int b = 2;\n        print(a);  // OK: 'a' from outer scope\n        print(b);  // OK: 'b' from current scope\n    }  // 'b' is destroyed here\n\n    // print(b)  // ERROR: 'b' no longer exists\n}  // 'a' is destroyed here\n</code></pre>"},{"location":"scoping/#3-global-scope","title":"3. Global Scope","text":"<p>Variables declared outside any braces are in the global scope and are accessible throughout the entire program:</p> <pre><code>int globalValue = 100;  // Global variable\n\n{\n    print(globalValue);  // Accessible anywhere in the program\n\n    {\n        print(globalValue);  // Still accessible\n    }\n}\n\n// User-defined functions would also have access to global variables\n// when this feature is implemented\n</code></pre>"},{"location":"scoping/#4-loop-scopes","title":"4. Loop Scopes","text":"<p>Each iteration of a loop has its own scope:</p> <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    // New scope for each loop iteration\n    int temp = i * 10;\n    print(temp);  // Prints 0, 10, 20\n    i = i + 1;\n}  // 'temp' is destroyed at the end of each iteration\n\n// print(temp)  // ERROR: 'temp' is not accessible here\n</code></pre>"},{"location":"scoping/#5-conditional-scopes","title":"5. Conditional Scopes","text":"<p>Each branch of a conditional statement creates its own scope. This pattern prevents runtime issues where a variable may or may not be defined depending on the execution path:</p> <pre><code>int value = 5;\n\nif (value &gt; 10) {\n    // Scope A\n    int result = value * 2;\n    print(result);\n} else if (value &gt; 0) {\n    // Scope B (different from Scope A)\n    int result = value + 10;  // OK to reuse the name 'result' here\n    print(result);  // Prints 15\n} else {\n    // Scope C (different from Scopes A and B)\n    int result = 0;\n    print(result);\n}\n\n// print(result)  // ERROR: 'result' is not accessible here\n</code></pre>"},{"location":"scoping/#6-nested-function-scopes-future-feature","title":"6. Nested Function Scopes (Future Feature)","text":"<p>When user-defined functions are implemented, they will create their own scopes:</p> <pre><code>// Global scope\nint globalVar = 10;\n\n// Future syntax when functions are implemented\nvoid exampleFunction() {\n    // Function scope\n    int functionVar = 20;\n    print(globalVar);  // OK: access to global scope\n\n    {\n        // Inner scope within the function\n        int innerVar = 30;\n        print(functionVar);  // OK: access to containing function scope\n        print(globalVar);    // OK: access to global scope\n    }\n\n    // print(innerVar)  // ERROR: not accessible outside its scope\n}\n\n// print(functionVar)  // ERROR: function variables only exist in function scope\n</code></pre>"},{"location":"scoping/#variable-scope-vs-object-lifetime","title":"Variable Scope vs. Object Lifetime","text":"<p>It's important to distinguish between a variable's scope (where it can be accessed) and an object's lifetime (how long it exists in memory):</p> <pre><code>// When object-oriented features are implemented:\n{\n    // myObj variable is scoped to this block\n    Person myObj = Person(\"John\", 30);\n\n    // myObj reference goes out of scope here\n    // The Person object may be garbage collected if no other references exist\n}\n</code></pre>"},{"location":"scoping/#best-practices-for-effective-scoping","title":"Best Practices for Effective Scoping","text":"<ol> <li> <p>Keep scopes as small as possible: Declare variables in the smallest scope where they are needed.</p> </li> <li> <p>Declare variables close to their first use: This improves code readability and maintainability.</p> </li> <li> <p>Use explicit scopes for temporary variables: Use bare braces <code>{}</code> to create explicit scopes for temporary variables.</p> </li> </ol> <p><code>firescript    {        // Temporary calculation scope        int temp = complexCalculation();        result = temp * 2;    }  // 'temp' is no longer accessible, reducing scope pollution</code></p> <ol> <li> <p>Be consistent with variable naming: Use clear, descriptive names to avoid confusion, especially with variables in different scopes.</p> </li> <li> <p>Avoid deeply nested scopes: Excessive nesting can make code harder to read and understand.</p> </li> </ol>"},{"location":"scoping/#implementation-details","title":"Implementation Details","text":"<p>firescript's scoping mechanism is implemented as a stack of symbol tables. When looking up a variable:</p> <ol> <li>The compiler first checks the innermost scope (top of the stack)</li> <li>If not found, it progressively checks outer scopes</li> <li>If the variable is not found in any scope, a compilation error occurs</li> </ol>"},{"location":"scoping/#common-scoping-errors","title":"Common Scoping Errors","text":""},{"location":"scoping/#1-accessing-variables-outside-their-scope","title":"1. Accessing Variables Outside Their Scope","text":"<pre><code>{\n    int value = 10;\n}\nprint(value)  // ERROR: 'value' is not defined in this scope\n</code></pre>"},{"location":"scoping/#2-redeclaring-variables-in-the-same-scope","title":"2. Redeclaring Variables in the Same Scope","text":"<pre><code>int count = 5;\nint count = 10;  // ERROR: 'count' is already defined\n</code></pre>"},{"location":"scoping/#3-attempting-variable-shadowing","title":"3. Attempting Variable Shadowing","text":"<pre><code>int value = 10;\nif (true) {\n    int value = 20;  // ERROR: Shadowing is not allowed in firescript\n}\n</code></pre>"},{"location":"scoping/#4-using-variables-before-declaration","title":"4. Using Variables Before Declaration","text":"<pre><code>print(result);  // ERROR: Cannot use 'result' before declaration\nint result = 42;\n</code></pre>"},{"location":"scoping/#implementation-status","title":"Implementation Status","text":"<p>Scope handling in firescript is fully implemented:</p> <ul> <li>\u2705 Block scopes with curly braces</li> <li>\u2705 Variable visibility rules</li> <li>\u2705 Prohibition of variable shadowing</li> <li>\u2705 Scope nesting and hierarchy</li> <li>\u2705 Variable lifetime management</li> </ul>"},{"location":"type_system/","title":"Type System in firescript","text":"<p>firescript employs a static type system to enhance code reliability and catch errors early during the compilation phase. This means that the type of every variable and expression is checked before the code is run.</p>"},{"location":"type_system/#built-in-types","title":"Built-in Types","text":"<p>firescript provides several fundamental data types:</p> <ul> <li><code>int</code>: Represents whole numbers (integers). Example: <code>int age = 30;</code></li> <li><code>float</code>: Represents single-precision floating-point numbers. Example: <code>float price = 19.95;</code></li> <li><code>double</code>: Represents double-precision floating-point numbers, offering higher precision than <code>float</code>. Example: <code>double pi = 3.1415926535;</code></li> <li><code>bool</code>: Represents boolean values, either <code>true</code> or <code>false</code>. Example: <code>bool isActive = true;</code></li> <li><code>string</code>: Represents sequences of characters. Example: <code>string message = \"Hello, World!\";</code></li> <li><code>char</code>: Represents a single character. (Note: Currently handled similarly to strings in some contexts, formal <code>char</code> type might be refined). Example: <code>char initial = \"A\";</code></li> <li><code>void</code>: Represents the absence of a type, primarily used as the return type for functions that do not return a value.</li> </ul>"},{"location":"type_system/#type-semantics","title":"Type Semantics","text":""},{"location":"type_system/#integer-type-int","title":"Integer Type (<code>int</code>)","text":"<p>The <code>int</code> type in firescript represents integers with arbitrary precision. There is no explicit size limit as in languages like C/C++, making it similar to Python integers that can grow as needed.</p> <pre><code>int small = 42;\nint large = 9223372036854775807;  // Large integers are supported\nint calculation = (small + large) * 2;  // Arithmetic operations\n</code></pre> <p>Integers support the following operations:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo), <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Bit manipulation (planned but not yet implemented): <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li> </ul>"},{"location":"type_system/#floating-point-types-float-and-double","title":"Floating Point Types (<code>float</code> and <code>double</code>)","text":"<p>The <code>float</code> type represents 32-bit floating-point numbers, while <code>double</code> represents 64-bit floating-point numbers with greater precision.</p> <pre><code>float simpleDecimal = 3.14;\ndouble highPrecision = 3.141592653589793;\n\n// Scientific notation\ndouble avogadro = 6.022e23;\nfloat tiny = 1.6e-19;\n</code></pre> <p>Floating point numbers support:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> </ul>"},{"location":"type_system/#boolean-type-bool","title":"Boolean Type (<code>bool</code>)","text":"<p>The <code>bool</code> type has only two possible values: <code>true</code> and <code>false</code>. It's commonly used in conditional expressions.</p> <pre><code>bool userLoggedIn = true;\nbool hasPermission = false;\n\n// Boolean operations\nbool canAccess = userLoggedIn &amp;&amp; hasPermission;  // Logical AND\nbool needsAttention = !userLoggedIn || !hasPermission;  // Logical OR and NOT\n</code></pre> <p>Boolean values support:</p> <ul> <li>Logical operations: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"type_system/#string-type-string","title":"String Type (<code>string</code>)","text":"<p>The <code>string</code> type represents sequences of characters. Strings in firescript are immutable (cannot be changed after creation).</p> <pre><code>string greeting = \"Hello\";\nstring name = \"World\";\nstring message = greeting + \", \" + name + \"!\";  // String concatenation with +\n\n// Multi-line strings\nstring paragraph = \"This is a\nmulti-line\nstring\";\n</code></pre> <p>Strings support:</p> <ul> <li>Concatenation: <code>+</code></li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"type_system/#character-type-char","title":"Character Type (<code>char</code>)","text":"<p>The <code>char</code> type represents a single character and is currently implemented as a string with length 1.</p> <pre><code>char letter = \"A\";\nchar digit = \"7\";\nchar newline = \"\\n\";  // Special character\n</code></pre>"},{"location":"type_system/#arrays","title":"Arrays","text":"<p>Arrays are ordered collections of elements of the same type.</p>"},{"location":"type_system/#declaration-and-initialization","title":"Declaration and Initialization","text":"<pre><code>// With initial values\nint[] numbers = [1, 2, 3, 4, 5];\nstring[] fruits = [\"apple\", \"banana\", \"cherry\"];\n\n// Empty array\nbool[] flags = [];\n</code></pre>"},{"location":"type_system/#array-operations","title":"Array Operations","text":"<pre><code>int[] scores = [85, 92, 78];\n\n// Accessing elements (zero-based indexing)\nint firstScore = scores[0];  // 85\n\n// Modifying elements\nscores[1] = 95;  // Array becomes [85, 95, 78]\n\n// Array methods\nscores.append(88);  // Add to end: [85, 95, 78, 88]\nscores.insert(2, 82);  // Insert at index: [85, 95, 82, 78, 88]\nint removed = scores.pop();  // Remove last: removed = 88, array = [85, 95, 82, 78]\nremoved = scores.pop(1);  // Remove at index: removed = 95, array = [85, 82, 78]\n\n// Array properties\nint count = scores.length;  // 3\n\n// Clearing arrays\nscores.clear();  // Array becomes []\n</code></pre>"},{"location":"type_system/#nullability","title":"Nullability","text":"<p>By default, variables cannot hold the value <code>null</code>. To allow a variable to be assigned <code>null</code>, you must explicitly declare it as <code>nullable</code>.</p>"},{"location":"type_system/#declaring-nullable-variables","title":"Declaring Nullable Variables","text":"<pre><code>nullable string username = null;  // Allowed\nstring title = \"Default\";\n\n// title = null;  // Error: Cannot assign null to non-nullable type 'string'\n\nusername = \"John\";  // Can be assigned a non-null value later\n</code></pre>"},{"location":"type_system/#working-with-nullable-values","title":"Working with Nullable Values","text":"<p>When working with nullable variables, it's important to check for null before using them:</p> <pre><code>nullable string data = null;\n\n// Safe pattern\nif (data != null) {\n    print(data);\n}\n\n// Could cause a runtime error if not checked\nprint(data);  // Might try to print null\n</code></pre>"},{"location":"type_system/#type-compatibility-and-conversions","title":"Type Compatibility and Conversions","text":"<p>firescript has strict typing rules but provides explicit conversion functions for common type conversions.</p>"},{"location":"type_system/#built-in-type-conversion-functions","title":"Built-in Type Conversion Functions","text":"<pre><code>// String to numeric conversions\nstring numStr = \"42\";\nint num = toInt(numStr);           // 42\nfloat floatVal = toFloat(\"3.14\");  // 3.14\ndouble doubleVal = toDouble(\"2.71828\");  // 2.71828\n\n// Numeric to string conversions\nstring strFromInt = toString(42);      // \"42\"\nstring strFromFloat = toString(3.14);  // \"3.14\"\n\n// Boolean conversions\nbool boolValue = toBool(\"true\");  // true\nstring strFromBool = toString(false);  // \"false\"\n\n// Character conversion\nchar first = toChar(\"Hello\");  // \"H\" - first character of string\n</code></pre>"},{"location":"type_system/#implicit-type-conversions","title":"Implicit Type Conversions","text":"<p>firescript generally does not perform implicit type conversions, with some exceptions:</p> <ol> <li>In binary numeric operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) between different numeric types:</li> <li>If one operand is <code>double</code>, the result is <code>double</code></li> <li>If one operand is <code>float</code> and the other is <code>int</code>, the result is <code>float</code></li> </ol> <pre><code>int intVal = 5;\nfloat floatVal = 2.5;\ndouble doubleVal = 3.14;\n\nfloat result1 = intVal + floatVal;    // Result is float 7.5\ndouble result2 = floatVal * doubleVal;  // Result is double 7.85\n</code></pre> <ol> <li>String concatenation with <code>+</code> will convert non-string values to strings:</li> </ol> <pre><code>string message = \"Count: \" + 42;  // \"Count: 42\"\nstring status = \"Active: \" + true;  // \"Active: true\"\n</code></pre>"},{"location":"type_system/#type-checking-and-enforcement","title":"Type Checking and Enforcement","text":"<p>The firescript parser includes a type-checking phase that runs after the initial syntax parsing.</p>"},{"location":"type_system/#static-type-checking","title":"Static Type Checking","text":"<ol> <li> <p>Variable Declarations: When you declare a variable (<code>int x = 5;</code>), the type checker verifies that the type of the initializer (<code>5</code>, which is <code>int</code>) matches the declared type (<code>int</code>).</p> </li> <li> <p>Assignments: When assigning a value to an existing variable (<code>x = 10;</code>), the checker ensures the assigned value's type is compatible with the variable's declared type.</p> </li> <li> <p>Expressions: Operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&gt;</code>, etc.) are checked to ensure they are used with compatible operand types. For example, arithmetic operators generally require numeric types (<code>int</code>, <code>float</code>, <code>double</code>), while <code>+</code> can also be used for string concatenation. The result type of an expression is also determined (e.g., <code>1 + 2.0</code> results in a <code>float</code>).</p> </li> <li> <p>Function Calls: Arguments passed to functions are checked against the expected parameter types. The return value type is also enforced.</p> </li> <li> <p>Method Calls: Similar to functions, arguments and the object the method is called on are type-checked.</p> </li> <li> <p>Array Operations: Indexing requires an integer, and assigning elements requires matching the array's element type.</p> </li> </ol>"},{"location":"type_system/#type-errors","title":"Type Errors","text":"<p>Type errors found during the checking phase will prevent the code from compiling further, providing early feedback on potential issues:</p> <pre><code>string name = \"John\";\nint age = 30;\n\nage = \"thirty\";  // Type error: Cannot assign string to int\nname = 25;       // Type error: Cannot assign int to string\nbool result = age + name;  // Type error: Cannot add int and string\n                           // Also cannot assign result to bool\n</code></pre>"},{"location":"type_system/#type-introspection","title":"Type Introspection","text":"<p>The <code>typeof</code> built-in function returns a string representing the type of a value:</p> <pre><code>// Future syntax\nstring type1 = typeof(42);        // \"int\"\nstring type2 = typeof(3.14);      // \"float\"\nstring type3 = typeof(\"hello\");   // \"string\"\nstring type4 = typeof(true);      // \"bool\"\nstring type5 = typeof([1, 2, 3]); // \"int[]\"\n</code></pre>"},{"location":"type_system/#advanced-type-features-planned","title":"Advanced Type Features (Planned)","text":"<p>The following advanced type features are planned but not yet implemented:</p>"},{"location":"type_system/#tuples","title":"Tuples","text":"<p>Tuples will allow grouping of values with different types. They will be immutable and can be accessed by index:</p> <pre><code>// Future syntax\ntuple&lt;int, string&gt; person = (30, \"John\");\nint age = person[0];  // 30\nstring name = person[1];  // \"John\"\n</code></pre>"},{"location":"type_system/#generics","title":"Generics","text":"<p>Generic types will allow for more flexible and reusable code:</p> <pre><code>// Future syntax\nT max&lt;T&gt;(T a, T b) {\n    if (a &gt; b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint largerInt = max&lt;int&gt;(5, 10);  // 10\nstring largerString = max&lt;string&gt;(\"apple\", \"banana\");  // \"banana\"\n</code></pre>"},{"location":"type_system/#user-defined-types-classes","title":"User-Defined Types (Classes)","text":"<p>Classes will enable user-defined types with methods and properties:</p> <pre><code>// Future syntax\nclass Point {\n    float x;\n    float y;\n\n    Point(this, float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    float distanceTo(this, Point other) {\n        float dx = this.x - other.x;\n        float dy = this.y - other.y;\n        return toFloat((dx * dx + dy * dy) ** 0.5);\n    }\n}\n</code></pre>"},{"location":"type_system/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 All primitive types: <code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>string</code>, <code>char</code></li> <li>\u2705 Nullable type modifiers</li> <li>\u2705 Arrays of primitive types</li> <li>\u2705 Static type checking for expressions and assignments</li> <li>\u2705 Type conversion functions</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c Type introspection with <code>typeof</code></li> <li>\u274c Tuples</li> <li>\u274c Generics</li> <li>\u274c User-defined types (classes)</li> <li>\u274c Interface types</li> <li>\u274c Function types</li> </ul>"},{"location":"variables/","title":"Types &amp; Variables","text":"<p>Note: Tuple types, the generic placeholder <code>T</code>, and declarations without an initializer are not supported by the compiler. Only built-in primitive types (<code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>string</code>, <code>char</code>) are fully implemented.</p>"},{"location":"variables/#primitive-types","title":"Primitive Types","text":"<p>firescript supports several built-in primitive types. For detailed information about the type system, see the Type System documentation.</p>"},{"location":"variables/#numeric-types","title":"Numeric Types","text":"<ul> <li><code>int</code>: Integer numbers with arbitrary precision</li> </ul> <pre><code>int count = 42;\nint largeNumber = 9223372036854775807;  // 64-bit integer\n</code></pre> <ul> <li><code>float</code>: Single-precision floating-point numbers (32-bit)</li> </ul> <pre><code>float price = 19.99;\nfloat smallValue = 0.000001;\n</code></pre> <ul> <li><code>double</code>: Double-precision floating-point numbers (64-bit)</li> </ul> <pre><code>double pi = 3.14159265359;\ndouble scientificNotation = 6.022e23;  // Scientific notation\n</code></pre>"},{"location":"variables/#boolean-type","title":"Boolean Type","text":"<ul> <li><code>bool</code>: Boolean values (<code>true</code> or <code>false</code>)</li> </ul> <pre><code>bool isActive = true;\nbool hasPermission = false;\n</code></pre>"},{"location":"variables/#text-types","title":"Text Types","text":"<ul> <li><code>string</code>: Text strings, enclosed in double quotes</li> </ul> <pre><code>string greeting = \"Hello, world!\";\nstring emptyString = \"\";\nstring multiline = \"This is a\nmulti-line string\";\n</code></pre> <ul> <li><code>char</code>: Single characters, represented as strings internally</li> </ul> <pre><code>char letter = \"A\";\nchar symbol = \"*\";\n</code></pre>"},{"location":"variables/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement:</p> <pre><code>int age = 30;\nstring name = \"Alice\";\nbool isRegistered = false;\n</code></pre>"},{"location":"variables/#type-inference","title":"Type Inference","text":"<p>firescript does not support automatic type inference:</p> <pre><code>var score = 95;  // Not supported - must specify the type explicitly\nint score = 95;  // Supported\n</code></pre>"},{"location":"variables/#constants","title":"Constants","text":"<p>Use the <code>const</code> keyword to declare immutable variables:</p> <pre><code>const int MAX_USERS = 100;\nconst string APP_VERSION = \"1.0.0\";\n</code></pre> <p>Constants must be initialized when declared and cannot be reassigned later:</p> <pre><code>const float PI = 3.14;\nPI = 3.14159;  // Error: cannot reassign a constant\n</code></pre>"},{"location":"variables/#nullability","title":"Nullability","text":"<p>By default, variables cannot be assigned <code>null</code>. The <code>nullable</code> keyword explicitly allows a variable to hold <code>null</code>:</p> <pre><code>nullable string username = null;  // Valid\nstring password = null;           // Invalid - non-nullable type cannot hold null\n</code></pre> <p>Attempting to use a nullable variable without checking for null may result in runtime errors:</p> <pre><code>nullable string message = null;\n\n// Safe access pattern\nif (message != null) {\n    print(message);\n}\n</code></pre>"},{"location":"variables/#implementation-status","title":"Implementation Status","text":"<p>All primitive types are fully supported in the current compiler. The following features are not yet implemented:</p> <ul> <li>Tuple operations (creation, access, manipulation)</li> <li>Generic type placeholders and type parameters</li> <li>Type inference</li> <li>Declaration without initialization</li> </ul> <p>For more detailed information about the type system, including type conversions, type compatibility, and advanced type features, please refer to the Type System documentation.</p>"}]}