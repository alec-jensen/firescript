{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"firescript v0.3.0 Documentation","text":"<p>This documentation is being used for the most part as a reference for planning the direction of the firescript language and its features. The compiler is still in early development, so many features are not yet implemented, or are implemented differently than described here. Nothing here should be considered final until the language reaches a stable 1.0.0 release.</p> <p>This documentation is organized to help both newcomers and experienced developers understand and use the firescript language effectively.</p>"},{"location":"#1-language-reference-manual","title":"1. Language Reference Manual","text":"<ul> <li>Type System - Formal definition of types, nullability, arrays</li> <li>Scoping Rules - Variable visibility, lifetime, and scope creation</li> <li>Control Flow - Conditional statements and loops</li> </ul>"},{"location":"#2-getting-started-tutorials","title":"2. Getting Started &amp; Tutorials","text":"<ul> <li>Types &amp; Variables - Basic variable declarations and types</li> <li>Arrays - Working with array data structures</li> <li>Functions &amp; Methods - Built-in functions and user-defined functions</li> </ul>"},{"location":"#3-language-features","title":"3. Language Features","text":"<ul> <li>Classes &amp; Inheritance - Object-oriented programming fundamentals</li> </ul>"},{"location":"#4-standard-library-reference","title":"4. Standard Library Reference","text":"<p>Standard library does not yet exist.</p>"},{"location":"#5-examples","title":"5. Examples","text":"<p>Check the <code>/examples</code> directory for complete code samples:</p> <ul> <li>Basic usage of built-in functions</li> <li>Fibonacci sequence implementation</li> <li>Array manipulation</li> <li>Scope and variable visibility demonstrations</li> </ul>"},{"location":"#6-changelog","title":"6. Changelog","text":"<p>For the latest updates and changes to the firescript language, see the changelog.</p>"},{"location":"#implementation-status","title":"Implementation Status","text":"<p>firescript is under active development. Key limitations in the current compiler version:</p> <ul> <li>\u274c Some copyable types (<code>bool</code>, <code>string</code>, <code>char</code>) are supported. <code>intN</code> and <code>floatN</code> types are planned.</li> <li>\u2705 Static type checking for expressions and assignments.</li> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, and type conversions.</li> <li>\u274c User-defined functions are not yet implemented.</li> <li>\u274c Classes and inheritance are planned but not implemented.</li> <li>\u274c Advanced array features like slicing and negative indices are not supported.</li> <li>\u274c Control flow is limited to <code>if</code>/<code>else</code> and <code>while</code> loops; <code>for</code> loops and <code>switch</code> statements are not implemented.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>firescript follows Semantic Versioning. This makes it easier to understand the impact of changes in each release.</p>"},{"location":"changelog/#currently-in-development","title":"Currently in Development","text":"<p>These are unversioned changes living on the main branch. They will be included in the next release.</p> <p>This is a MAJOR rewrite and WILL be buggy and will not work correctly.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed legacy numeric aliases: <code>int</code>, <code>float</code>, and <code>double</code>.<ul> <li>Use explicit-width types instead: <code>int8|16|32|64</code>, <code>uint8|16|32|64</code>, and <code>float32|64|128</code>.</li> <li>Integer literals default to <code>int32</code> when unsuffixed.</li> <li>No implicit numeric promotions. Arithmetic and comparisons require operands of the exact same type.</li> <li>Modulo (<code>%</code>) is defined only for integer types.</li> </ul> </li> <li>Beginning memory management implementation</li> </ul>"},{"location":"changelog/#new-language-features","title":"New Language Features","text":"<ul> <li>Fixed-width numeric types across the board:<ul> <li>Integers: <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>.</li> <li>Floats: <code>float32</code>, <code>float64</code>, <code>float128</code>.</li> </ul> </li> <li>Literal suffixes for precise typing:<ul> <li>Integers: <code>i8/i16/i32/i64</code> and <code>u8/u16/u32/u64</code> (e.g., <code>42i8</code>, <code>7u32</code>).</li> <li>Floats: <code>f32</code>, <code>f64</code>, <code>f128</code> (e.g., <code>3.14f32</code>, <code>2.0f64</code>, <code>1.0f128</code>).</li> </ul> </li> <li>String concatenation remains supported via <code>+</code> between two strings.</li> <li>Initial support for classes</li> </ul>"},{"location":"changelog/#030-sep-12-2025","title":"0.3.0 (Sep 12 2025)","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li><code>int</code> type is a native int again.<ul> <li>The <code>int</code> type is now a native <code>int64_t</code> type in the generated C code.</li> <li>This change improves performance and reduces complexity in the generated code.</li> <li>Arbitrary precision integer / decimal support has been removed from the core. Future optional library packages may re\u2011introduce them without impacting the core compiler.</li> </ul> </li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Function Definitions and Calls:<ul> <li>Added support for defining functions.</li> <li>Functions can be called by their name followed by parentheses.</li> <li>Functions can accept parameters and return values.</li> <li>Example:</li> </ul> </li> </ul> <pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Improved Variable Declaration Parsing:<ul> <li>Enhanced the parser to better handle nullable and const variable declarations.</li> </ul> </li> <li>Improved Error Handling:<ul> <li>Enhanced error messages for syntax and type errors.</li> <li>More context provided in error messages to help identify issues.</li> </ul> </li> <li>Refactored if-else parsing:<ul> <li>Improved the parsing logic for <code>if</code>, <code>else if</code>, and <code>else</code> statements.</li> <li>Better support for nested conditional statements.</li> </ul> </li> <li>Enhanced print function:<ul> <li>The <code>print</code> function correctly prints all primitive types.</li> </ul> </li> </ul>"},{"location":"changelog/#020-may-8-2025","title":"0.2.0 (May 8 2025)","text":""},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li> <p>Improved Syntax Handling and Error Reporting:</p> <ul> <li>Refactored the lexer and parser for enhanced syntax handling</li> <li>The lexer now correctly handles greater than (<code>&gt;</code>) and less than (<code>&lt;</code>) operators</li> <li>The parser includes stricter checks for Abstract Syntax Tree (AST) node children to prevent unexpected errors from <code>None</code> values</li> <li>Introduced new logic for parsing <code>if</code> and <code>while</code> statements to properly support nested structures</li> <li>Improved error messages with more context for syntax errors</li> </ul> </li> <li> <p>Memory Model Progress:</p> <ul> <li>Introduced an interim reference-counting mechanism for certain heap values (e.g., strings, arrays)</li> <li>This is a stepping stone toward the planned ownership + deterministic drop model (see Memory Management documentation)</li> <li>Improves leak resilience while compiler-based last-use drop insertion is under development</li> <li>Dynamic array resource reclamation aligned with deterministic drop goals</li> </ul> </li> <li> <p>Arbitrary Precision Integers:</p> <ul> <li>The <code>int</code> type is now represented using <code>mpz_t</code> in the generated code</li> <li>Enables arbitrary precision integers for handling large numbers</li> <li>Provides improved accuracy and reliability for complex calculations</li> <li>No practical limit to integer size (constrained only by available memory)</li> </ul> </li> <li> <p>Organized Build Outputs:</p> <ul> <li>Build outputs and temporary files are now stored in a dedicated <code>build</code> directory</li> <li>Temporary files are specifically located under <code>build/temp</code></li> <li>Cleaner project structure with separate directories for source, documentation, and build artifacts</li> </ul> </li> <li> <p>Expanded Array Operations:</p> <ul> <li>Added new array methods: <code>clear()</code> and improved <code>pop()</code> functionality</li> <li>Enhanced array bounds checking for safer indexing operations</li> <li>Optimized memory allocation for arrays to improve performance</li> </ul> </li> <li> <p>More Operators:</p> <ul> <li>Added support for compound assignment operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, and <code>%=</code></li> <li>Added support for increment (<code>++</code>) and decrement (<code>--</code>) operators</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed parser issue causing incorrect handling of complex nested expressions</li> <li>Addressed memory leak in string operations when concatenating multiple strings</li> <li>Corrected type checking for nullable values in conditional statements</li> <li>Fixed compilation errors in C code generation for complex boolean expressions</li> <li>Resolved issue with array element access in while loop conditions</li> </ul>"},{"location":"changelog/#code-quality-improvements","title":"Code Quality Improvements","text":"<ul> <li>Comprehensive refactoring of the C code generator for improved maintainability</li> <li>Added more detailed debug logging throughout the compilation process</li> <li>Improved documentation with examples for all supported language features</li> <li>Enhanced test coverage with new test cases for core functionality</li> </ul>"},{"location":"changelog/#011-january-2025","title":"0.1.1 (January 2025)","text":"<p>There is not a version 0.1.0 because of a versioning mishap during initial release.</p>"},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li> <p>Enhanced Variable Scoping:</p> <ul> <li>Strict enforcement of variable scoping rules</li> <li>Prevention of variable shadowing to avoid common programming errors</li> <li>Clear error messages for scope-related issues</li> </ul> </li> <li> <p>Improved Type System:</p> <ul> <li>Comprehensive type checking for variable assignments</li> <li>Type compatibility verification for expressions</li> <li>Function and method call parameter validation</li> <li>Support for nullable types with explicit declaration</li> </ul> </li> <li> <p>Control Flow Structures:</p> <ul> <li>Basic implementation of <code>if</code>, <code>else if</code>, and <code>else</code> statements</li> <li>Support for <code>while</code> loops with condition checking</li> <li><code>break</code> and <code>continue</code> statements in loops</li> </ul> </li> <li> <p>Basic Standard Library:</p> <ul> <li>Implementation of essential built-in functions:</li> <li><code>print()</code> for output</li> <li><code>input()</code> for user input</li> <li>Type conversion functions (<code>toInt()</code>, <code>toFloat()</code>, <code>toString()</code>, etc.)</li> <li><code>typeof()</code> function for runtime type introspection</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Resolved parsing issues for nested expressions</li> <li>Fixed incorrect operator precedence in complex expressions</li> <li>Addressed memory management issues in the runtime library</li> </ul>"},{"location":"changelog/#001-november-2024","title":"0.0.1 (November 2024)","text":""},{"location":"changelog/#initial-release","title":"Initial Release","text":"<ul> <li>First Public Alpha:</li> <li>Basic language structure and syntax</li> <li>Simple variable declarations with primitive types</li> <li>Arithmetic and logical operations</li> <li> <p>First iteration of the compilation pipeline</p> </li> <li> <p>Array Support:</p> </li> <li>Initial implementation of arrays with literal initialization</li> <li>Basic array operations: indexing, assignment</li> <li> <p>Simple array methods: <code>append()</code> and <code>insert()</code></p> </li> <li> <p>Compiler Infrastructure:</p> </li> <li>Lexer for tokenizing source code</li> <li>Parser for building the abstract syntax tree</li> <li>Simple C code generator for compilation</li> <li>Runtime library with basic functions</li> </ul>"},{"location":"firescript_philosophy/","title":"firescript Philosophy","text":"<p>firescript is intended to be a simple but powerful and fast language with safety by design. This is accomplished through a strict type system, explicit design, and simple to learn but powerful compile-time memory management. It is intended to be usable in a variety of domains, from systems programming to web development, as it compiles to a C backend or JavaScript + WebAssembly in the future.</p>"},{"location":"firescript_philosophy/#key-principles","title":"Key Principles","text":"<ul> <li>Simplicity: The language syntax and semantics are designed to be easy to learn and understand, minimizing complexity while maximizing expressiveness.</li> <li>Safety: Strong static typing, null safety, and compile-time checks help prevent common programming errors.</li> <li>Null safety is enforced by default; nullable types must be explicitly declared.</li> <li>Memory safety is ensured through compile-time ownership and borrowing rules, preventing issues like dangling pointers</li> <li>There is no undefined behavior; all operations are well-defined.</li> <li>Performance: Although the syntax is high-level, firescript is designed to compile to efficient low-level code, with no runtime overhead.</li> <li>Explicitness: The language favors explicit declarations and operations over implicit behavior, making code easier to read and reason about.</li> </ul>"},{"location":"glossary/","title":"Glossary","text":"<p>This glossary contains definitions of terms commonly used in the firescript documentation. For authoritative rules on ownership and lifetimes see Memory Management.</p>"},{"location":"glossary/#memory-management-terms","title":"Memory Management Terms","text":"Term Definition Copyable Fixed-size value with no destructor; copied bitwise. Owned Resource/heap-managing value with unique ownership semantics. Move Transfer of ownership; original binding becomes invalid. Borrow (<code>&amp;T</code>) Read-only, non-owning view whose lifetime is limited to an expression or call boundary. Clone Explicit duplication of an owned value\u2019s contents (deep or COW per type). Drop Deterministic destruction at an inserted point (last use or scope exit)."},{"location":"glossary/#expanded-definitions","title":"Expanded Definitions","text":"<ul> <li>Copyable: Includes <code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>, <code>string</code>, arrays, and other fixed-size scalars. Copies are bitwise; no destructor runs.</li> <li>Owned: Includes user-defined objects, closures, or any type that requires a destructor. Ownership is unique unless an explicit sharing container (future <code>Rc</code>, <code>Arc</code>) is used.</li> <li>Move: Occurs on assignment, passing to a parameter of owned type, or returning a value. After a move, the source binding cannot be used (use-after-move error).</li> <li>Borrow: Lightweight, read-only access. Cannot be stored in owned fields or escape its originating scope/call. Does not incur runtime overhead.</li> <li>Clone: Creates an independent owned value. Semantics (deep vs copy-on-write) determined by the type implementation but always preserves logical independence.</li> <li>Drop: Compiler-inserted destructor invocation (<code>drop(this)</code>) ensuring timely resource release (files, sockets, buffers) without tracing GC.</li> </ul>"},{"location":"internal/","title":"Internal Documentation","text":"<p>This is documentation for internal language features intended for use in the compiler and standard library. These are not intended for use in user code, as these features require careful handling to be used safely and correctly.</p>"},{"location":"internal/directives/","title":"compiler directives","text":"<p>compiler directives are special instructions to the compiler that affect compilation behavior. They are not part of the runtime language and do not produce any code themselves.</p> <p>Directives are not intended to be used in source files except in specific scenarios (e.g., enabling syscalls in the standard library). They are primarily for internal use by the compiler and standard library.</p>"},{"location":"internal/directives/#directive-syntax","title":"Directive Syntax","text":"<pre><code>directive &lt;name&gt; [&lt;arg1&gt; [, &lt;arg2&gt; ...]];\n</code></pre> <ul> <li><code>directive</code> keyword starts the directive.</li> <li><code>&lt;name&gt;</code> is the name of the directive (e.g., <code>enable_syscalls</code>).</li> <li>Optional arguments can be provided, separated by commas.</li> </ul>"},{"location":"internal/directives/#examples","title":"Examples","text":"<ul> <li>Enable syscalls in a file:</li> </ul> <pre><code>directive enable_syscalls;\n</code></pre> <ul> <li>Enable compiler-inserted drops (preprocessor inserts drop() calls):</li> </ul> <p>Should ONLY be used internally by the preprocessor.</p> <pre><code>directive enable_drops;\n</code></pre>"},{"location":"internal/directives/#available-directives","title":"Available Directives","text":"<ul> <li><code>enable_syscalls</code>: Allows the use of syscalls in the file. This is required for files in the standard library that need syscall access.</li> <li><code>enable_drops</code>: Enables the preprocessor to insert deterministic drop() calls for Owned values (e.g., arrays) at scope boundaries and early exits.</li> </ul>"},{"location":"internal/syscalls/","title":"syscalls docs","text":"<p>Syscalls are only intended to be used in the standard library. When we need them in the standard library, you add this directive at the top of the file:</p> <pre><code>directive enable_syscalls;\n</code></pre>"},{"location":"internal/syscalls/#available-syscalls","title":"Available Syscalls","text":"<p>Enabling syscalls gives you access to the following functions:</p> Syscall Description syscall_open(path, mode) Opens a file at <code>path</code> with the given <code>mode</code> (\"r\", \"w\", \"a\", etc.). Returns a file descriptor or file object referencing the open file. syscall_read(fd, buf, n) Reads up to <code>n</code> bytes from file descriptor or file object <code>fd</code> into buffer <code>buf</code>. Returns number of bytes read or error code. syscall_write(fd, buf, n) Writes up to <code>n</code> bytes from buffer <code>buf</code> to file descriptor or file object <code>fd</code>. Returns number of bytes written or error code. syscall_close(fd) Closes file descriptor or file object <code>fd</code>. Returns 0 on success or error code. syscall_remove(path) Removes (deletes) the file at the given <code>path</code>. syscall_rename(old, new) Renames file <code>old</code> to <code>new</code>. syscall_stat(path, stat) Gets metadata for file at <code>path</code> into <code>stat</code> struct. syscall_exec(cmd, args) Executes shell command <code>cmd</code> with arguments <code>args</code>. syscall_getenv(name, buf) Gets the value of the environment variable <code>name</code> into <code>buf</code>. syscall_system(cmd) Executes shell command <code>cmd</code> via the system shell. syscall_exit(code) Exits the process with exit code <code>code</code>. syscall_time() Returns the current system time (seconds since epoch). syscall_sleep(ms) Sleeps for <code>ms</code> milliseconds."},{"location":"internal/syscalls/#how-file-and-descriptor-objects-work","title":"How File and Descriptor Objects Work","text":"<ul> <li>File handles/descriptors are returned by <code>syscall_open</code> and uniquely identify an open file.</li> <li>Parallel I/O: You can open multiple files at once. Each operation (<code>read</code>, <code>write</code>, <code>close</code>) targets a specific file via its descriptor/object, allowing independent and parallel operations on multiple files.</li> <li>Lifetime: The file descriptor/object remains valid until explicitly closed via <code>syscall_close</code>. After closing, further operations on that handle are invalid.</li> <li>Threading/Concurrency: If the firescript runtime or standard library supports threading, syscalls are designed so that concurrent threads can operate on different file descriptors in parallel, with OS-level guarantees of isolation and safety.</li> <li>Error Handling: Functions typically return 0 or a positive value on success, and a negative error code on failure (e.g., invalid descriptor, permission denied).</li> </ul>"},{"location":"internal/syscalls/#example-usage","title":"Example Usage","text":"<pre><code>directive enable_syscalls;\n\n// Open two files for parallel access\nint fd1 = syscall_open(\"output1.txt\", \"w\");\nint fd2 = syscall_open(\"output2.txt\", \"w\");\n\nif fd1 &gt;= 0 and fd2 &gt;= 0 {\n    // Write to both files independently\n    syscall_write(fd1, \"foo\", 3);\n    syscall_write(fd2, \"bar\", 3);\n\n    syscall_close(fd1);\n    syscall_close(fd2);\n}\n</code></pre>"},{"location":"internal/syscalls/#notes","title":"Notes","text":"<ul> <li>Syscalls are low-level; errors are returned as negative numbers where applicable.</li> <li>Buffer types and argument conventions are subject to firescript's standard library conventions.</li> </ul>"},{"location":"reference/arrays/","title":"Arrays","text":"<p>Only arrays with literal initialization and methods <code>length</code> are supported by the compiler. Array slicing, negative indices, and other utility methods are not implemented.</p>"},{"location":"reference/arrays/#array-basics","title":"Array Basics","text":"<p>In firescript, arrays are fixed-size, ordered collections of elements that all share the same type. Arrays are declared using square brackets and the size after the type.</p>"},{"location":"reference/arrays/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Arrays are declared by appending <code>[N]</code> to any valid type and initializing with values in square brackets:</p> <pre><code>// Array initialization with values\nint8[5] numbers = [10, 20, 30, 40, 50];\nstring[3] names = [\"Alice\", \"Bob\", \"Charlie\"];\nbool[3] flags = [true, false, true];\n</code></pre> <p>All elements in an array must be of the same type as specified in the declaration.</p>"},{"location":"reference/arrays/#accessing-array-elements","title":"Accessing Array Elements","text":"<p>Individual array elements can be accessed using zero-based indexing:</p> <pre><code>int8[5] scores = [85, 92, 78, 90, 88];\n\n// Access individual elements\nint8 firstScore = scores[0];    // 85\nint8 thirdScore = scores[2];    // 78\n\n// Modifying elements\nscores[1] = 95;                // Array becomes [85, 95, 78, 90, 88]\n</code></pre> <p>\u26a0\ufe0f Warning: Accessing an index outside the array bounds will cause a runtime error. Always ensure your index is valid before access.</p>"},{"location":"reference/arrays/#array-operations","title":"Array Operations","text":"<p>firescript provides several built-in methods for manipulating arrays:</p> <ul> <li><code>length</code> \u2013 Property that returns the current size of the array</li> </ul> <pre><code>int8[5] data = [5, 10, 15, 20, 25];\nint8 size = data.length;      // size = 5\n</code></pre>"},{"location":"reference/arrays/#working-with-arrays","title":"Working with Arrays","text":""},{"location":"reference/arrays/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Use a <code>while</code> loop with an index variable to iterate over array elements:</p> <pre><code>string[5] cities = [\"New York\", \"London\", \"Tokyo\", \"Paris\", \"Sydney\"];\nuint8 i = 0;\nwhile (i &lt; cities.length) {\n    print(cities[i]);\n    i = i + 1;\n}\n</code></pre>"},{"location":"reference/arrays/#array-as-function-arguments","title":"Array as Function Arguments","text":"<p>Arrays can be passed to functions:</p> <pre><code>// Example of how it would work when user-defined functions are implemented\nint32 sum(int8[] numbers) {\n    int32 total = 0;\n    uint8 i = 0;\n    while (i &lt; numbers.length) {\n        total = total + numbers[i];\n        i = i + 1;\n    }\n    return total;\n}\n\n// Usage\nint8[5] values = [1, 2, 3, 4, 5];\nint32 result = sum(values);  // 15\n</code></pre>"},{"location":"reference/arrays/#nested-arrays","title":"Nested Arrays","text":"<p>Arrays can contain other arrays (though this is not fully implemented yet):</p> <pre><code>// 2D array example\nint8[3][3] matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\n// Accessing elements\nint8 element = matrix[1][2];  // 6\n</code></pre>"},{"location":"reference/arrays/#common-array-patterns","title":"Common Array Patterns","text":""},{"location":"reference/arrays/#finding-an-element","title":"Finding an Element","text":"<pre><code>int8[5] numbers = [10, 20, 30, 40, 50];\nint8 target = 30;\nint8 index = -1;\nuint8 i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] == target) {\n        index = i;\n        break;\n    }\n    i = i + 1;\n}\n\n// index = 2 if found, -1 if not found\n</code></pre>"},{"location":"reference/arrays/#features-not-yet-implemented","title":"Features Not Yet Implemented","text":"<p>The following array features are planned but not yet implemented in the current compiler:</p> <ul> <li>Array slicing (<code>arr[start:end:step]</code>) \u2013 Extract a portion of the array</li> </ul> <pre><code>// Future syntax\nint8[5] numbers = [10, 20, 30, 40, 50];\nint8[3] subset = numbers[1:4];  // Would be [20, 30, 40]\n</code></pre> <ul> <li>Negative indices \u2013 Access elements from the end of the array</li> </ul> <pre><code>// Future syntax\nstring[3] words = [\"apple\", \"banana\", \"cherry\"];\nstring last = words[-1];     // Would be \"cherry\"\n</code></pre> <ul> <li>Additional utility methods:</li> <li><code>index(value)</code> \u2013 Find the index of the first occurrence of a value</li> <li><code>count(value)</code> \u2013 Count occurrences of a value</li> <li> <p><code>sort()</code> \u2013 Sort the array elements</p> </li> <li> <p>Array arithmetic \u2013 Element-wise operations between arrays</p> </li> </ul> <p>Will use SIMD where possible for performance.</p> <pre><code>// Future syntax\nint8[3] a = [1, 2, 3];\nint8[3] b = [4, 5, 6];\n\n// add arrays element-wise\nint8[3] c = a + b;  // Would be [5, 7, 9]\n\n// subtract arrays element-wise\nint8[3] e = b - a;  // Would be [3, 3, 3]\n\n// add scalar to array\nint8[3] g = a + 2;  // Would be [3, 4, 5]\n\n// subtract scalar from array\nint8[3] h = b - 1;  // Would be [3, 4, 5]\n\n// multiply arrays element-wise\nint8[3] j = a * b;  // Would be [4, 10, 18]\n\n// divide arrays element-wise\nint8[3] k = b / a;  // Would be [4, 2, 2]\n\n// multiply arrays by scalar\nint8[3] d = a * 2;  // Would be [2, 4, 6]\n\n// divide arrays by scalar\nint8[3] f = b / 2;  // Would be [2, 2, 3]\n\n// dot product of two arrays\nint8 dotProduct = a . b;  // Would be 32 (1*4 + 2*5 + 3*6)\n</code></pre>"},{"location":"reference/arrays/#implementation-status","title":"Implementation Status","text":"<p>Arrays are functional but with limited operations in the current compiler:</p> <ul> <li>\u2705 Array declaration and initialization</li> <li>\u2705 Element access with positive indices</li> <li>\u2705 Length property</li> <li>\u274c Array slicing</li> <li>\u274c Negative indices</li> <li>\u274c Advanced utility methods</li> <li>\u274c Multi-dimensional array operations</li> </ul>"},{"location":"reference/classes/","title":"Classes &amp; Inheritance","text":"<p>Status: This page describes planned class semantics that integrate with the ownership-based memory model. See Memory Management and the Glossary for authoritative lifetime terminology.</p> <p>Note: Class definitions, inheritance, and methods are currently not supported by the compiler. This documentation describes the planned implementation.</p>"},{"location":"reference/classes/#object-oriented-programming-in-firescript","title":"Object-Oriented Programming in firescript","text":"<p>firescript's class system is designed to provide a clean, intuitive approach to object-oriented programming with features like single inheritance, constructors, and both instance and static methods.</p>"},{"location":"reference/classes/#ownership-lifetime-planned","title":"Ownership &amp; Lifetime (Planned)","text":"<p>Classes are Owned (Non-Trivially Copyable) types unless specified otherwise. Their instances participate in the deterministic ownership model:</p> <ul> <li>Construction produces a new owned instance. Binding the result to a variable creates that variable as the initial owner.</li> <li>Passing an instance to a function parameter of owned type moves it; the caller's binding becomes invalid after the call unless the value is returned.</li> <li>Future borrow syntax (<code>&amp;Person</code>) will allow read-only access to an instance without moving ownership.</li> <li>Fields that are owned types are dropped in reverse order of their construction when the containing object is dropped.</li> <li>A <code>drop(this)</code> method (planned) acts as a destructor. It runs exactly once at the inserted drop point.</li> <li>Cloning an instance will be explicit (<code>person.clone()</code>) if the type supports it (semantics: deep vs copy-on-write TBD per type design).</li> <li>Inheritance does not change ownership: moving a <code>Student</code> moves its base <code>Person</code> subobject as part of the same operation.</li> <li>Borrowed references cannot escape beyond the lifetime of the owning instance; the compiler enforces non-escaping borrows.</li> </ul> <p>Receiver convention (planned): Methods use a borrowed receiver <code>&amp;this</code> by default\u2014even when mutating fields\u2014because internal mutation does not require taking ownership of the entire object. A method takes an owning <code>this</code> only when it will consume the instance (e.g., irreversible state transition, transferring internal resources, or explicit <code>drop(this)</code> destructor). Examples below follow this convention.</p> <p>Borrowing applies only to Owned (Non-Trivially Copyable) types. Copyable types (<code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, etc.) are always passed and returned by value with implicit bitwise copy; using a borrow marker on copyable values is unnecessary and omitted below. When you see <code>&amp;Type</code> it implies the type is Owned.</p>"},{"location":"reference/classes/#example-deterministic-drop-ordering","title":"Example: Deterministic Drop Ordering","text":"<pre><code>class HandleBundle {\n    File log;\n    Socket conn;\n\n    HandleBundle(&amp;this, File &amp;log, Socket &amp;conn) {\n        this.log = log;     // constructed first\n        this.conn = conn;   // constructed second\n    }\n\n    drop(&amp;this) {            // planned destructor\n        // Custom cleanup (optional). Fields are then dropped automatically\n        // in reverse: conn then log.\n    }\n}\n\nHandleBundle hb = makeHandles(); // this would be invalid since you need to provide owned File and Socket\nprocess(&amp;hb);  // borrow\n// last use of hb here -&gt; compiler may drop immediately after\n</code></pre>"},{"location":"reference/classes/#takeaways","title":"Takeaways","text":"<ul> <li>Instances behave like other owned values: moves invalidate the source; borrows do not.</li> <li>Destruction is deterministic; order is reverse of field construction unless overridden by explicit semantics.</li> <li>No implicit deep copies: cloning is explicit.</li> <li>Inheritance does not introduce implicit sharing or reference counting.</li> </ul>"},{"location":"reference/classes/#defining-a-class","title":"Defining a Class","text":"<p>A class in firescript is defined using the <code>class</code> keyword, followed by the class name and a block containing fields and methods:</p> <pre><code>class Person {\n    // Fields (instance variables)\n    string name;\n    nullable int8 age;\n    bool isEmployed;\n\n    // Constructor: 'this' refers to the instance being created\n    Person(&amp;this, string &amp;name, nullable int8 age = null, bool isEmployed = false) {\n        this.name = name;\n        this.age = age;\n        this.isEmployed = isEmployed;\n    }\n\n    // Instance methods\n    // Non-mutating: borrow receiver\n    string getName(&amp;this) {\n        return &amp;this.name;\n    }\n\n    nullable int getAge(&amp;this) {\n        return &amp;this.age;\n    }\n\n    // Mutating via borrow (allowed; does not consume the instance)\n    void celebrate(&amp;this) {\n        if (this.age != null) {\n            this.age = this.age + 1;\n            print(this.name + \" is now \" + toString(this.age) + \" years old!\");\n        } else {\n            print(this.name + \" is celebrating!\");\n        }\n    }\n\n    // Static method (belongs to the class, not instances)\n    static string species() {\n        return \"Homo sapiens\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#fields","title":"Fields","text":"<p>Fields declare the data that each instance of a class will contain. Each field must have a type:</p> <pre><code>class Rectangle {\n    float32 width;\n    float32 height;\n    string color;\n}\n</code></pre> <p>Fields can be nullable or const:</p> <pre><code>class Configuration {\n    const string APP_NAME;       // Constant field\n    nullable string lastUser;    // Can be null\n}\n</code></pre>"},{"location":"reference/classes/#constructors","title":"Constructors","text":"<p>Constructors are special methods that initialize a new instance of a class. They always take <code>this</code> as their first parameter, which refers to the instance being created. For most cases, <code>this</code> will be a borrowed parameter, unless you are transferring ownership of the instance.</p> <pre><code>class Point {\n    float32 x;\n    float32 y;\n\n    // Basic constructor\n    Point(&amp;this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // With default values (when implemented)\n    Point(&amp;this, float32 x = 0.0, float32 y = 0.0) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#instance-methods","title":"Instance Methods","text":"<p>Instance methods are functions that belong to an instance of a class. They always take <code>this</code> as their first parameter:</p> <pre><code>class Circle {\n    float32 radius;\n\n    Circle(&amp;this, float32 radius) {\n        this.radius = radius;\n    }\n\n    // Instance methods\n    // Non-mutating\n    float getArea(&amp;this) {\n        return 3.14159 * this.radius * this.radius;\n    }\n\n    float getCircumference(&amp;this) {\n        return 2.0 * 3.14159 * this.radius;\n    }\n\n    // Mutating via borrow\n    void scale(&amp;this, float32 factor) {\n        this.radius = this.radius * factor;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#static-methods","title":"Static Methods","text":"<p>Static methods belong to the class itself rather than any instance. They don't take a <code>this</code> parameter:</p> <pre><code>class MathUtils {\n    // Static methods\n    static int8 max(int8 a, int8 b) {\n        if (a &gt; b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    static float32 average(float32 a, float32 b) {\n        return (a + b) / 2.0;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#creating-and-using-objects","title":"Creating and Using Objects","text":"<p>Once a class is defined, you can create instances (objects) of that class:</p> <pre><code>// Creating objects\nPerson alice = Person(\"Alice\", 30, true);\nPerson bob = Person(\"Bob\", null);\n\n// Using instance methods\nstring aliceName = alice.getName();\nalice.celebrate();\n\n// Using static methods\nstring speciesName = Person.species();\n</code></pre>"},{"location":"reference/classes/#inheritance","title":"Inheritance","text":"<p>Inheritance allows a class to inherit fields and methods from another class. firescript supports single inheritance using the <code>from</code> keyword:</p> <pre><code>class Student from Person {\n    string school;\n    string[] courses;\n\n    Student(&amp;this, string name, int8 age, string school) {\n        super.Student(name, age);  // Call parent constructor\n        this.school = school;\n        this.courses = [];\n    }\n\n    // Additional methods\n    void enroll(&amp;this, string &amp;course) {\n        this.courses.append(course);\n        print(this.name + \" enrolled in \" + course);\n    }\n\n    string[] getCourses(&amp;this) {\n        return this.courses;\n    }\n\n    // Override parent method\n    void celebrate(&amp;this) {\n        super.celebrate();  // Call parent method\n        print(\"Time for a student party!\");\n    }\n}\n</code></pre>"},{"location":"reference/classes/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override methods from the parent class. To call the parent class's implementation, use <code>super</code>:</p> <pre><code>class Shape {\n    string color;\n\n    Shape(&amp;this, string color) {\n        this.color = color;\n    }\n\n    string describe(&amp;this) {\n        return \"A \" + this.color + \" shape\";\n    }\n}\n\nclass Square from Shape {\n    float32 side;\n\n    Square(&amp;this, float32 side, string color) {\n        super.Shape(color);\n        this.side = side;\n    }\n\n    // Override the parent's describe method\n    string describe(&amp;this) {\n        return super.describe() + \" (square with side \" + toString(this.side) + \")\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism allows objects of different classes in the same inheritance hierarchy to be treated as objects of a common superclass:</p> <pre><code>// Example of future planned polymorphism\nPerson[] people = [\n    Person(\"Alice\", 25),\n    Student(\"Bob\", 20, \"State University\")\n];\n\nuint8 i = 0;\nwhile (i &lt; people.length) {\n    print(people[i].getName());\n    i = i + 1;\n}\n</code></pre>"},{"location":"reference/classes/#planned-class-features-not-yet-implemented","title":"Planned Class Features (Not Yet Implemented)","text":"<p>The following features are planned for future versions of firescript:</p>"},{"location":"reference/classes/#interfaces","title":"Interfaces","text":"<pre><code>// Future syntax\ninterface Drawable {\n    void draw(&amp;this)\n    bool isVisible(&amp;this)\n}\n\nclass Circle implements Drawable {\n    // Must implement all interface methods\n    void draw(&amp;this) {\n        // Drawing implementation\n    }\n\n    bool isVisible(&amp;this) {\n        return true;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#generics-on-classes","title":"Generics on Classes","text":"<pre><code>// Future syntax\nclass Box&lt;T&gt; {\n    nullable T value;\n\n    Box(&amp;this) {\n        this.value = null;\n    }\n\n    void set(&amp;this, T newValue) { // if T is Owned this is a borrow; if T is copyable it's just a copy\n        this.value = newValue;\n    }\n\n    nullable T get(&amp;this) {\n        return this.value;\n    }\n}\n\n// Usage\nBox&lt;int&gt; intBox = Box&lt;int&gt;();\nintBox.set(42);\n</code></pre>"},{"location":"reference/classes/#abstract-classes-and-methods","title":"Abstract Classes and Methods","text":"<pre><code>// Future syntax\nabstract class Animal {\n    string species;\n\n    Animal(&amp;this, string &amp;species) {\n        this.species = species;\n    }\n\n    // Abstract method - no implementation\n    abstract string makeSound(&amp;this);\n\n    // Regular method with implementation\n    string getSpecies(&amp;this) { // non-mutating borrow\n        return this.species;\n    }\n}\n\nclass Cat from Animal {\n    // Must implement abstract methods\n    string makeSound(&amp;this) { // non-mutating\n        return \"Meow\";\n    }\n}\n</code></pre>"},{"location":"reference/classes/#copyable-classes","title":"Copyable Classes","text":"<p>A class may be annotated <code>copyable</code> to become Copyable if it satisfies: 1. All fields are Copyable. 2. No <code>drop</code> defined. 3. Fixed-size representation. 4. No disallowed interior references.</p> <pre><code>// Future syntax\ncopyable class Point {\n    float32 x;\n    float32 y;\n\n    Point(this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n</code></pre>"},{"location":"reference/classes/#best-practices-for-class-design","title":"Best Practices for Class Design","text":"<ol> <li>Single Responsibility Principle: Each class should have only one reason to change.\\</li> <li>Favor Composition Over Inheritance: Use object composition rather than complex inheritance hierarchies.</li> <li>Keep Inheritance Hierarchies Shallow: Deep inheritance can lead to complexity.</li> <li>Use Descriptive Names: Class names should be nouns, method names should be verbs.</li> </ol>"},{"location":"reference/classes/#implementation-status","title":"Implementation Status","text":"<p>Classes in firescript are planned but not yet implemented in the current compiler:</p> <ul> <li>\u274c Class definitions</li> <li>\u274c Instance fields and methods</li> <li>\u274c Constructors</li> <li>\u274c Static methods</li> <li>\u274c Inheritance</li> <li>\u274c Method overriding</li> <li>\u274c Polymorphism</li> <li>\u274c Interfaces</li> <li>\u274c Access modifiers</li> <li>\u274c Abstract classes</li> <li>\u274c Meta-attributes/annotations</li> <li>\u274c Generics on classes</li> </ul>"},{"location":"reference/control_flow/","title":"Control Flow","text":"<p>Only <code>if</code>/<code>else</code> chains and <code>while</code> loops are currently supported. C-style <code>for</code> loops, for-in loops, range loops, and the ternary operator are not supported by the compiler.</p>"},{"location":"reference/control_flow/#introduction-to-control-flow","title":"Introduction to Control Flow","text":"<p>Control flow structures determine the order in which statements are executed in a program. They allow for conditional execution (if/else) and repeated execution (loops) of code blocks. In firescript, control flow constructs use curly braces <code>{}</code> to define code blocks.</p>"},{"location":"reference/control_flow/#conditional-statements","title":"Conditional Statements","text":"<p>Conditional statements execute different blocks of code depending on whether a specified condition evaluates to <code>true</code> or <code>false</code>. firescript supports <code>if</code>, <code>else if</code>, and <code>else</code> statements.</p>"},{"location":"reference/control_flow/#basic-if-statement","title":"Basic If Statement","text":"<p>The simplest form executes a block of code only if the condition is true:</p> <pre><code>if (condition) {\n    // Code executed only if condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>int8 age = 18;\nif (age &gt;= 18) {\n    print(\"You are eligible to vote\");\n}\n</code></pre>"},{"location":"reference/control_flow/#if-else-statement","title":"If-Else Statement","text":"<p>You can specify an alternative block of code to execute when the condition is false:</p> <pre><code>if (condition) {\n    // Code executed if condition is true\n} else {\n    // Code executed if condition is false\n}\n</code></pre> <p>Example:</p> <pre><code>int8 score = 65;\nif (score &gt;= 70) {\n    print(\"Pass\");\n} else {\n    print(\"Fail\");\n}\n</code></pre>"},{"location":"reference/control_flow/#if-else-if-else-chains","title":"If-Else If-Else Chains","text":"<p>For multiple conditions, you can use <code>else if</code>:</p> <pre><code>if (condition1) {\n    // Executed if condition1 is true\n} else if (condition2) {\n    // Executed if condition1 is false and condition2 is true\n} else if (condition3) {\n    // Executed if condition1 and condition2 are false and condition3 is true\n} else {\n    // Executed if all conditions are false\n}\n</code></pre> <p>Example:</p> <pre><code>int8 grade = 85;\n\nif (grade &gt;= 90) {\n    print(\"A\");\n} else if (grade &gt;= 80) {\n    print(\"B\");\n} else if (grade &gt;= 70) {\n    print(\"C\");\n} else if (grade &gt;= 60) {\n    print(\"D\");\n} else {\n    print(\"F\");\n}\n</code></pre>"},{"location":"reference/control_flow/#nested-conditional-statements","title":"Nested Conditional Statements","text":"<p>Conditional statements can be nested within other conditional statements:</p> <pre><code>bool hasDiscount = true;\nint8 totalAmount = 120;\n\nif (totalAmount &gt; 100) {\n    if (hasDiscount) {\n        print(\"You qualify for a 15% discount\");\n    } else {\n        print(\"You qualify for a 10% discount\");\n    }\n} else {\n    print(\"No discount available\");\n}\n</code></pre>"},{"location":"reference/control_flow/#boolean-expressions-in-conditions","title":"Boolean Expressions in Conditions","text":"<p>Conditions can use various boolean operators:</p> <ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li> <li>Logical operators: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> </ul> <p>Example:</p> <pre><code>int8 age = 25;\nbool hasLicense = true;\n\nif (age &gt;= 18 &amp;&amp; hasLicense) {\n    print(\"You can drive\");\n}\n\nif (!(age &lt; 18 || !hasLicense)) {\n    print(\"Also, you can drive\"); // Equivalent to the above\n}\n</code></pre>"},{"location":"reference/control_flow/#loops","title":"Loops","text":"<p>Loops allow for repeated execution of a block of code. firescript supports <code>while</code> loops and plans to support various forms of <code>for</code> loops in the future.</p>"},{"location":"reference/control_flow/#while-loops","title":"While Loops","text":"<p>A <code>while</code> loop repeatedly executes a block of code as long as a specified condition is <code>true</code>:</p> <pre><code>while (condition) {\n    // Loop body: code executed repeatedly as long as condition is true\n}\n</code></pre> <p>Example:</p> <pre><code>uint8 count = 0;\nwhile (count &lt; 5) {\n    print(count);\n    count = count + 1;\n}\n// Outputs: 0, 1, 2, 3, 4\n</code></pre>"},{"location":"reference/control_flow/#infinite-loops","title":"Infinite Loops","text":"<p>A <code>while</code> loop with a condition that is always <code>true</code> creates an infinite loop. These should be used with caution and should include a break statement:</p> <pre><code>while (true) {\n    // This will run forever unless broken\n    if (someCondition) {\n        break; // Exit the loop\n    }\n}\n</code></pre>"},{"location":"reference/control_flow/#loop-control-statements","title":"Loop Control Statements","text":"<p>The following statements can control loop execution:</p> <ul> <li><code>break</code> - Immediately exits the loop</li> <li><code>continue</code> - Skips the rest of the current iteration and starts the next one</li> </ul> <p>Example:</p> <pre><code>uint8 i = 0;\nwhile (i &lt; 10) {\n    i = i + 1;\n\n    if (i == 3) {\n        continue; // Skip the rest of this iteration\n    }\n\n    if (i == 8) {\n        break; // Exit the loop\n    }\n\n    print(i);\n}\n// Outputs: 1, 2, 4, 5, 6, 7\n</code></pre>"},{"location":"reference/control_flow/#combining-loops-and-conditionals","title":"Combining Loops and Conditionals","text":"<p>Loops and conditional statements can be combined to create powerful control flows:</p> <pre><code>int8[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nint8 sum = 0;\nuint8 i = 0;\n\nwhile (i &lt; numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        sum = sum + numbers[i]; // Add only even numbers\n    }\n    i = i + 1;\n}\n\nprint(sum); // Outputs: 30 (2 + 4 + 6 + 8 + 10)\n</code></pre>"},{"location":"reference/control_flow/#future-control-flow-features","title":"Future Control Flow Features","text":"<p>The following control flow features are planned but not yet implemented in the current compiler:</p>"},{"location":"reference/control_flow/#c-style-for-loops","title":"C-style For Loops","text":"<pre><code>// Future syntax\nfor (uint8 i = 0; i &lt; 5; i++) {\n    print(i);\n}\n</code></pre>"},{"location":"reference/control_flow/#for-in-loops","title":"For-In Loops","text":"<pre><code>// Future syntax\nstring[] fruits = [\"apple\", \"banana\", \"cherry\"];\nfor (string fruit : fruits) {\n    print(fruit);\n}\n</code></pre>"},{"location":"reference/control_flow/#range-loops","title":"Range Loops","text":"<pre><code>// Future syntax\nfor (uint8 i : range(5)) {\n    print(i); // 0, 1, 2, 3, 4\n}\n\nfor (uint8 i : range(2, 8)) {\n    print(i); // 2, 3, 4, 5, 6, 7\n}\n\nfor (uint8 i : range(1, 10, 2)) {\n    print(i); // 1, 3, 5, 7, 9\n}\n</code></pre>"},{"location":"reference/control_flow/#ternary-operator","title":"Ternary Operator","text":"<pre><code>// Future syntax\nint8 max = ternary a &gt; b then a else b;\n</code></pre>"},{"location":"reference/control_flow/#switch-statements","title":"Switch Statements","text":"<p>Switch statements provide a way to execute different parts of code based on the value of a variable:</p> <pre><code>// Future syntax\nswitch (value) {\n    case (1) {\n        // code for case 1\n    }\n    case (2) {\n        // code for case 2\n    }\n    case (value &gt; 2 &amp;&amp; value &lt; 5) {\n        // code for range case\n    }\n    default {\n        // default code\n        // executed if no cases match\n    }\n}\n</code></pre>"},{"location":"reference/control_flow/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Keep conditions simple: Split complex conditions into multiple variables for better readability.</p> </li> <li> <p>Avoid deep nesting: Too many nested if/else statements make code hard to follow. Consider refactoring deeply nested code.</p> </li> <li> <p>Be careful with while loops: Always ensure that the condition will eventually become false to avoid infinite loops.</p> </li> <li> <p>Use appropriate loop types: Once implemented, choose the right loop for the task: <code>while</code> for unknown iteration counts, <code>for</code> for counting, and <code>for-in</code> for collections.</p> </li> </ol>"},{"location":"reference/control_flow/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 <code>if</code>/<code>else</code>/<code>else if</code> conditional statements</li> <li>\u2705 <code>while</code> loops</li> <li>\u2705 <code>break</code> and <code>continue</code> statements</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c C-style <code>for</code> loops</li> <li>\u274c <code>for-in</code> loops</li> <li>\u274c Range-based loops</li> <li>\u274c Ternary operator</li> <li>\u274c <code>switch</code>/<code>case</code> statements</li> </ul>"},{"location":"reference/error_handling/","title":"Runtime Error Handling","text":"<p>firescript is designed in a way that minimizes runtime errors through static type checking and compile-time validation. However, some errors may still occur during execution, such as division by zero or out-of-bounds array access.</p>"},{"location":"reference/error_handling/#error-types","title":"Error Types","text":"<ol> <li>Syntax Errors: Caught at compile-time, these errors occur when the code is not well-formed.</li> <li>Type Errors: Also caught at compile-time, these occur when operations are applied to incompatible types.</li> <li>Runtime Errors: These occur during execution and can include:</li> <li>Division by zero</li> <li>Null reference access</li> <li>Array index out of bounds</li> </ol>"},{"location":"reference/error_handling/#error-handling","title":"Error Handling","text":"<p>firescript provides a way to handle runtime errors gracefully:</p> <ul> <li>Try/Catch Blocks: You can wrap code that may throw an error in a try block, and handle the error in a catch block.</li> </ul> <pre><code>try {\n    int8 result = 10 / 0;\n} catch (DivisionByZeroError e) {\n    print(\"Error: \" + e.message);\n}\n</code></pre> <ul> <li>Assertions: Use the <code>assert</code> function to check for conditions that must be true. If the condition is false, an error is raised.</li> </ul> <pre><code>assert(x &gt; 0, \"x must be positive\");\n</code></pre>"},{"location":"reference/error_handling/#best-practices","title":"Best Practices","text":"<ul> <li>Always validate user input to prevent errors.</li> <li>Use try/catch blocks to handle potential runtime errors.</li> <li>Write unit tests to catch errors early in the development process.</li> </ul>"},{"location":"reference/functions/","title":"Functions &amp; Methods","text":"<p>Status: This section includes planned semantics for the ownership-based memory model. See Memory Management for authoritative definitions.</p>"},{"location":"reference/functions/#built-in-functions","title":"Built-in Functions","text":"<p>firescript provides a set of built-in functions that are available for use without requiring any imports. These functions provide essential functionality for input/output, type conversion, and type introspection.</p>"},{"location":"reference/functions/#inputoutput-functions","title":"Input/Output Functions","text":"<ul> <li><code>print(value)</code> \u2013 Outputs a value to the console</li> </ul> <pre><code>print(\"Hello, world!\");  // Prints: Hello, world!\nprint(42);               // Prints: 42\nprint(true);             // Prints: true\n</code></pre> <p>This function accepts values of any type and converts them to strings for display.</p> <ul> <li><code>input(prompt)</code> \u2013 Reads a string from the console</li> </ul> <pre><code>string name = input(\"Enter your name: \");\nprint(\"Hello, \" + name);\n</code></pre> <p>The <code>prompt</code> parameter is displayed to the user before waiting for input.</p>"},{"location":"reference/functions/#type-conversion-functions","title":"Type Conversion Functions","text":"<p>These functions convert values from one type to another:</p> <ul> <li><code>toIntN(value)</code> \u2013 Converts a value to an N-bit integer (e.g., <code>toInt8</code>, <code>toInt16</code>, <code>toInt32</code>, <code>toInt64</code>)</li> </ul> <pre><code>string numberString = \"123\";\nint8 number = toInt8(numberString);  // 123\n\nfloat32 floatVal = 45.7;\nint8 intVal = toInt8(floatVal);      // 45 (truncated)\n</code></pre> <ul> <li><code>toFloatN(value)</code> \u2013 Converts a value to an N-bit floating point number (e.g., <code>toFloat32</code>, <code>toFloat64</code>)</li> </ul> <pre><code>int32 bigNumber = 1000000;\nfloat64 doubleBig = toFloat64(bigNumber);  // 1000000.0 (with 64-bit precision)\n\nstring sciNotation = \"6.022e23\";\nfloat64 avogadro = toFloat64(sciNotation);  // 6.022e23\n</code></pre> <ul> <li><code>toBool(value)</code> \u2013 Converts a value to a boolean</li> </ul> <pre><code>string truthy = \"true\";\nbool flag = toBool(truthy);  // true\n\nstring falsy = \"false\";\nbool notFlag = toBool(falsy);  // false\n\n// Non-string inputs:\nbool nonZero = toBool(1);      // true\nbool zero = toBool(0);         // false\n</code></pre> <ul> <li><code>toString(value)</code> \u2013 Converts a value to a string</li> </ul> <pre><code>int number = 42;\nstring text = toString(number);  // \"42\"\n\nbool state = true;\nstring stateText = toString(state);  // \"true\"\n\nfloat decimal = 3.14;\nstring piText = toString(decimal);  // \"3.14\"\n</code></pre> <ul> <li><code>toChar(value)</code> \u2013 Converts a value to a character (represented as a string)</li> </ul> <pre><code>string word = \"Hello\";\nchar firstLetter = toChar(word);  // \"H\" (first character)\n\nint codePoint = 65;\nchar letter = toChar(codePoint);  // \"A\" (ASCII value 65)\n</code></pre>"},{"location":"reference/functions/#type-introspection","title":"Type Introspection","text":"<ul> <li><code>typeof(value)</code> \u2013 Returns the type name of a value as a string</li> </ul> <pre><code>string typeOfNumber = typeof(42);         // \"int\"\nstring typeOfText = typeof(\"hello\");      // \"string\"\nstring typeOfArray = typeof([1, 2, 3]);   // \"int[]\"\n</code></pre> <p>This can be useful for debugging and for implementing type-dependent behavior.</p>"},{"location":"reference/functions/#testing","title":"Testing","text":"<ul> <li><code>assert(condition, message)</code> \u2013 Asserts that a condition is true, otherwise raises an error with the given message</li> </ul> <pre><code>int x = 5;\nassert(x &gt; 0, \"x must be positive\");  // Passes\nassert(x &lt; 0, \"x must be negative\");  // Fails with error: \"Assertion failed: x must be negative\"\n</code></pre>"},{"location":"reference/functions/#using-built-in-functions","title":"Using Built-in Functions","text":"<p>Functions are called by specifying the function name followed by parentheses containing the arguments:</p> <pre><code>// Converting user input to a number\nstring inputValue = input(\"Enter a number: \");\nint parsedValue = toInt(inputValue);\nprint(\"You entered: \" + toString(parsedValue));\n\n// Type checking\nint number = 42;\nstring typeInfo = typeof(number);\nprint(\"The type of \" + toString(number) + \" is \" + typeInfo);\n</code></pre>"},{"location":"reference/functions/#chain-of-function-calls","title":"Chain of Function Calls","text":"<p>Built-in functions can be chained together:</p> <pre><code>// Get input, convert to int, double it, and print\nint result = toInt(input(\"Enter a number: \")) * 2;\nprint(\"Double of your number is: \" + toString(result));\n</code></pre>"},{"location":"reference/functions/#user-defined-functions","title":"User-defined Functions","text":"<pre><code>// Basic function definition\nreturnType functionName(paramType1 param1, paramType2 param2) {\n    // function body\n    return returnValue;\n}\n\n// Examples:\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(string name) {\n    print(\"Hello, \" + name);\n}\n\nfloat calculateAverage(int[] numbers) {\n    int sum = 0;\n    int i = 0;\n    while (i &lt; numbers.length) {\n        sum = sum + numbers[i];\n        i = i + 1;\n    }\n    return toFloat(sum) / toFloat(numbers.length);\n}\n</code></pre>"},{"location":"reference/functions/#ownership-notes-planned-semantics","title":"Ownership Notes (Planned Semantics)","text":"<ul> <li>Parameters of owned types move into the function. After a call, an argument of an owned type is no longer valid unless the function returns it.</li> <li>Future explicit borrow syntax (<code>&amp;T</code>) will allow passing a read-only view without moving ownership. Borrowed arguments remain valid after the call.</li> <li>For Copyable types (e.g., <code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>, <code>string</code>), calls pass by value; borrowing is not defined for Copyable types.</li> <li><code>input()</code> returns a new <code>string</code> (Copyable).</li> <li><code>toString()</code> and string concatenation produce new <code>string</code> values. Strings are Copyable and passed by value.</li> <li>Cloning is explicit for Owned values (not needed for Copyable types like <code>string</code>).</li> <li>Examples currently show simple pass semantics until borrow syntax is implemented.</li> </ul>"},{"location":"reference/functions/#methods-planned-not-implemented","title":"Methods (Planned, Not Implemented)","text":"<p>Methods are functions that belong to objects. This feature is planned but not yet implemented:</p> <pre><code>class Person {\n    string name\n    int age\n\n    // Constructor method\n    Person(&amp;this, string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Instance method\n    string introduce(&amp;this) {\n        return \"My name is \" + this.name + \" and I'm \" + toString(this.age) + \" years old\";\n    }\n\n    // Static method\n    static string getSpecies() {\n        return \"Human\";\n    }\n}\n</code></pre>"},{"location":"reference/functions/#best-practices-for-functions","title":"Best Practices for Functions","text":"<p>Although user-defined functions aren't implemented yet, here are best practices to follow when they become available:</p> <ol> <li> <p>Single responsibility: Each function should perform a single, well-defined task.</p> </li> <li> <p>Descriptive names: Use verb-based names that clearly describe what the function does.</p> </li> <li> <p>Input validation: Check function arguments for validity when appropriate.</p> </li> <li> <p>Error handling: Consider how your function will handle error conditions.</p> </li> <li> <p>Pure functions: When possible, write pure functions (functions without side-effects that return the same output for the same input).</p> </li> </ol>"},{"location":"reference/functions/#future-function-features","title":"Future Function Features","text":"<p>The following function-related features are planned but not yet implemented:</p> <ul> <li>Optional parameters with default values:</li> </ul> <pre><code>// Future syntax\nvoid greet(string name, string greeting = \"Hello\") {\n    print(greeting + \", \" + name);\n}\n</code></pre> <ul> <li>Named arguments in calls:</li> </ul> <pre><code>// Future syntax\ncalculateRectangle(width: 10, height: 20);\n</code></pre> <ul> <li>Variadic parameters (variable number of arguments):</li> </ul> <pre><code>// Future syntax\nint sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total = total + num;\n    }\n    return total;\n}\n</code></pre> <ul> <li>Function overloading:</li> </ul> <pre><code>// Future syntax\nint add(int a, int b) {\n    return a + b;\n}\n\nfloat add(float a, float b) {\n    return a + b;\n}\n</code></pre>"},{"location":"reference/functions/#implementation-status","title":"Implementation Status","text":"<ul> <li>\u2705 Built-in functions: <code>print</code>, <code>input</code>, type conversions, <code>typeof</code></li> <li>\u2705 Array methods: <code>append</code>, <code>insert</code>, <code>pop</code>, <code>clear</code>, <code>length</code></li> <li>\u2705 User-defined function definitions</li> <li>\u274c Methods on objects</li> <li>\u274c Optional, named, or variadic parameters</li> <li>\u274c Function overloading</li> </ul>"},{"location":"reference/imports/","title":"Imports","text":"<p>Status: Modules and import resolution are planned but not yet implemented. The syntax below is reserved and may evolve as the compiler gains module support.</p> <p>firescript uses an explicit, Java-inspired import system for organizing code across files and (in the future) external packages. All imports must specify full paths; there is no implicit or relative import behavior.</p>"},{"location":"reference/imports/#import-syntax","title":"Import Syntax","text":""},{"location":"reference/imports/#importing-local-modules","title":"Importing local modules","text":"<ul> <li>Import an entire module:</li> </ul> <pre><code>import src.utils.utils\n</code></pre> <ul> <li>Import a specific symbol from a module:</li> </ul> <pre><code>import src.utils.utils.helper\n</code></pre> <ul> <li>Import multiple symbols from a module:</li> </ul> <pre><code>import src.utils.utils.{helper, CONSTANT}\n</code></pre> <ul> <li>Import all symbols from a module (allowed, but discouraged for explicitness):</li> </ul> <pre><code>import src.utils.utils.*\n</code></pre> <ul> <li>Aliasing imports (optional):</li> </ul> <pre><code>import src.utils.utils.helper as help\nimport src.utils.utils as Utils\n</code></pre>"},{"location":"reference/imports/#importing-external-packages-reserved","title":"Importing external packages (reserved)","text":"<p>These forms are reserved for future package management and standard library support:</p> <pre><code>import @user/package\nimport @firescript/std\n</code></pre>"},{"location":"reference/imports/#paths-and-resolution","title":"Paths and Resolution","text":"<ul> <li>Import paths are absolute from the project root. For example, <code>src.utils.utils</code> maps to <code>{project-root}/src/utils/utils.fire</code>.</li> <li>Relative imports (e.g., <code>import ../utils</code>) are not permitted.</li> <li>There are no default or magic imports\u2014every symbol must be explicitly imported.</li> <li>The <code>.fire</code> extension is omitted in import statements but always resolves to a file with that extension.</li> <li>A configurable import root may be supported in the future; the default is the project root.</li> </ul>"},{"location":"reference/imports/#examples","title":"Examples","text":"<p>Given the structure:</p> <pre><code>src/\n    main.fire\n    utils/\n        utils.fire\n    enums/\n        colors.fire\n</code></pre> <p>From <code>colors.fire</code>, to import a function <code>helper</code> from <code>utils.fire</code>:</p> <pre><code>import src.utils.utils.helper\n</code></pre> <p>To import the entire module:</p> <pre><code>import src.utils.utils\n</code></pre> <p>To import multiple symbols:</p> <pre><code>import src.utils.utils.{helper, CONSTANT}\n</code></pre>"},{"location":"reference/imports/#wildcards-aliasing-and-explicitness","title":"Wildcards, Aliasing, and Explicitness","text":"<ul> <li>Wildcards via <code>*</code> are allowed but discouraged; prefer explicit symbol lists.</li> <li>Aliasing is available for both modules and symbols to improve clarity and resolve naming conflicts.</li> <li>Explicitness is required\u2014no implicit re-exports or default imports.</li> </ul>"},{"location":"reference/imports/#reserved-future-features","title":"Reserved &amp; Future Features","text":"<ul> <li><code>import @user/package</code> is reserved for future package management.</li> <li><code>import @firescript/std</code> is reserved for standard library modules.</li> </ul>"},{"location":"reference/imports/#best-practices","title":"Best Practices","text":"<ol> <li>Prefer explicit symbol imports over wildcards.</li> <li>Avoid broad module imports unless you intentionally need many symbols.</li> <li>Use aliasing when names conflict or when a shorter local name improves readability.</li> </ol>"},{"location":"reference/imports/#not-supported","title":"Not Supported","text":"<ul> <li>Relative imports</li> <li>Implicit \u201cimport everything\u201d behavior</li> <li>Omitting paths or symbols</li> </ul>"},{"location":"reference/imports/#syntax-summary","title":"Syntax Summary","text":"Syntax Meaning <code>import src.utils.utils</code> Import entire module <code>import src.utils.utils.helper</code> Import a specific symbol <code>import src.utils.utils.{a, b}</code> Import multiple symbols <code>import src.utils.utils.*</code> Import all symbols (discouraged) <code>import src.utils.utils.helper as h</code> Alias an imported symbol <code>import @user/package</code> External package (future)"},{"location":"reference/imports/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Import statements are only valid at the top level of a source file.</li> <li>The compiler will resolve imports from the project root and report missing files or symbols.</li> <li>Cyclic imports should be detected and reported as errors.</li> </ul>"},{"location":"reference/imports/#implementation-status","title":"Implementation Status","text":"<ul> <li>\u274c Modules and import resolution are planned but not implemented in the current compiler.</li> <li>\u2705 Syntax is reserved and documented here for future implementation.</li> </ul>"},{"location":"reference/memory_management/","title":"Memory Management","text":"<p>Status: This is the authoritative specification of firescript's ownership-based memory model. Some described behaviors (e.g., last-use drop insertion, borrow checking) may not yet be enforced in current builds. If another document conflicts with this page, this page takes precedence.</p>"},{"location":"reference/memory_management/#overview","title":"Overview","text":"<p>firescript uses a deterministic ownership model rather than a tracing garbage collector. Values are categorized as either copyable or owned. Owned values move by default; borrowing (<code>&amp;T</code>) provides a temporary, read\u2011only view only for Owned types. Copyable types are always passed and assigned by value (bitwise copy); they cannot be borrowed. The compiler (planned) inserts destruction (\u201cdrop\u201d) at the last proven use or at scope end. Ordinary owned values incur no runtime reference counting.</p> <p>This page is layered: first core concepts, then detailed rules. Other documentation pages should link here instead of redefining terminology.</p>"},{"location":"reference/memory_management/#core-concepts-concept-map","title":"Core Concepts (Concept Map)","text":"<ol> <li>Categorize each value: copyable or owned</li> <li>Moving an Owned value transfers ownership; the previous binding becomes invalid</li> <li>Borrowing (<code>&amp;T</code>) is only allowed for Owned types; it grants a read-only, non-owning view tied to the original owner\u2019s lifetime</li> <li>Copyable types are simply copied; \u201cmove\u201d is indistinguishable from copy; borrowing does not exist for Copyable types</li> <li>The compiler performs last-use analysis to place deterministic drop points (Owned types only)</li> <li>Scope exit drops any remaining owned values</li> <li>Cloning is explicit (<code>.clone()</code> / <code>clone(x)</code>) for Owned values</li> </ol>"},{"location":"reference/memory_management/#terminology","title":"Terminology","text":"<p>Core terms (Copyable, Owned, Move, Borrow, Clone, Drop) are defined centrally in the glossary. This document applies those definitions normatively and adds the constraint:</p> <ul> <li>Borrow (<code>&amp;T</code>) is only defined for Owned types. Attempting to borrow a Copyable type (e.g., <code>&amp;int</code>) is a compile error.</li> </ul>"},{"location":"reference/memory_management/#how-this-interacts-with-other-features","title":"How This Interacts With Other Features","text":"<ul> <li>Scoping: Scope exit triggers drops of any still-owned values (see Scoping).</li> <li>Functions: Owned parameters move; borrowed parameters (<code>&amp;T</code>) (Owned types only) do not transfer ownership (see Functions).</li> <li>Future Closures: Captures of Owned variables default to move; borrow captures are allowed only if the closure cannot escape.</li> </ul>"},{"location":"reference/memory_management/#detailed-rules","title":"Detailed Rules","text":""},{"location":"reference/memory_management/#1-value-categories","title":"1. Value Categories","text":"<ul> <li>Copyable: Fixed-size scalars with no destructor (e.g., <code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>char</code>, <code>string</code>, and fixed-size arrays). Copy is bitwise; there is no drop. Borrowing a Copyable type is disallowed (<code>&amp;int</code> is invalid).</li> <li>Owned: Heap-backed or resource-managing values (e.g., user-defined objects, closures). Ownership is unique; assignment/pass/return moves ownership. Destruction runs at drop points.</li> </ul> <p>Cloning Owned values is explicit via <code>.clone()</code> or <code>clone(x)</code>.</p>"},{"location":"reference/memory_management/#2-regions-and-lifetimes","title":"2. Regions and Lifetimes","text":"<ul> <li>Each lexical scope defines a region. An owned value lives in the region of its current owner.</li> <li>On scope exit, all owned values remaining in the region are dropped (reverse creation order).</li> <li>The compiler performs last-use analysis and inserts earlier drops when safe.</li> <li>Copyable values have no lifetime actions; they are ignored by drop logic.</li> </ul> <p>Moving a value transfers it to the destination region: - Passing to a function that takes <code>owned T</code> moves into the callee\u2019s region. - Returning <code>T</code> moves into the caller\u2019s region. - Assigning to a variable moves into that variable\u2019s region.</p>"},{"location":"reference/memory_management/#3-function-parameters-and-returns","title":"3. Function Parameters and Returns","text":"<p>Parameters may be:</p> <ul> <li><code>owned T</code>: (T is Owned) callee receives ownership; caller loses it unless returned.</li> <li><code>&amp;T</code>: (T is Owned) borrowed, read-only; callee cannot retain or return it in a longer-lived form.</li> </ul> <p>For Copyable types: - There is only pass-by-value (copy). No borrow syntax is permitted. <code>intN</code>, <code>bool</code>, etc. are always copied; moves do not invalidate the source.</p> <p>Returns: - Returning <code>T</code> (Owned) transfers ownership to the caller. - Returning <code>&amp;T</code> (Owned) only allowed if the referenced value is owned by the caller (non-escaping). Borrow returns of Copyable types are invalid (they cannot be borrowed).</p> <p>Notes: - At call sites, borrow inference applies only when the callee expects <code>&amp;OwnedType</code>. - Attempting to pass a Copyable value where <code>&amp;T</code> is required is a type error (cannot borrow Copyable).</p>"},{"location":"reference/memory_management/#4-borrowing-rules-owned-types-only","title":"4. Borrowing Rules (Owned Types Only)","text":"<ul> <li>Borrowing is only defined for Owned types.</li> <li>A borrowed <code>&amp;OwnedType</code> is a non-owning, read-only view.</li> <li>A borrow cannot be stored in any owned field or global location that outlives the borrow expression/call.</li> <li>Mutability of Owned values occurs via methods on an owned receiver or a consuming pattern (no mutable borrow form yet).</li> <li>If a function must retain or store a value, it must take ownership (<code>owned T</code>) or clone inside the borrow\u2019s scope.</li> </ul>"},{"location":"reference/memory_management/#5-closures-and-coroutines","title":"5. Closures and Coroutines","text":"<ul> <li>Capturing by move transfers ownership into the closure\u2019s region (Owned types only).</li> <li>Capturing by borrow is only allowed for non-escaping closures and only for Owned types.</li> <li>Copyable values captured are copied; no borrow form exists. (Copyable capture has no ownership effect.)</li> <li>Escaping closures cannot have borrowed captures.</li> </ul>"},{"location":"reference/memory_management/#6-destruction-and-drop","title":"6. Destruction and <code>Drop</code>","text":"<ul> <li>Owned (Owned) types may define <code>drop(this)</code>.</li> <li>Drops occur deterministically:</li> <li>At last use (if provable).</li> <li>At scope exit.</li> <li>Along all control-flow exits (return, break, exception).</li> <li>Moves prevent duplicate drops (previous binding invalidated).</li> <li>Copyable values never have drops.</li> </ul> <p>Example:</p> <pre><code>File f = File.open(\"log.txt\");\nf.write(\"hello\");\nf.flush();\n// f dropped here even on early return/exception; File.drop closes the descriptor.\n</code></pre>"},{"location":"reference/memory_management/#7-method-receivers","title":"7. Method Receivers","text":"<p>Method receiver kinds apply only to Owned types (Copyable methods implicitly copy the receiver):</p> <ul> <li>Borrowed receiver (default for Owned): signature form <code>name(...) ReturnType</code> implicitly receives <code>&amp;OwnedType this</code> (read-only).</li> <li>Consuming receiver: <code>name(owned this, ...) ReturnType</code> (or <code>name(this, ...)</code>) takes ownership; caller\u2019s binding is invalid unless the method returns it.</li> </ul> <p>For Copyable types: - Methods always receive the value by copy; \u201cconsuming\u201d semantics do not apply.</p> <p>Consuming example:</p> <pre><code>Account upgrade(owned this) {\n  // ... mutate internal state\n  return this;\n}\n\nacct = acct.upgrade(); // rebind because ownership moved and was returned\n</code></pre>"},{"location":"reference/memory_management/#8-control-flow-and-last-use-owned-types","title":"8. Control Flow and Last Use (Owned Types)","text":"<ul> <li>Conditional joins: if both branches use a value, drop inserted after merge; otherwise at last branch that uses it.</li> <li>Loops: Values used across iterations drop after loop. Iteration-temporary owned values drop at iteration end.</li> <li>Copyable values ignored by last-use logic (always trivially copyable).</li> </ul>"},{"location":"reference/memory_management/#9-conversions-and-sharing","title":"9. Conversions and Sharing","text":"<ul> <li>To create multiple independent owners of an Owned value: <code>.clone()</code>.</li> <li>Opt-in reference-counted or shared abstractions may be provided (e.g., <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, arenas). These layer explicit runtime or bulk management semantics on top of the ownership core.</li> <li>Copyable values never require sharing constructs.</li> </ul>"},{"location":"reference/memory_management/#10-interop-and-backends","title":"10. Interop and Backends","text":"<ul> <li>Native: Drops become direct destructor calls.</li> <li>JavaScript: Destruction logic executes at specified points; underlying JS GC handles memory backing where applicable; resource closures are deterministic.</li> </ul>"},{"location":"reference/memory_management/#11-diagnostics","title":"11. Diagnostics","text":"<ul> <li>Use-after-move (Owned) is an error: primary note at move, secondary at invalid use.</li> <li>Illegal borrow of a Copyable type (e.g., <code>&amp;int</code>) is an error: \u201cCannot borrow trivially copyable type \u2018int\u2019; pass by value.\u201d</li> <li>Borrow escape detection flags returning or storing a borrow beyond its allowed lifetime.</li> <li>Deterministic destruction order may be visualized (tooling).</li> </ul>"},{"location":"reference/memory_management/#declaring-a-copyable-class","title":"Declaring a Copyable Class","text":"<p>A class may be annotated <code>copyable</code> to become Copyable if it satisfies: 1. All fields are Copyable. 2. No <code>drop</code> defined. 3. Fixed-size representation. 4. No disallowed interior references.</p> <p>Example:</p> <pre><code>copyable class Vec2 {\n    float32 x; // float32 is Copyable\n    float32 y;\n}\n</code></pre> <p><code>Vec2</code> values copy bitwise; moves do not invalidate the source.</p>"},{"location":"reference/memory_management/#examples","title":"Examples","text":"<p>The following examples illustrate planned semantics. Some features (e.g., full last-use optimization) may not yet be implemented.</p>"},{"location":"reference/memory_management/#example-move-vs-copy-takeaway-owned-moves-copyable-copies","title":"Example: Move vs Copy (Takeaway: Owned moves; Copyable copies)","text":"<pre><code>Object o1 = Object(); // owned\nObject o2 = o1;      // move; o1 invalid afterward\n// print(o1);        // error: moved value\n\nint8 x = 42;\nint8 y = x;          // copy (Copyable); x still valid\nprint(x);           // OK\n</code></pre>"},{"location":"reference/memory_management/#example-clone-takeaway-explicit-duplication-for-owned","title":"Example: Clone (Takeaway: explicit duplication for Owned)","text":"<pre><code>string s1 = \"fire\";\nstring s2 = s1.clone(); // independent\nprint(s1);\nprint(s2);\n</code></pre>"},{"location":"reference/memory_management/#example-borrowed-parameter-owned-only","title":"Example: Borrowed Parameter (Owned only)","text":"<pre><code>int length(&amp;string s) {\n    return s.length;\n}\n\nstring name = \"firescript\";\nint8 n = length(name); // borrow; name still valid\n</code></pre>"},{"location":"reference/memory_management/#example-invalid-borrow-of-copyable-compile-error","title":"Example: Invalid Borrow of Copyable (Compile Error)","text":"<pre><code>int8 id = 10;\nprintId(&amp;id);   // ERROR: cannot borrow Copyable type 'int'; remove '&amp;'\n\n// Correct version:\nvoid printId(int8 v) {\n    print(v);\n}\nprintId(id);    // copies 'id'\nprint(id);      // still valid\n</code></pre>"},{"location":"reference/memory_management/#example-owned-parameter-consumed","title":"Example: Owned Parameter Consumed","text":"<pre><code>void addUser(owned string username);\n\nstring u = \"alice\";\naddUser(u);   // move; u invalid afterward\n</code></pre>"},{"location":"reference/memory_management/#example-returning-borrow-owned-only-non-escaping","title":"Example: Returning Borrow (Owned Only, Non-Escaping)","text":"<pre><code>&amp;string head(string[] xs) {\n    return xs[0];   // OK: element owned by caller's array\n}\n</code></pre>"},{"location":"reference/memory_management/#example-consuming-method","title":"Example: Consuming Method","text":"<pre><code>Account activate(owned this) {\n    // mutate state\n    return this;\n}\n\nacct = acct.activate(); // rebind with returned owned value\n</code></pre>"},{"location":"reference/memory_management/#summary-of-borrowing-availability","title":"Summary of Borrowing Availability","text":"Kind Copyable Types Owned Types Borrow (<code>&amp;T</code>) Not allowed (error) Allowed (read-only, non-owning) Move Degenerate (copy) Transfers ownership; source invalid Clone Not needed Explicit, creates new owner Drop Not applicable Invokes destructor deterministically <p>Borrowing is intentionally restricted to Owned types to: 1. Preserve simplicity (no redundant alias form for scalars). 2. Keep ownership-focused diagnostics clear. 3. Avoid needless syntactic noise for trivially cheap copies.</p> <p>If a future revision broadens Copyable to include large POD aggregates, this restriction may be reconsidered; until then it is normative.</p>"},{"location":"reference/overview/","title":"Language Reference Overview","text":"<p>This section provides a comprehensive reference for the firescript programming language. firescript is a statically and strongly typed language that prioritizes readability, explicitness, and predictable behavior.</p>"},{"location":"reference/overview/#core-design-principles","title":"Core Design Principles","text":"<p>firescript's design follows several key principles:</p> <ul> <li>Static &amp; Strong Typing: Every variable has a defined type that is checked at compile-time</li> <li>Explicit Behavior: No implicit type conversions or hidden behaviors</li> <li>Simple Syntax: Draws inspiration from C, Java, JavaScript, and Python</li> <li>Consistent Rules: Language constructs follow consistent patterns</li> <li>Predictable Execution: Code behaves as written, minimizing surprises</li> </ul>"},{"location":"reference/overview/#implementation-status","title":"Implementation Status","text":"<p>The firescript compiler is under active development. Current status:</p> Feature Status Notes Copyable Types \u26a0\ufe0f Partial <code>bool</code>, <code>string</code>, <code>char</code>, <code>intN</code>, <code>floatN</code> Arrays \u26a0\ufe0f Partial Basic operations work; slicing not implemented Memory Model \u26a0\ufe0f In Progress Ownership model documented; compiler enforcement WIP. Arrays are targeted as the first Owned type. See Memory Management. Control Flow \u26a0\ufe0f Partial <code>if/else</code> and <code>while</code> loops work; <code>for</code> loops planned Functions \u26a0\ufe0f Partial Functions can be defined and used but lack some planned features Classes \u274c Planned Object-oriented features planned for future versions Modules \u274c Planned Code organization across files planned for future versions"},{"location":"reference/overview/#getting-started","title":"Getting Started","text":"<p>For those new to firescript, we recommend starting with the following guides:</p> <ol> <li>Types &amp; Variables - Learn how to declare and use variables</li> <li>Arrays - Working with collections of data</li> <li>Control Flow - Conditionals and loops</li> <li>Functions &amp; Methods - Using built-in functions</li> </ol>"},{"location":"reference/overview/#detailed-reference","title":"Detailed Reference","text":"<p>For more detailed information, each section of this reference covers specific aspects of the language:</p> <ul> <li>Type System - Comprehensive information about the firescript type system</li> <li>Scoping Rules - How variable scoping works</li> <li>Classes &amp; Inheritance - Object-oriented programming (future)</li> </ul>"},{"location":"reference/overview/#example-code","title":"Example Code","text":"<pre><code>// Calculate fibonacci numbers\nint8 i = 0;\nint8 j = 1;\nint8 count = 10;\n\nprint(\"Fibonacci Sequence:\");\nprint(i);\nprint(j);\n\nwhile (count &gt; 0) {\n    int8 next = i + j;\n    print(next);\n    i = j;\n    j = next;\n    count = count - 1;\n}\n</code></pre> <p>For the complete language specification, see the Language Specification document.</p>"},{"location":"reference/scoping/","title":"Scoping in firescript","text":"<p>Status: This section references planned ownership semantics. See Memory Management for authoritative definitions.</p> <p>In firescript, scopes define the visibility and lifetime of variables. Understanding how scopes work is crucial for writing correct and predictable code.</p>"},{"location":"reference/scoping/#scope-creation","title":"Scope Creation","text":"<p>A new scope is created by any set of curly braces <code>{}</code>. This includes:</p> <ul> <li>Control Flow Statements: The bodies of <code>if</code>, <code>else if</code>, <code>else</code>, <code>for</code>, <code>while</code>, and other control flow statements each create their own scope.</li> <li>Function Bodies: The body of a function defines a scope.</li> <li>Class Bodies: The body of a class defines a scope.</li> <li>Bare Braces: You can create an explicit scope simply by using a pair of curly braces <code>{}</code> anywhere they are syntactically allowed.</li> </ul> <pre><code>// Global scope\n\nint globalVar = 10;\n\nif (globalVar &gt; 5) {\n    // Inner scope 1 (if body)\n    int innerVar1 = 20;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar1);  // Accessing current scope variable: OK (prints 20)\n}\n\n// print(innerVar1)  // ERROR: innerVar1 is not accessible here\n\n{\n    // Inner scope 2 (bare braces)\n    int innerVar2 = 30;\n    print(globalVar);  // Accessing outer scope variable: OK (prints 10)\n    print(innerVar2);  // Accessing current scope variable: OK (prints 30)\n\n    if (true) {\n        // Inner scope 3 (nested if body)\n        int innerVar3 = 40;\n        print(globalVar);  // OK (prints 10)\n        print(innerVar2);  // OK (prints 30)\n        print(innerVar3);  // OK (prints 40)\n    }\n    // print(innerVar3)  // ERROR: innerVar3 is not accessible here\n}\n\n// print(innerVar2)  // ERROR: innerVar2 is not accessible here\n</code></pre>"},{"location":"reference/scoping/#scope-hierarchy-and-variable-access","title":"Scope Hierarchy and Variable Access","text":"<ul> <li>Outer Scope Access: An inner scope can access variables declared in any of its enclosing (outer) scopes, all the way up to the global scope.</li> <li>Inner Scope Isolation: An outer scope cannot access variables declared within any of its inner scopes. Once a scope block is exited, all variables declared directly within that scope are destroyed and become inaccessible.</li> <li>Variable Shadowing: Variable shadowing is not allowed. firescript will throw an error if you try to declare a variable with the same name in an inner scope that already exists in an outer scope. This is to prevent confusion and ensure that the intended variable is always accessed.</li> </ul>"},{"location":"reference/scoping/#detailed-scoping-rules","title":"Detailed Scoping Rules","text":""},{"location":"reference/scoping/#1-variable-declaration-and-initialization","title":"1. Variable Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement. They are only accessible within their scope:</p> <pre><code>{\n    int x = 5;  // x is declared and initialized\n\n    {\n        // New inner scope\n        print(x);  // Accessible, prints 5\n\n        // int x = 10;  // ERROR: Cannot redeclare 'x' - shadowing is not allowed\n        int y = 15;  // y is only accessible in this scope\n    }\n\n    // print(y)  // ERROR: y is not defined in this scope\n}\n// print(x)  // ERROR: x is not defined in this scope\n</code></pre>"},{"location":"reference/scoping/#2-variable-lifetime","title":"2. Variable Lifetime","text":"<p>Variables exist only from the point of their declaration to the end of their containing scope:</p> <pre><code>{\n    // print(a)  // ERROR: Cannot use 'a' before declaration\n\n    int a = 1;\n    print(a);  // OK: 'a' exists here\n\n    {\n        int b = 2;\n        print(a);  // OK: 'a' from outer scope\n        print(b);  // OK: 'b' from current scope\n    }  // 'b' is destroyed here\n\n    // print(b)  // ERROR: 'b' no longer exists\n}  // 'a' is destroyed here\n</code></pre>"},{"location":"reference/scoping/#3-global-scope","title":"3. Global Scope","text":"<p>Variables declared outside any braces are in the global scope and are accessible throughout the entire program:</p> <pre><code>int globalValue = 100;  // Global variable\n\n{\n    print(globalValue);  // Accessible anywhere in the program\n\n    {\n        print(globalValue);  // Still accessible\n    }\n}\n\n// User-defined functions would also have access to global variables\n// when this feature is implemented\n</code></pre>"},{"location":"reference/scoping/#4-loop-scopes","title":"4. Loop Scopes","text":"<p>Each iteration of a loop has its own scope:</p> <pre><code>int i = 0;\nwhile (i &lt; 3) {\n    // New scope for each loop iteration\n    int temp = i * 10;\n    print(temp);  // Prints 0, 10, 20\n    i = i + 1;\n}  // 'temp' is destroyed at the end of each iteration\n\n// print(temp)  // ERROR: 'temp' is not accessible here\n</code></pre>"},{"location":"reference/scoping/#5-conditional-scopes","title":"5. Conditional Scopes","text":"<p>Each branch of a conditional statement creates its own scope. This pattern prevents runtime issues where a variable may or may not be defined depending on the execution path:</p> <pre><code>int value = 5;\n\nif (value &gt; 10) {\n    // Scope A\n    int result = value * 2;\n    print(result);\n} else if (value &gt; 0) {\n    // Scope B (different from Scope A)\n    int result = value + 10;  // OK to reuse the name 'result' here\n    print(result);  // Prints 15\n} else {\n    // Scope C (different from Scopes A and B)\n    int result = 0;\n    print(result);\n}\n\n// print(result)  // ERROR: 'result' is not accessible here\n</code></pre>"},{"location":"reference/scoping/#6-nested-function-scopes-future-feature","title":"6. Nested Function Scopes (Future Feature)","text":"<p>When user-defined functions are implemented, they will create their own scopes:</p> <pre><code>// Global scope\nint globalVar = 10;\n\n// Future syntax when functions are implemented\nvoid exampleFunction() {\n    // Function scope\n    int functionVar = 20;\n    print(globalVar);  // OK: access to global scope\n\n    {\n        // Inner scope within the function\n        int innerVar = 30;\n        print(functionVar);  // OK: access to containing function scope\n        print(globalVar);    // OK: access to global scope\n    }\n\n    // print(innerVar)  // ERROR: not accessible outside its scope\n}\n\n// print(functionVar)  // ERROR: function variables only exist in function scope\n</code></pre>"},{"location":"reference/scoping/#variable-scope-vs-object-lifetime","title":"Variable Scope vs. Object Lifetime","text":"<p>It's important to distinguish between a variable's scope (where it can be accessed) and an object's lifetime (how long it exists in memory and when it is dropped):</p> <pre><code>// When object-oriented features are implemented:\n{\n    // myObj variable is scoped to this block\n    Person myObj = Person(\"John\", 30);\n\n    // myObj reference goes out of scope here\n    // The Person object will be dropped (its destructor run) when its final owner goes out of scope.\n    // (Deterministic planned behavior \u2013 see Memory Management.)\n}\n</code></pre>"},{"location":"reference/scoping/#best-practices-for-effective-scoping","title":"Best Practices for Effective Scoping","text":"<ol> <li> <p>Keep scopes as small as possible: Declare variables in the smallest scope where they are needed.</p> </li> <li> <p>Declare variables close to their first use: This improves code readability and maintainability.</p> </li> <li> <p>Use explicit scopes for temporary variables: Use bare braces <code>{}</code> to create explicit scopes for temporary variables.</p> </li> </ol> <p><code>firescript    {        // Temporary calculation scope        int temp = complexCalculation();        result = temp * 2;    }  // 'temp' is no longer accessible, reducing scope pollution</code></p> <ol> <li> <p>Be consistent with variable naming: Use clear, descriptive names to avoid confusion, especially with variables in different scopes.</p> </li> <li> <p>Avoid deeply nested scopes: Excessive nesting can make code harder to read and understand.</p> </li> </ol>"},{"location":"reference/scoping/#interaction-with-ownership-planned","title":"Interaction With Ownership (Planned)","text":"<ul> <li>Scope exit triggers deterministic drop of all still-owned values declared in that scope.</li> <li>A move transfers ownership; the original variable becomes invalid immediately after the move.</li> <li>A borrow (<code>&amp;T</code>) never extends lifetime; it relies on the original owner remaining in scope.</li> <li>Last-use analysis may drop a value before the lexical end of the scope if no further uses are provable.</li> </ul>"},{"location":"reference/scoping/#implementation-details","title":"Implementation Details","text":"<p>firescript's scoping mechanism is implemented as a stack of symbol tables. When looking up a variable:</p> <ol> <li>The compiler first checks the innermost scope (top of the stack)</li> <li>If not found, it progressively checks outer scopes</li> <li>If the variable is not found in any scope, a compilation error occurs</li> </ol>"},{"location":"reference/scoping/#common-scoping-errors","title":"Common Scoping Errors","text":""},{"location":"reference/scoping/#1-accessing-variables-outside-their-scope","title":"1. Accessing Variables Outside Their Scope","text":"<pre><code>{\n    int8 value = 10;\n}\nprint(value)  // ERROR: 'value' is not defined in this scope\n</code></pre>"},{"location":"reference/scoping/#2-redeclaring-variables-in-the-same-scope","title":"2. Redeclaring Variables in the Same Scope","text":"<pre><code>int8 count = 5;\nint8 count = 10;  // ERROR: 'count' is already defined\n</code></pre>"},{"location":"reference/scoping/#3-attempting-variable-shadowing","title":"3. Attempting Variable Shadowing","text":"<pre><code>int8 value = 10;\nif (true) {\n    int8 value = 20;  // ERROR: Shadowing is not allowed in firescript\n}\n</code></pre>"},{"location":"reference/scoping/#4-using-variables-before-declaration","title":"4. Using Variables Before Declaration","text":"<pre><code>print(result);  // ERROR: Cannot use 'result' before declaration\nint8 result = 42;\n</code></pre>"},{"location":"reference/scoping/#implementation-status","title":"Implementation Status","text":"<p>Scope handling in firescript is fully implemented:</p> <ul> <li>\u2705 Block scopes with curly braces</li> <li>\u2705 Variable visibility rules</li> <li>\u2705 Prohibition of variable shadowing</li> <li>\u2705 Scope nesting and hierarchy</li> <li>\u2705 Variable lifetime management</li> </ul>"},{"location":"reference/type_system/","title":"Type System in firescript","text":"<p>firescript employs a static type system to enhance code reliability and catch errors early during the compilation phase. This means that the type of every variable and expression is checked before the code is run.</p>"},{"location":"reference/type_system/#built-in-types","title":"Built-in Types","text":"<p>firescript provides several fundamental data types. These are all Copyable types:</p> <ul> <li>Numeric Types:</li> <li><code>int8</code>: 8-bit signed integer</li> <li><code>int16</code>: 16-bit signed integer</li> <li><code>int32</code>: 32-bit signed integer</li> <li><code>int64</code>: 64-bit signed integer</li> <li><code>uint8</code>: 8-bit unsigned integer</li> <li><code>uint16</code>: 16-bit unsigned integer</li> <li><code>uint32</code>: 32-bit unsigned integer</li> <li><code>uint64</code>: 64-bit unsigned integer</li> <li><code>float32</code>: 32-bit floating point number</li> <li><code>float64</code>: 64-bit floating point number</li> <li><code>float128</code>: 128-bit floating point number</li> <li><code>bool</code>: Represents boolean values, either <code>true</code> or <code>false</code>. Example: <code>bool isActive = true;</code></li> <li><code>string</code>: Represents sequences of characters. Example: <code>string message = \"Hello, World!\";</code></li> <li><code>char</code>: Represents a single character. (Note: Currently handled similarly to strings in some contexts, formal <code>char</code> type might be refined). Example: <code>char initial = \"A\";</code></li> <li><code>void</code>: Represents the absence of a type, primarily used as the return type for functions that do not return a value.</li> </ul>"},{"location":"reference/type_system/#type-semantics","title":"Type Semantics","text":""},{"location":"reference/type_system/#integer-type-intn-and-uintn","title":"Integer Type (<code>intN</code> and <code>uintN</code>)","text":"<p>The <code>intN</code> types in firescript represent N-bit signed integers, while the <code>uintN</code> types represent N-bit unsigned integers.</p> <pre><code>int8 small = 42;\nint64 large = 9223372036854775807;  // Large integers are supported\nint64 calculation = (small + large) * 2;  // Arithmetic operations\n</code></pre> <p>Integers support the following operations:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo), <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Bit manipulation (planned but not yet implemented): <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li> </ul>"},{"location":"reference/type_system/#integer-literals","title":"Integer Literals","text":"<p>Integer literals can be made more readable using underscores:</p> <pre><code>int32 million = 1_000_000;  // One million\nint64 bigNumber = 9_223_372_036_854_775_807;  // Large integer\n</code></pre> <p>Integer literals can be specified in decimal, hexadecimal, binary, or octal formats:</p> <pre><code>int8 decimal = 42;        // Decimal\nint8 hex = 0x2A;          // Hexadecimal\nint8 binary = 0b00101010; // Binary\nint8 octal = 0o52;        // Octal\n</code></pre> <p>Integer literals by default will be inferred as <code>int32</code> unless specified otherwise. To specify a different integer type, you can use a suffix:</p> <pre><code>int8 small = 42i8;\nint16 medium = 30000i16;\nint64 large = 9223372036854775807i64;\nuint8 usmall = 255u8;\nuint16 umedium = 60000u16;\nuint64 ularge = 18446744073709551615u64;\n</code></pre> <p>You can define a base and a suffix together:</p> <pre><code>int8 hexSmall = 0x2Ai8;\nuint16 binMedium = 0b111010100110u16;\n</code></pre>"},{"location":"reference/type_system/#integer-overflow-and-underflow-behavior","title":"Integer Overflow and Underflow Behavior","text":"<p>For all fixed-size integer types (<code>intN</code> and <code>uintN</code>), arithmetic operations that exceed the representable range will throw an error at runtime. This is to prevent silent overflow/underflow issues.</p> <pre><code>int8 max = 127i8;\nint8 overflow = max + 1i8;  // Runtime error: Integer overflow\n</code></pre> <p>Overflows that can be detected at compile-time (e.g., constant expressions) will result in a compile-time error.</p> <pre><code>int8 compileTimeOverflow = 128i8;  // Compile-time error: Integer overflow\n</code></pre>"},{"location":"reference/type_system/#floating-point-types-floatn","title":"Floating Point Types (<code>floatN</code>)","text":"<p>The <code>floatN</code> types represent N-bit floating point numbers.</p> <pre><code>float32 simpleDecimal = 3.14;\nfloat64 highPrecision = 3.141592653589793;\n</code></pre> <p>Floating point numbers support:</p> <ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> </ul>"},{"location":"reference/type_system/#floating-point-literals","title":"Floating Point Literals","text":"<p>Floating point literals can be specified in decimal or scientific notation:</p> <pre><code>float32 decimal = 3.14f32;        // Decimal\nfloat64 scientific = 2.71828e0f64; // Scientific notation\n</code></pre> <p>Floating point literals by default will be inferred as <code>float32</code> unless specified otherwise. To specify a different floating point type, you can use a suffix:</p> <pre><code>float32 f32Value = 3.14f32;\nfloat64 f64Value = 3.14f64;\nfloat128 f128Value = 3.14f128;\n</code></pre>"},{"location":"reference/type_system/#special-floating-point-values","title":"Special Floating Point Values","text":"<p>Floating point types support special values such as <code>NaN</code> (Not a Number), <code>Infinity</code>, and <code>-Infinity</code>:</p> <pre><code>float32 notANumber = 0.0f32 / 0.0f32;  // NaN\nfloat64 positiveInfinity = 1.0f64 / 0.0f64;  // Infinity\nfloat64 negativeInfinity = -1.0f64 / 0.0f64; // -Infinity\n</code></pre>"},{"location":"reference/type_system/#floating-point-overflow-and-underflow-behavior","title":"Floating Point Overflow and Underflow Behavior","text":"<p>Floating point operations that exceed the representable range will result in <code>Infinity</code> or <code>-Infinity</code>, while operations resulting in values too close to zero will result in <code>0.0</code>. Operations resulting in undefined values will yield <code>NaN</code>.</p> <pre><code>float32 large = 3.4e38f32 * 10.0f32;  // Results in Infinity\nfloat32 small = 1.0e-38f32 / 10.0f32; // Results in 0.0\nfloat32 undefined = 0.0f32 / 0.0f32;      // Results in NaN\n</code></pre>"},{"location":"reference/type_system/#boolean-type-bool","title":"Boolean Type (<code>bool</code>)","text":"<p>The <code>bool</code> type has only two possible values: <code>true</code> and <code>false</code>. It's commonly used in conditional expressions.</p> <pre><code>bool userLoggedIn = true;\nbool hasPermission = false;\n\n// Boolean operations\nbool canAccess = userLoggedIn &amp;&amp; hasPermission;  // Logical AND\nbool needsAttention = !userLoggedIn || !hasPermission;  // Logical OR and NOT\n</code></pre> <p>Boolean values support:</p> <ul> <li>Logical operations: <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT)</li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"reference/type_system/#string-type-string","title":"String Type (<code>string</code>)","text":"<p>The <code>string</code> type represents sequences of characters. Strings in firescript are immutable.</p> <pre><code>string greeting = \"Hello\";\nstring name = \"World\";\nstring message = greeting + \", \" + name + \"!\";  // String concatenation with +\n\n// Multi-line strings\nstring paragraph = \"This is a\nmulti-line\nstring\";\n</code></pre> <p>Strings support:</p> <ul> <li>Concatenation: <code>+</code></li> <li>Comparison: <code>==</code>, <code>!=</code></li> </ul>"},{"location":"reference/type_system/#character-type-char","title":"Character Type (<code>char</code>)","text":"<p>The <code>char</code> type represents a single character and is currently implemented as a string with length 1.</p> <pre><code>char letter = \"A\";\nchar digit = \"7\";\nchar newline = \"\\n\";  // Special character\n</code></pre>"},{"location":"reference/type_system/#arrays","title":"Arrays","text":"<p>Arrays are fixed-size ordered collections of elements of the same type.</p>"},{"location":"reference/type_system/#declaration-and-initialization","title":"Declaration and Initialization","text":"<pre><code>// With initial values\nint8[5] numbers = [1, 2, 3, 4, 5];\nstring[3] fruits = [\"apple\", \"banana\", \"cherry\"];\n</code></pre>"},{"location":"reference/type_system/#array-operations","title":"Array Operations","text":"<pre><code>int8[3] scores = [85, 92, 78];\n\n// Accessing elements (zero-based indexing)\nint8 firstScore = scores[0];  // 85\n\n// Modifying elements\nscores[1] = 95;  // Array becomes [85, 95, 78]\n\n// Array properties\nint8 count = scores.length;  // 3\n</code></pre>"},{"location":"reference/type_system/#nullability","title":"Nullability","text":"<p>By default, variables cannot hold the value <code>null</code>. To allow a variable to be assigned <code>null</code>, you must explicitly declare it as <code>nullable</code>.</p>"},{"location":"reference/type_system/#declaring-nullable-variables","title":"Declaring Nullable Variables","text":"<pre><code>nullable string username = null;  // Allowed\nstring title = \"Default\";\n\n// title = null;  // Error: Cannot assign null to non-nullable type 'string'\n\nusername = \"John\";  // Can be assigned a non-null value later\n</code></pre>"},{"location":"reference/type_system/#working-with-nullable-values","title":"Working with Nullable Values","text":"<p>When working with nullable variables, it's important to check for null before using them:</p> <pre><code>nullable string data = null;\n\n// Safe pattern\nif (data != null) {\n    print(data);\n}\n\n// Could cause a runtime error if not checked\nprint(data);  // Might try to print null\n</code></pre>"},{"location":"reference/type_system/#type-compatibility-and-conversions","title":"Type Compatibility and Conversions","text":"<p>firescript has strict typing rules but provides explicit conversion functions for common type conversions.</p>"},{"location":"reference/type_system/#built-in-type-conversion-functions","title":"Built-in Type Conversion Functions","text":"<pre><code>// String to numeric conversions\nstring numStr = \"42\";\nint8 num = toInt(numStr);           // 42\nfloat32 floatVal = toFloat(\"3.14\");  // 3.14\nfloat64 doubleVal = toDouble(\"2.71828\");  // 2.71828\n\n// Numeric to string conversions\nstring strFromInt = toString(42);      // \"42\"\nstring strFromFloat = toString(3.14);  // \"3.14\"\n\n// Boolean conversions\nbool boolValue = toBool(\"true\");  // true\nstring strFromBool = toString(false);  // \"false\"\n\n// Character conversion\nchar first = toChar(\"Hello\");  // \"H\" - first character of string\n</code></pre>"},{"location":"reference/type_system/#implicit-type-conversions","title":"Implicit Type Conversions","text":"<p>firescript generally does not perform implicit type conversions, with some exceptions:</p> <ol> <li>In binary numeric operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) between different numeric types:</li> <li>If one operand is <code>floatN</code>, the result is <code>floatN</code></li> <li>If one operand is <code>floatN</code> and the other is <code>intN</code>, the result is <code>floatN</code></li> </ol> <pre><code>int8 intVal = 5;\nfloat32 floatVal = 2.5;\nfloat32 doubleVal = 3.14;\n\nfloat32 result1 = intVal + floatVal;    // Result is 7.5f32\nfloat32 result2 = floatVal * doubleVal;  // Result is 7.85f32\n</code></pre> <ol> <li>String concatenation with <code>+</code> will convert non-string values to strings:</li> </ol> <pre><code>string message = \"Count: \" + 42;  // \"Count: 42\"\nstring status = \"Active: \" + true;  // \"Active: true\"\n</code></pre>"},{"location":"reference/type_system/#type-checking-and-enforcement","title":"Type Checking and Enforcement","text":"<p>The firescript parser includes a type-checking phase that runs after the initial syntax parsing.</p>"},{"location":"reference/type_system/#static-type-checking","title":"Static Type Checking","text":"<ol> <li> <p>Variable Declarations: When you declare a variable (<code>int8 x = 5;</code>), the type checker verifies that the type of the initializer (<code>5</code>, which is <code>int8</code>) matches the declared type (<code>int8</code>).</p> </li> <li> <p>Assignments: When assigning a value to an existing variable (<code>x = 10;</code>), the checker ensures the assigned value's type is compatible with the variable's declared type.</p> </li> <li> <p>Expressions: Operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&gt;</code>, etc.) are checked to ensure they are used with compatible operand types. For example, arithmetic operators generally require numeric types (<code>intN</code>, <code>floatN</code>), while <code>+</code> can also be used for string concatenation. The result type of an expression is also determined (e.g., <code>1 + 2.0</code> results in a <code>float32</code>).</p> </li> <li> <p>Function Calls: Arguments passed to functions are checked against the expected parameter types. The return value type is also enforced.</p> </li> <li> <p>Method Calls: Similar to functions, arguments and the object the method is called on are type-checked.</p> </li> <li> <p>Array Operations: Indexing requires an integer, and assigning elements requires matching the array's element type.</p> </li> </ol>"},{"location":"reference/type_system/#type-errors","title":"Type Errors","text":"<p>Type errors found during the checking phase will prevent the code from compiling further, providing early feedback on potential issues:</p> <pre><code>string name = \"John\";\nint8 age = 30;\n\nage = \"thirty\";  // Type error: Cannot assign string to int\nname = 25;       // Type error: Cannot assign int to string\nbool result = age + name;  // Type error: Cannot add int and string\n                           // Also cannot assign result to bool\n</code></pre>"},{"location":"reference/type_system/#type-introspection","title":"Type Introspection","text":"<p>The <code>typeof</code> built-in function returns a string representing the type of a value:</p> <pre><code>// Future syntax\nstring type1 = typeof(42);        // \"int8\"\nstring type2 = typeof(3.14);      // \"float32\"\nstring type3 = typeof(\"hello\");   // \"string\"\nstring type4 = typeof(true);      // \"bool\"\nstring type5 = typeof([1, 2, 3]); // \"int8[]\"\n</code></pre>"},{"location":"reference/type_system/#standard-library-types-planned","title":"Standard Library Types (Planned)","text":"<p>The following standard library types are planned but not yet implemented: * <code>BigInt</code>: Arbitrary-precision integers for calculations requiring more than 64 bits. * <code>Decimal</code>: Fixed-point, arbitrary-precision decimal type for precise calculations. * <code>list&lt;T&gt;</code>: A dynamic array type that can grow and shrink, unlike fixed-size arrays.</p>"},{"location":"reference/type_system/#advanced-type-features-planned","title":"Advanced Type Features (Planned)","text":"<p>The following advanced type features are planned but not yet implemented:</p>"},{"location":"reference/type_system/#tuples","title":"Tuples","text":"<p>Tuples will allow grouping of values with different types. They will be immutable and can be accessed by index:</p> <pre><code>// Future syntax\ntuple&lt;int8, string&gt; person = (30, \"John\");\nint8 age = person[0];  // 30\nstring name = person[1];  // \"John\"\n</code></pre>"},{"location":"reference/type_system/#generics","title":"Generics","text":"<p>Generic types will allow for more flexible and reusable code:</p> <pre><code>// Future syntax\nT max&lt;T&gt;(T a, T b) {\n    if (a &gt; b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint largerInt = max&lt;int&gt;(5, 10);  // 10\nstring largerString = max&lt;string&gt;(\"apple\", \"banana\");  // \"banana\"\n</code></pre>"},{"location":"reference/type_system/#user-defined-types-classes","title":"User-Defined Types (Classes)","text":"<p>Classes will enable user-defined types with methods and properties:</p> <pre><code>// Future syntax\nclass Point {\n    float32 x;\n    float32 y;\n\n    Point(this, float32 x, float32 y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    float32 distanceTo(this, Point other) {\n        float32 dx = this.x - other.x;\n        float32 dy = this.y - other.y;\n        return toFloat((dx * dx + dy * dy) ** 0.5);\n    }\n}\n</code></pre>"},{"location":"reference/type_system/#implementation-status","title":"Implementation Status","text":"<p>The current firescript compiler supports:</p> <ul> <li>\u2705 Some Copyable types: <code>bool</code>, <code>string</code>, <code>char</code></li> <li>\u2705 Nullable type modifiers</li> <li>\u2705 Arrays of Copyable types</li> <li>\u2705 Static type checking for expressions and assignments</li> <li>\u2705 Type conversion functions</li> </ul> <p>Not yet implemented:</p> <ul> <li>\u274c All integer types (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>)</li> <li>\u274c All floating point types (<code>float32</code>, <code>float64</code>, <code>float128</code>)</li> <li>\u274c Type introspection with <code>typeof</code></li> <li>\u274c Tuples</li> <li>\u274c Generics</li> <li>\u274c User-defined types (classes)</li> <li>\u274c Interface types</li> <li>\u274c Function types</li> </ul>"},{"location":"reference/variables/","title":"Types &amp; Variables","text":"<p>Note: Tuple types, the generic placeholder <code>T</code>, and declarations without an initializer are not supported by the compiler. Only built-in Copyable types (<code>intN</code>, <code>floatN</code>, <code>bool</code>, <code>string</code>, <code>char</code>) are fully implemented.</p>"},{"location":"reference/variables/#types","title":"Types","text":"<p>Types are defined in the Type System documentation.</p>"},{"location":"reference/variables/#declaration-and-initialization","title":"Declaration and Initialization","text":"<p>Variables in firescript must be declared with an explicit type and initialized in the same statement:</p> <pre><code>int8 age = 30;\nstring name = \"Alice\";\nbool isRegistered = false;\n</code></pre>"},{"location":"reference/variables/#type-inference","title":"Type Inference","text":"<p>firescript does not support automatic type inference:</p> <pre><code>var score = 95;  // Not supported - must specify the type explicitly\nint8 score = 95;  // Supported\n</code></pre>"},{"location":"reference/variables/#constants","title":"Constants","text":"<p>Use the <code>const</code> keyword to declare immutable variables:</p> <pre><code>const int8 MAX_USERS = 100;\nconst string APP_VERSION = \"1.0.0\";\n</code></pre> <p>Constants must be initialized when declared and cannot be reassigned later:</p> <pre><code>const float32 PI = 3.14;\nPI = 3.14159;  // Error: cannot reassign a constant\n</code></pre>"},{"location":"reference/variables/#nullability","title":"Nullability","text":"<p>By default, variables cannot be assigned <code>null</code>. The <code>nullable</code> keyword explicitly allows a variable to hold <code>null</code>:</p> <pre><code>nullable string username = null;  // Valid\nstring password = null;           // Invalid - non-nullable type cannot hold null\n</code></pre> <p>Attempting to use a nullable variable without checking for null may result in runtime errors:</p> <pre><code>nullable string message = null;\n\n// Safe access pattern\nif (message != null) {\n    print(message);\n}\n</code></pre>"},{"location":"reference/variables/#implementation-status","title":"Implementation Status","text":"<p>Variable declaration and initialization is fully supported for some built-in Copyable types. User-defined types and tuples are planned for future versions. Constants and nullability are also planned features.</p>"}]}