// Single line comment

/*
Multi
line
comment
*/

/*
    Philosophy of FireScript

    Static typing is better than dynamic
    Explicit is better than implicit
    Code should be self explanatory
    Code should be easy to read
    Code should be easy to write
    Performance is important and should be easy to achieve
*/

/*
    Operators

    Arithmetic

        +   Addition
        +=  Addition assignment
        ++  Increment
        -   Subtraction
        -=  Subtraction assignment
        --  Decrement
        *   Multiplication
        *=  Multiplication assignment
        /   Division
        /=  Division assignment
        %   Modulus
        %=  Modulus assignment
        **  Exponentiation
        **= Exponentiation assignment

    Assignment

        =   Assignment

    Logic

        ==  Equality
        !=  Inequality
        >   Greater than
        >=  Greater than or equal to
        <   Less than
        <=  Less than or equal to
        &&  Logical and
        ||  Logical or
        !   Logical not
*/

// Variables

// Types are: [int, float, double, bool, string, tuple]

int a = 10;
float b = 10.5;
double c = 10.5;
bool d = true; // or false
string e = "Hello";
tuple<int, double, bool, string> f = (10, 10.5, true, "Hello"); // tuples can contain any type, and are immutable

// Arrays

int[] arr = {1, 2, 3, 4, 5}; // arrays can contain any type, and are mutable. fixed length
int[] arr2 = new int[10]; // create an array of length 10

// Variables can be nullable or non-nullable by adding the "nullable" keyword

nullable int f = null; // nullable
int g = 10; // non-nullable

// To make a variable constant, add the "const" keyword. Constants must be initialized when declared and cannot are immutable

const int h = 10;

// Strings

// Formatted strings

string someString = f"1+1={1+1}"; // By putting `f` in front of a string, you can insert expressions into the string using {expression}

// Logic structures

// If statements

if (true)
{
    // do something
}
else if (true)
{
    // do something else
}
else
{
    // do something else
}

// Loops

// For loops

for (int i = 0; i < 10; i++)
{
    if (i == 5)
    {
        continue; // skip to next iteration
    }

    if (i == 8)
    {
        break; // break out of loop
    }
}

for (int i : ["cat", "dog"]) // iterate over array
{
    // do something
}

// Range loops

// Range in firescript is most similar to python's range function
// Range is a generator, so it does not create an array in memory

for (int i : range(10)) // iterate over range 0-10, exclusive
{
    // do something
}

// range(int end)
// start defaults to 0, step defaults to 1, inclusive defaults to false

// range(int start, int end)
// step defaults to 1, inclusive defaults to false

// range(int start, int end, int step)
// inclusive defaults to false

// range(int start, int end, int step, bool inclusive)

int[] arr = {1, 2, 3, 4, 5};

for (int i : arr) // iterate over array
{
    // do something
}

// While loops

while (true)
{
    // do something
}

// Methods

int add(int a, int b)
{
    return a + b;
}

// Nullable methods and parameters
// Nullable parameters must be the last parameters in the method. Required parameters cannot follow nullable parameters

nullable int add(int a, nullable int b, nullable int c) // b & c are optional. If not provided, they will be null
{
    if (b == null)
    {
        return null; // since the method is nullable, it can return null
    }

    return a + b;
}

// Calling a method with optional parameters

add(10, 10); // The parameters will be assigned in order

add(10, c=10); // The parameters can be assigned by name

// Classes

class Person
{
    // Define class variables
    string name;
    nullable int age;

    // `this` is the class instance. It is passed as the first argument to all constructors and non-static methods
    // it can be called whatever you want
    Person(this, string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    // Constructors can be overloaded

    Person(this, string name)
    {
        this.name = name;
    }

    // Methods can also be overloaded

    string set(this, string name)
    {
        this.name = name;
    }

    string set(this, int age)
    {
        this.age = age;
    }

    string getName(this)
    {
        return this.name;
    }

    int getAge(this)
    {
        return this.age;
    }Functions

    // Static methods
    // Static methods can be called without an instance of the class

    static string getHello()
    {
        return "Hello";

        // Example of calling a static method
        string hello = Person.getHello();
    }

    // Static variables

    static string hello = "Hello";
}

// Inheritance

class Student from Person
{
    string school;

    Student(this, string name, int age, string school)
    {
        this.__parent__(name, age); // call parent constructor *not required*

        this.school = school;
    }

    string getSchool(this)
    {
        return this.school;
    }
}

// Generators

// Generators are methods that can be iterated over

generator int range(int end)
{
    for (int i = 0; i < end; i++)
    {
        yield i;
        
        // yield is like return, but it does not end the method.
        // execution will pause at yield and resume when the value is used
    }
}

//        COMPILER WARNINGS

bool a = true;
if (a = true)
{
    // This gives a warning "Assignment in if statement" because it is likely a mistake
}